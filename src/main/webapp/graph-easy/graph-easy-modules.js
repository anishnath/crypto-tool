/**
 * Graph::Easy Perl modules for WebPerl
 * Auto-generated by bundle-modules.js
 *
 * This file contains all Graph::Easy modules embedded as strings.
 * They will be loaded into WebPerl's virtual filesystem.
 */

window.GraphEasyModules = {
  "Graph/Easy/As_ascii.pm": "#############################################################################\n# Render Nodes/Edges/Cells as ASCII/Unicode box drawing art\n#\n# (c) by Tels 2004-2007. Part of Graph::Easy\n#############################################################################\n\npackage Graph::Easy::As_ascii;\n\n$VERSION = '0.22';\n\nuse utf8;\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy::Edge::Cell;\n\nuse strict;\n\nmy $edge_styles = [ \n  {\n  # style            hor, ver,   cross,\tcorner (SE, SW, NE, NW)\n  'solid'\t => [ '--',  \"|\", '+', '+','+','+','+' ],\t# simple line\n  'double'\t => [ '==',  \"H\", \"#\", '#','#','#','#' ],\t# double line\n  'double-dash'\t => [ '= ',  '\"', \"#\", '#','#','#','#' ],\t# double dashed line\n  'dotted'\t => [ '..',  \":\", ':', '.','.','.','.' ],\t# dotted\n  'dashed'\t => [ '- ',  \"'\", '+', '+','+','+','+' ],\t# dashed\n  'dot-dash'\t => [ '.-',  \"!\", '+', '+','+','+','+' ],\t# dot-dash\n  'dot-dot-dash' => [ '..-', \"!\", '+', '+','+','+','+' ],\t# dot-dot-dash\n  'wave' \t => [ '~~',  \"}\", '+', '*','*','*','*' ],\t# wave\n  'bold' \t => [ '##',  \"#\", '#', '#','#','#','#' ],\t# bold\n  'bold-dash' \t => [ '# ',  \"#\", '#', '#','#','#','#' ],\t# bold-dash\n  'wide' \t => [ '##',  \"#\", '#', '#','#','#','#' ],\t# wide\n  'broad' \t => [ '##',  \"#\", '#', '#','#','#','#' ],\t# broad\n  },\n  {\n  # style            hor, ver,   \t    cross,     corner (SE, SW, NE, NW)\n  'solid'\t => [ '─', '│', '┼',  '┌', '┐', '└', '┘' ],\n  'double'\t => [ '═', '║', '╬',  '╔', '╗', '╚', '╝' ],\n  'double-dash'\t => [ '═'.' ', '∥', '╬',  '╔', '╗', '╚', '╝' ], # double dashed\n  'dotted'\t => [ '·', ':',     '┼',  '┌', '┐', '└', '┘' ], # dotted\n  'dashed'\t => [ '╴', '╵', '┘',  '┌', '┐', '╵', '┘' ], # dashed\n  'dot-dash'\t => [ '·'.'-',  \"!\",   '┼',  '┌', '┐', '└', '┘' ], # dot-dash\n  'dot-dot-dash' => [ ('·' x 2).'-', \"!\",  '┼',  '┌', '┐', '└', '┘' ], # dot-dot-dash\n  'wave' \t => [ '∼', '≀',     '┼',  '┌', '┐', '└', '┘' ], # wave\n  'bold' \t => [ '━', '┃', '╋',  '┏', '┓', '┗', '┛' ], # bold\n  'bold-dash' \t => [ '━'.' ', '╻', '╋',  '┏', '┓', '┗', '┛' ], # bold-dash\n  'broad' \t => [ '▬', '▮', '█',  '█', '█', '█', '█' ], # wide\n  'wide' \t => [ '█', '█', '█',  '█', '█', '█', '█' ], # broad\n\n# these two make it nec. to support multi-line styles for the vertical edge pieces\n#  'broad-dash' \t => [ '◼', '◼', '◼',  '◼', '◼', '◼', '◼' ], # broad-dash\n#  'wide-dash' \t => [ ('█'x 2) .'  ', '█', '█',  '█', '█', '█', '█' ], # wide-dash\n  },\n  ];\n\nsub _edge_style\n  {\n  my ($self, $st) = @_;\n\n  my $g = $self->{graph}->{_ascii_style} || 0;\n  $st = $self->{style} unless defined $st;\n\n  $edge_styles->[$g]->{ $st };\n  }\n\n  #    |       |        |        |        :        }       |     \n  # ===+=== ###+### ....!.... ~~~+~~~ ----+---  ...+... .-.+.-.-\n  #    |       |        |        |        :        {       |   \n\nmy $cross_styles = [\n  # normal cross \n  [\n    {\n    'boldsolid' \t=> '┿',\n    'solidbold' \t=> '╂',\n    'doublesolid' \t=> '╪',\n    'soliddouble' \t=> '╫',\n    'dashedsolid' \t=> '┤',\n    'soliddashed' \t=> '┴',\n    'doubledashed' \t=> '╧',\n    'dasheddouble' \t=> '╢',\n    },\n    {\n    'boldsolid'\t\t=> '+',  \n    'dashedsolid'\t=> '+',  \n    'dottedsolid'\t=> '!',\n    'dottedwave'\t=> '+',  \n    'doublesolid'\t=> '+',  \n    'dot-dashsolid'\t=> '+',  \n    'dot-dot-dashsolid'\t=> '+',  \n    'soliddotted'\t=> '+',  \n    'solidwave'\t\t=> '+',  \n    'soliddashed'\t=> '+',  \n    'soliddouble'\t=> 'H',  \n    'wavesolid'\t\t=> '+',\n    },\n  ],\n  undef,\t# HOR, cannot happen\n  undef,\t# VER, cannot happen\n  undef,\n  undef,\n  undef,\n  undef,\n  # S_E_W -+-\n  #        |\n  [\n    {\n    'solidsolid'\t\t=> '┬',  \n    'boldbold'\t\t\t=> '┳',  \n    'doubledouble'\t\t=> '╦',  \n    'dasheddashed'\t\t=> '╴',  \n    'dotteddotted'\t\t=> '·',  \n    },\n  ],\n  # N_E_W  |\n  #       -+-\n  [ \n    {\n    'solidsolid'\t\t=> '┴',  \n    'boldbold'\t\t\t=> '┻',  \n    'doubledouble'\t\t=> '╩',  \n    'dotteddotted'\t\t=> '·',  \n    },\n  ],\n  # E_N_S  |\n  #        +-\n  #        |\n  [ \n    {\n    'solidsolid'\t\t=> '├',  \n    'boldbold'\t\t\t=> '┣',  \n    'doubledouble'\t\t=> '╠',  \n    'dotteddotted'\t\t=> ':',  \n    },\n  ],\n  # W_N_S  |\n  #       -+\n  #        |\n  [ \n    {\n    'solidsolid'\t\t=> '┤',  \n    'boldbold'\t\t\t=> '┫',  \n    'doubledouble'\t\t=> '╣',  \n    'dotteddotted'\t\t=> ':',  \n    },\n  ] ];\n\nsub _arrow_style\n  {\n  my $self = shift;\n\n  my $edge = $self->{edge};\n\n  my $as = $edge->attribute('arrowstyle');\n  $as = 'none' if $edge->{undirected};\n  $as;\n  }\n\nsub _arrow_shape\n  {\n  my $self = shift;\n\n  my $edge = $self->{edge};\n\n  my $as = $edge->attribute('arrowshape');\n  $as;\n  }\n\nsub _cross_style\n  {\n  my ($self, $st, $corner_type) = @_;\n\n  my $g = $self->{graph}->{_ascii_style} || 0;\n\n  # 0 => 1, 1 => 0\n  $g = 1 - $g;\n\n  # for ASCII, one style fist all (e.g a joint has still \"+\" as corner)\n  $corner_type = 0 unless defined $corner_type;\n  $corner_type = 0 if $g == 1;\n\n  $cross_styles->[$corner_type]->[$g]->{ $st };\n  }\n\nsub _insert_label\n  {\n  my ($self, $fb, $xs, $ys, $ws, $hs, $align_ver) = @_;\n\n  my $align = $self->{edge}->attribute('align');\n  \n  my ($lines,$aligns) = $self->_aligned_label($align);\n\n  $ys = $self->{h} - scalar @$lines + $ys if $ys < 0; \n\n  $ws ||= 0; $hs ||= 0;\n  my $w = $self->{w} - $ws - $xs;\n  my $h = $self->{h} - $hs - $ys;\n\n  $self->_printfb_aligned ($fb, $xs, $ys, $w, $h, $lines, $aligns, $align_ver);\n  }\n\nsub _draw_hor\n  {\n  # draw a HOR edge piece\n  my ($self, $fb) = @_;\n\n  my $style = $self->_edge_style();\n  \n  my $w = $self->{w};\n  # '-' => '-----', '.-' => '.-.-.-'\n  # \"(2 + ... )\" to get space for the offset\n  my $len = length($style->[0]); \n  my $line = $style->[0] x (2 + $w / $len); \n\n  # '.-.-.-' => '-.-.-' if $x % $ofs == 1 (e.g. on odd positions)\n  my $ofs = $self->{rx} % $len;\n  my $type = ($self->{type} & (~EDGE_MISC_MASK));\n  substr($line,0,$ofs) = '' if $ofs != 0\n    && ($type != EDGE_SHORT_E && $type != EDGE_SHORT_W);\n\n  $line = substr($line, 0, $w) if length($line) > $w;\n\n  # handle start/end point\n\n  my $flags = $self->{type} & EDGE_FLAG_MASK;\n\n  my $as = $self->_arrow_style();\n  my $ashape; $ashape = $self->_arrow_shape() if $as ne 'none';\n\n  my $x = 0;\t\t\t\t# offset for the edge line\n  my $xs = 1;\t\t\t\t# offset for the edge label\n  my $xr = 0;\t\t\t\t# right offset for label\n  if (($flags & EDGE_START_W) != 0)\n    {\n    $x++; chop($line);\t\t\t# ' ---'\n    $xs++;\n    }\n  if (($flags & EDGE_START_E) != 0)\n    {\n    chop($line);\t\t\t# '--- '\n    }\n\n  if (($flags & EDGE_END_E) != 0)\n    {\n    # '--> '\n    chop($line);\n    substr($line,-1,1) = $self->_arrow($as, ARROW_RIGHT, $ashape) if $as ne 'none';\n    $xr++;\n    }\n  if (($flags & EDGE_END_W) != 0)\n    {\n    # ' <--'\n    substr($line,0,1) = ' ' if $as eq 'none';\n    substr($line,0,2) = ' ' . $self->_arrow($as, ARROW_LEFT, $ashape) if $as ne 'none';\n    $xs++;\n    }\n\n  $self->_printfb_line ($fb, $x, $self->{h} - 2, $line);\n\n  $self->_insert_label($fb, $xs, 0, $xs+$xr, 2, 'bottom' )  \n   if ($self->{type} & EDGE_LABEL_CELL);\n\n  }\n\nsub _draw_ver\n  {\n  # draw a VER edge piece\n  my ($self, $fb) = @_;\n\n  my $style = $self->_edge_style();\n\n  my $h = $self->{h};\n  # '|' => '|||||', '{}' => '{}{}{}'\n  my $line = $style->[1] x (1 + $h / length($style->[1]));\n  $line = substr($line, 0, $h) if length($line) > $h;\n\n  my $flags = $self->{type} & EDGE_FLAG_MASK;\n  # XXX TODO: handle here start points\n  # we get away with not handling them because in VER edges\n  # starting points are currently invisible.\n\n  my $as = $self->_arrow_style();\n  if ($as ne 'none')\n    {\n    my $ashape = $self->_arrow_shape();\n    substr($line,0,1) = $self->_arrow($as,ARROW_UP, $ashape)\n      if (($flags & EDGE_END_N) != 0);\n    substr($line,-1,1) = $self->_arrow($as,ARROW_DOWN, $ashape)\n      if (($flags & EDGE_END_S) != 0);\n    }\n  $self->_printfb_ver ($fb, 2, 0, $line);\n\n  $self->_insert_label($fb, 4, 1, 4, 2, 'middle')\n    if ($self->{type} & EDGE_LABEL_CELL);\n\n  }\n\nsub _draw_cross\n  {\n  # draw a CROSS sections, or a joint (which is a 3/4 cross)\n  my ($self, $fb) = @_;\n  \n  # vertical piece\n  my $style = $self->_edge_style( $self->{style_ver} );\n\n  my $invisible = 0;\n  my $line;\n  my $flags = $self->{type} & EDGE_FLAG_MASK;\n  my $type = $self->{type} & EDGE_TYPE_MASK;\n  my $as = $self->_arrow_style();\n  my $y = $self->{h} - 2;\n\n  print STDERR \"# drawing cross at $self->{x},$self->{y} with flags $flags\\n\" if $self->{debug};\n\n  if ($self->{style_ver} ne 'invisible')\n    {\n    my $h = $self->{h};\n    # '|' => '|||||', '{}' => '{}{}{}'\n    $line = $style->[1] x (2 + $h / length($style->[1])); \n\n    $line = substr($line, 0, $h) if length($line) > $h;\n\n    if ($as ne 'none')\n      {\n      my $ashape = $self->_arrow_shape();\n      substr($line,0,1) = $self->_arrow($as,ARROW_UP, $ashape) \n        if (($flags & EDGE_END_N) != 0);\n      substr($line,-1,1) = $self->_arrow($as,ARROW_DOWN, $ashape)\n        if (($flags & EDGE_END_S) != 0);\n      }\n\n    # create joints\n    substr($line,0,$y) = ' ' x $y if $type == EDGE_S_E_W;\n    substr($line,$y,2) = '  ' if $type == EDGE_N_E_W;\n\n    $self->_printfb_ver ($fb, 2, 0, $line);\n    }\n  else { $invisible++; }\n\n  # horizontal piece\n  $style = $self->_edge_style();\n  \n  my $ashape; $ashape = $self->_arrow_style() if $as ne 'none';\n\n  if ($self->{style} ne 'invisible')\n    {\n    my $w = $self->{w};\n    # '-' => '-----', '.-' => '.-.-.-'\n    my $len = length($style->[0]); \n    $line = $style->[0] x (2 + $w / $len); \n  \n    # '.-.-.-' => '-.-.-' if $x % $ofs == 1 (e.g. on odd positions)\n    my $ofs = $self->{rx} % $len;\n    substr($line,0,$ofs) = '' if $ofs != 0;\n\n    $line = substr($line, 0, $w) if length($line) > $w;\n  \n    my $x = 0;\n    if (($flags & EDGE_START_W) != 0)\n      {\n      $x++; chop($line);\t\t# ' ---'\n      }\n    if (($flags & EDGE_START_E) != 0)\n      {\n      chop($line);\t\t\t# '--- '\n      }\n    if (($flags & EDGE_END_E) != 0)\n      {\n      # '--> '\n      chop($line);\n      substr($line,-1,1) = $self->_arrow($as, ARROW_RIGHT, $ashape)\n       if $as ne 'none';\n      }\n    if (($flags & EDGE_END_W) != 0)\n      {\n      # ' <--'\n      substr($line,0,1) = ' ' if $as eq 'none';\n      substr($line,0,2) = ' ' . $self->_arrow($as, ARROW_LEFT, $ashape)\n       if $as ne 'none';\n      }\n\n    substr($line,0,2) = '  ' if $type == EDGE_E_N_S;\n    substr($line,2,$self->{w}-2) = ' ' x ($self->{w}-2) if $type == EDGE_W_N_S;\n\n    $self->_printfb_line ($fb, $x, $y, $line);\n    }\n  else { $invisible++; }\n\n  if (!$invisible)\n    {\n    # draw the crossing character only if both lines are visible\n    my $cross = $style->[2];\n    my $s = $self->{style} . $self->{style_ver};\n    $cross = ($self->_cross_style($s,$type) || $cross); # if $self->{style_ver} ne $self->{style};\n\n    $self->_printfb ($fb, 2, $y, $cross);\n    }\n\n  # done\n  }\n\nsub _draw_corner\n  {\n  # draw a corner (N_E, S_E etc)\n  my ($self, $fb) = @_;\n\n  my $type = $self->{type} & EDGE_TYPE_MASK;\n  my $flags = $self->{type} & EDGE_FLAG_MASK;\n\n  ############\n  #   ........\n  # 0 :      :\n  # 1 :      :    label would appear here\n  # 2 :  +---:    (w-3) = 3 chars wide\n  # 3 :  |   :    always 1 char high\n  #   .......:\n  #    012345 \n\n  # draw the vertical piece\n \n  # get the style\n  my $style = $self->_edge_style();\n \n  my $h = 1; my $y = $self->{h} -1; \n  if ($type == EDGE_N_E || $type == EDGE_N_W)\n    {\n    $h = $self->{h} - 2; $y = 0; \n    }\n  # '|' => '|||||', '{}' => '{}{}{}'\n  my $line = $style->[1] x (1 + $h / length($style->[1])); \n  $line = substr($line, 0, $h) if length($line) > $h;\n\n  my $as = $self->_arrow_style();\n  my $ashape;\n  if ($as ne 'none')\n    {\n    $ashape = $self->_arrow_shape();\n    substr($line,0,1) = $self->_arrow($as, ARROW_UP, $ashape)\n      if (($flags & EDGE_END_N) != 0);\n    substr($line,-1,1) = $self->_arrow($as, ARROW_DOWN, $ashape)\n      if (($flags & EDGE_END_S) != 0);\n    }\n  $self->_printfb_ver ($fb, 2, $y, $line);\n\n  # horizontal piece\n  my $w = $self->{w} - 3; $y = $self->{h} - 2; my $x = 3;\n  if ($type == EDGE_N_W || $type == EDGE_S_W)\n    {\n    $w = 2; $x = 0; \n    }\n\n  # '-' => '-----', '.-' => '.-.-.-'\n  my $len = length($style->[0]); \n  $line = $style->[0] x (2 + $w / $len); \n  \n  # '.-.-.-' => '-.-.-' if $x % $ofs == 1 (e.g. on odd positions)\n  my $ofs = ($x + $self->{rx}) % $len;\n  substr($line,0,$ofs) = '' if $ofs != 0;\n\n  $line = substr($line, 0, $w) if length($line) > $w;\n  \n  substr($line,-1,1) = ' ' if ($flags & EDGE_START_E) != 0;\n  substr($line,0,1) = ' '  if ($flags & EDGE_START_W) != 0;\n\n  if (($flags & EDGE_END_E) != 0)\n    {\n    substr($line,-1,1) = ' ' if $as eq 'none';\n    substr($line,-2,2) = $self->_arrow($as, ARROW_RIGHT, $ashape) . ' ' if $as ne 'none';\n    }\n  if (($flags & EDGE_END_W) != 0)\n    {\n    substr($line,0,1) = ' ' if $as eq 'none';\n    substr($line,0,2) = ' ' . $self->_arrow($as, ARROW_LEFT, $ashape) if $as ne 'none';\n    }\n\n  $self->_printfb_line ($fb, $x, $y, $line);\n\n  my $idx = 3; \t\t# corner (SE, SW, NE, NW)\n  $idx = 4 if $type == EDGE_S_W;\n  $idx = 5 if $type == EDGE_N_E;\n  $idx = 6 if $type == EDGE_N_W;\n\n  # insert the corner character\n  $self->_printfb ($fb, 2, $y, $style->[$idx]);\n  }\n\nsub _draw_loop_hor\n  {\n  my ($self, $fb) = @_;\n\n  my $type = $self->{type} & EDGE_TYPE_MASK;\n  my $flags = $self->{type} & EDGE_FLAG_MASK;\n\n  ############\n  #   ..........\n  # 0 :        :\n  # 1 :        :    label would appear here\n  # 2 :  +--+  :    (w-6) = 2 chars wide\n  # 3 :  |  v  :    1 char high\n  #   .........:\n  #    01234567 \n\n  ############\n  #   ..........\n  # 0 :  |  ^  :    ver is h-2 chars high\t\n  # 1 :  |  |  :    label would appear here\n  # 2 :  +--+  :    (w-6) = 2 chars wide\n  # 3 :        :\n  #   .........:\n  #    01234567 \n\n  # draw the vertical pieces\n \n  # get the style\n  my $style = $self->_edge_style();\n \n  my $h = 1; my $y = $self->{h} - 1; \n  if ($type == EDGE_S_W_N)\n    {\n    $h = $self->{h} - 2; $y = 0; \n    }\n  # '|' => '|||||', '{}' => '{}{}{}'\n  my $line = $style->[1] x (1 + $h / length($style->[1])); \n  $line = substr($line, 0, $h) if length($line) > $h;\n  \n  my $as = $self->_arrow_style();\n  my $ashape; $ashape = $self->_arrow_shape() if $as ne 'none';\n\n  if ($self->{edge}->{bidirectional} && $as ne 'none')\n    {\n    substr($line,0,1)  = $self->_arrow($as, ARROW_UP, $ashape) if (($flags & EDGE_END_N) != 0);\n    substr($line,-1,1) = $self->_arrow($as, ARROW_DOWN, $ashape) if (($flags & EDGE_END_S) != 0);\n    }\n  $self->_printfb_ver ($fb, $self->{w}-3, $y, $line);\n\n  if ($as ne 'none')\n    {\n    substr($line,0,1)  = $self->_arrow($as, ARROW_UP, $ashape) if (($flags & EDGE_END_N) != 0);\n    substr($line,-1,1) = $self->_arrow($as, ARROW_DOWN, $ashape) if (($flags & EDGE_END_S) != 0);\n    }\n  $self->_printfb_ver ($fb, 2, $y, $line);\n\n  # horizontal piece\n  my $w = $self->{w} - 6; $y = $self->{h} - 2; my $x = 3;\n\n  # '-' => '-----', '.-' => '.-.-.-'\n  my $len = length($style->[0]); \n  $line = $style->[0] x (2 + $w / $len); \n  \n  # '.-.-.-' => '-.-.-' if $x % $ofs == 1 (e.g. on odd positions)\n  my $ofs = ($x + $self->{rx}) % $len;\n  substr($line,0,$ofs) = '' if $ofs != 0;\n\n  $line = substr($line, 0, $w) if length($line) > $w;\n  \n  $self->_printfb_line ($fb, $x, $y, $line);\n  \n  my $corner_idx = 3; $corner_idx = 5 if $type == EDGE_S_W_N;\n\n  # insert the corner characters\n  $self->_printfb ($fb, 2, $y, $style->[$corner_idx]);\n  $self->_printfb ($fb, $self->{w}-3, $y, $style->[$corner_idx+1]);\n\n  my $align = 'bottom'; $align = 'top' if $type == EDGE_S_W_N;\n  $self->_insert_label($fb, 4, 0, 4, 2, $align)\n  if ($self->{type} & EDGE_LABEL_CELL);\n\n  # done\n  }\n\nsub _draw_loop_ver\n  {\n  my ($self, $fb) = @_;\n\n  my $type = $self->{type} & EDGE_TYPE_MASK;\n  my $flags = $self->{type} & EDGE_FLAG_MASK;\n\n  ############\n  #   ........\n  # 0 :      :  label would appear here\n  # 1 :  +-- :\n  # 2 :  |   :\n  # 3 :  +-> :\n  #   .......:\n  #    012345 \n\n  #   ........\n  # 0 :      :  label would appear here\n  # 1 : --+  :\n  # 2 :   |  :\n  # 3 : <-+  :\n  #   .......:\n  #    012345 \n\n  ###########################################################################\n  # draw the vertical piece\n \n  # get the style\n  my $style = $self->_edge_style();\n \n  my $h = 1; my $y = $self->{h} - 3; \n  # '|' => '|||||', '{}' => '{}{}{}'\n  my $line = $style->[1] x (1 + $h / length($style->[1])); \n  $line = substr($line, 0, $h) if length($line) > $h;\n\n  my $x = 2; $x = $self->{w}-3 if ($type == EDGE_E_S_W);\n  $self->_printfb_ver ($fb, $x, $y, $line);\n\n  ###########################################################################\n  # horizontal pieces\n\n  my $w = $self->{w} - 3; $y = $self->{h} - 4;\n  $x = 2; $x = 1 if ($type == EDGE_E_S_W);\n\n  # '-' => '-----', '.-' => '.-.-.-'\n  my $len = length($style->[0]); \n  $line = $style->[0] x (2 + $w / $len); \n  \n  # '.-.-.-' => '-.-.-' if $x % $ofs == 1 (e.g. on odd positions)\n  my $ofs = ($x + $self->{rx}) % $len;\n  substr($line,0,$ofs) = '' if $ofs != 0;\n\n  $line = substr($line, 0, $w) if length($line) > $w;\n\n  my $as = $self->_arrow_style();\n  my $ashape; $ashape = $self->_arrow_shape() if $as ne 'none';\n \n  if ($self->{edge}->{bidirectional} && $as ne 'none')\n    {\n    substr($line,0,1)  = $self->_arrow($as, ARROW_LEFT, $ashape) if (($flags & EDGE_END_W) != 0);\n    substr($line,-1,1) = $self->_arrow($as, ARROW_RIGHT, $ashape) if (($flags & EDGE_END_E) != 0);\n    }\n\n  $self->_printfb_line ($fb, $x, $y, $line);\n\n  if ($as ne 'none')\n    {\n    substr($line,0,1)  = $self->_arrow($as, ARROW_LEFT, $ashape) if (($flags & EDGE_END_W) != 0);\n    substr($line,-1,1) = $self->_arrow($as, ARROW_RIGHT, $ashape) if (($flags & EDGE_END_E) != 0);\n    }\n  \n  $self->_printfb_line ($fb, $x, $self->{h} - 2, $line);\n\n  $x = 2; $x = $self->{w}-3 if ($type == EDGE_E_S_W);\n\n  my $corner_idx = 3; $corner_idx = 4 if $type == EDGE_E_S_W;\n\n  # insert the corner characters\n  $self->_printfb ($fb, $x, $y, $style->[$corner_idx]);\n  $self->_printfb ($fb, $x, $self->{h}-2, $style->[$corner_idx+2]);\n\n  $x = 4; $x = 3 if ($type == EDGE_E_S_W);\n  $self->_insert_label($fb, $x, 0, $x, 4, 'bottom')\n    if ($self->{type} & EDGE_LABEL_CELL);\n\n  # done\n  }\n\n# which method to call for which edge type\nmy $draw_dispatch =\n  {\n  EDGE_HOR() => '_draw_hor',\n  EDGE_VER() => '_draw_ver',\n\n  EDGE_S_E() => '_draw_corner', \n  EDGE_S_W() => '_draw_corner',\n  EDGE_N_E() => '_draw_corner',\n  EDGE_N_W() => '_draw_corner',\n\n  EDGE_CROSS() => '_draw_cross',\n  EDGE_W_N_S() => '_draw_cross',\n  EDGE_E_N_S() => '_draw_cross',\n  EDGE_N_E_W() => '_draw_cross',\n  EDGE_S_E_W() => '_draw_cross',\n\n  EDGE_N_W_S() => '_draw_loop_hor',\n  EDGE_S_W_N() => '_draw_loop_hor',\n\n  EDGE_E_S_W() => '_draw_loop_ver',\n  EDGE_W_S_E() => '_draw_loop_ver',\n  };\n\nsub _draw_label\n  {\n  # This routine is cunningly named _draw_label, because it actually\n  # draws the edge line(s). The label text will be drawn by the individual\n  # routines called below.\n  my ($self, $fb, $x, $y) = @_;\n\n  my $type = $self->{type} & EDGE_TYPE_MASK;\n\n  # for cross sections, we maybe need to draw one of the parts:\n  return if $self->attribute('style') eq 'invisible' && $type ne EDGE_CROSS;\n\n  my $m = $draw_dispatch->{$type};\n\n  $self->_croak(\"Unknown edge type $type\") unless defined $m;\n\n  # store the coordinates of our upper-left corner (for seamless rendering)\n  $self->{rx} = $x || 0; $self->{ry} = $y || 0;\n  $self->$m($fb);\n  delete $self->{rx}; delete $self->{ry};\t# no longer needed\n  }\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy::Node;\n\nuse strict;\n\nsub _framebuffer\n  {\n  # generate an actual framebuffer consisting of spaces\n  my ($self, $w, $h) = @_;\n\n  print STDERR \"# trying to generate framebuffer of undefined width for $self->{name}\\n\",\n               join (\": \", caller(),\"\\n\") if !defined $w;\n\n  my @fb;\n\n  my $line = ' ' x $w;\n  for my $y (1..$h)\n    {\n    push @fb, $line;\n    }\n  \\@fb;\n  }\n\nsub _printfb_aligned\n  {\n  my ($self,$fb, $x1,$y1, $w,$h, $lines, $aligns, $align_ver) = @_;\n\n  $align_ver = 'middle' unless $align_ver;\n\n  # $align_ver eq 'middle':\n  my $y = $y1 + ($h / 2) - (scalar @$lines / 2);\n  if ($align_ver eq 'top')\n    {\n    $y = $y1; \n    $y1 = 0;\n    }\n  if ($align_ver eq 'bottom')\n    {\n    $y = $h - scalar @$lines; $y1 = 0; \n    }\n\n  my $xc = ($w / 2);\n\n  my $i = 0;\n  while ($i < @$lines)\n    {\n    # get the line and her alignment\n    my ($l,$al) = ($lines->[$i],$aligns->[$i]);\n\n    my $x = 0;\t\t\t# left is default\n\n    $x = $xc - length($l) / 2 if $al eq 'c';\n    $x = $w - length($l) if $al eq 'r';\n\n    # now print the line (inlined print_fb_line for speed)\n    substr ($fb->[int($y+$i+$y1)], int($x+$x1), length($l)) = $l;\n\n    $i++;\n    }\n  }\n\nsub _printfb_line\n  {\n  # Print one textline into a framebuffer\n  # Caller MUST ensure proper size of FB, for speed reasons,\n  # we do not check whether text fits!\n  my ($self, $fb, $x, $y, $l) = @_;\n\n  # [0] = '0123456789...'\n\n  substr ($fb->[$y], $x, length($l)) = $l;\n  }\n\nsub _printfb\n  {\n  # Print (potential a multiline) text into a framebuffer\n  # Caller MUST ensure proper size of FB, for speed reasons,\n  # we do not check whether the text fits!\n  my ($self, $fb, $x, $y, @lines) = @_;\n\n  # [0] = '0123456789...'\n  # [1] = '0123456789...' etc\n\n  for my $l (@lines)\n    {\n#    # XXX DEBUG:\n#    if ( $x + length($l) > length($fb->[$y]))\n#      {\n#      require Carp;\n#      Carp::confess(\"substr outside framebuffer\");\n#      }\n\n    substr ($fb->[$y], $x, length($l)) = $l; $y++;\n    }\n  }\n\nsub _printfb_ver\n  {\n  # Print a string vertical into a framebuffer.\n  # Caller MUST ensure proper size of FB, for speed reasons,\n  # we do not check whether text fits!\n  my ($self, $fb, $x, $y, $line) = @_;\n\n  # this more than twice as fast as:\n  #  \"@pieces = split//,$line; _printfb(...)\"\n\n  my $y1 = $y + length($line);\n  substr ($fb->[$y1], $x, 1) = chop($line) while ($y1-- > $y);\n  }\n\n # for ASCII and box drawing:\n\n # the array contains for each style:\n # upper left edge\n # upper right edge\n # lower right edge\n # lower left edge\n # hor style (top edge)\n # hor style (bottom side)\n # ver style (right side) (multiple characters possible)\n # ver style (left side) (multiple characters possible)\n # T crossing (see drawing below)\n # T to right\n # T to left\n # T to top\n # T shape (to bottom)\n \n #\n # +-----4-----4------+\n # |     |     |      |\n # |     |     |      |\n # |     |     |      |\n # 1-----0-----3------2\t\t1 = T to right, 2 = T to left, 3 T to top\n # |     |\t\t\t0 = cross, 4 = T shape\n # |     |\n # |     |\n # +-----+\n\nmy $border_styles = \n  [\n  {\n  solid =>\t\t[ '+', '+', '+', '+', '-',   '-',   [ '|'      ], [ '|'     ], '+', '+', '+', '+', '+' ],\n  dotted =>\t\t[ '.', '.', ':', ':', '.',   '.',   [ ':'      ], [ ':'     ], '.', '.', '.', '.', '.' ],\n  dashed =>\t\t[ '+', '+', '+', '+', '- ',  '- ',  [ \"'\"      ], [ \"'\"     ], '+', '+', '+', '+', '+' ],\n  'dot-dash' =>\t\t[ '+', '+', '+', '+', '.-',  '.-',  [ '!'      ], [ '!'     ], '+', '+', '+', '+', '+' ],\n  'dot-dot-dash' =>\t[ '+', '+', '+', '+', '..-', '..-', [ '|', ':' ], [ '|',':' ], '+', '+', '+', '+', '+' ],\n  bold =>\t\t[ '#', '#', '#', '#', '#',   '#',   [ '#'      ], [ '#'     ], '#', '#', '#', '#', '#' ],\n  'bold-dash' =>\t[ '#', '#', '#', '#', '# ',  '# ',  ['#',' '   ], [ '#',' ' ], '#', '#', '#', '#', '#' ],\n  double =>\t\t[ '#', '#', '#', '#', '=',   '=',   [ 'H'      ], [ 'H'     ], '#', '#', '#', '#', '#' ],\n  'double-dash' =>\t[ '#', '#', '#', '#', '= ',  '= ',  [ '\"'      ], [ '\"'     ], '#', '#', '#', '#', '#' ],\n  wave =>\t\t[ '+', '+', '+', '+', '~',   '~',   [ '{', '}' ], [ '{','}' ], '+', '+', '+', '+', '+' ],\n  broad =>\t\t[ '#', '#', '#', '#', '#',   '#',   [ '#'      ], [ '#'     ], '#', '#', '#', '#', '#' ],\n  wide =>\t\t[ '#', '#', '#', '#', '#',   '#',   [ '#'      ], [ '#'     ], '#', '#', '#', '#', '#' ],\n  none =>\t\t[ ' ', ' ', ' ', ' ', ' ',   ' ',   [ ' '      ], [ ' '     ], ' ', ' ', ' ', ' ', ' ' ],\n  },\n  {\n  solid =>\t\t[ '┌', '┐', '┘', '└', '─', '─',     [ '│' ], [ '│' ], '┼', '├', '┤', '┴', '┬' ],\n  double =>\t\t[ '╔', '╗', '╝', '╚', '═', '═',     [ '║' ], [ '║' ], '┼', '├', '┤', '┴', '┬' ],\n  dotted =>\t\t[ '┌', '┐', '┘', '└', '⋯', '⋯', [ '⋮' ], [ '⋮' ], '┼', '├', '┤', '┴', '┬' ],\n  dashed =>\t\t[ '┌', '┐', '┘', '└', '−', '−', [ '╎' ], [ '╎' ], '┼', '├', '┤', '┴', '┬' ],\n  'dot-dash' =>\t\t[ '┌', '┐', '┘', '└', '·'.'-', '·'.'-', ['!'], ['!'], '┼', '├', '┤', '┴', '┬' ],\n  'dot-dot-dash' =>\t[ '┌', '┐', '┘', '└', ('·' x 2) .'-', ('·' x 2) .'-', [ '│', ':' ], [ '│', ':' ], '┼', '├', '┤', '┴', '┬' ],\n  bold =>\t\t[ '┏', '┓', '┛', '┗', '━', '━', [ '┃' ], [ '┃' ], '┼', '├', '┤', '┴', '┬' ],\n  'bold-dash' =>\t[ '┏', '┓', '┛', '┗', '━'.' ', '━'.' ', [ '╻' ], [ '╻' ], '┼', '├', '┤', '┴', '┬' ],\n  'double-dash' =>\t[ '╔', '╗', '╝', '╚', '═'.' ', '═'.' ', [ '∥' ], [ '∥' ], '┼', '├', '┤', '┴', '┬' ],\n  wave =>\t\t[ '┌', '┐', '┘', '└', '∼',  '∼', [ '≀' ], [ '≀' ], '┼', '├', '┤', '┴', '┬' ],\n  broad =>\t\t[ '▛', '▜', '▟', '▙', '▀', '▄', [ '▌' ], [ '▐' ], '▄', '├', '┤', '┴', '┬' ],\n  wide =>\t\t[ '█', '█', '█', '█', '█', '█', [ '█' ], [ '█' ], '█', '█', '█', '█', '█' ],\n  none =>\t\t[ ' ', ' ', ' ', ' ', ' ', ' ',  [ ' ' ], [ ' ' ], ' ', ' ', ' ', ' ', ' ', ],\n  },\n  ];\n\n # for boxart and rounded corners on node-borders:\n # upper left edge\n # upper right edge\n # lower right edge\n # lower left edge\n\nmy $rounded_edges = [ '╭', '╮', '╯', '╰', ]; \n\n # for ASCII/boxart drawing slopes/slants\n #             lower-left to upper right (repeated twice)\n #                   lower-right to upper left (repeated twice)\nmy $slants = [\n  # ascii\n  {                    \n  solid\t \t => [ '/'  , '\\\\'   ],\n  dotted\t => [ '.' , '.'     ],\n  dashed\t => [ '/ ', '\\\\ '   ],\n  'dot-dash'\t => [ './', '.\\\\'   ],\n  'dot-dot-dash' => [ '../', '..\\\\' ],\n  bold\t \t => [ '#' , '#'     ],\n  'bold-dash' \t => [ '# ' , '# '   ],\n  'double' \t => [ '/' , '\\\\'    ],\n  'double-dash'\t => [ '/ ' , '\\\\ '  ],\n  wave\t \t => [ '/ ' , '\\\\ '  ],\n  broad\t \t => [ '#' , '#'     ],\n  wide\t \t => [ '#' , '#'     ],\n  },\n  # boxart\n  {                     \n  solid\t \t => [ '╱'  , '╲'   ],\n  dotted\t => [ '⋰' , '⋱'    ],\n  dashed\t => [ '╱ ', '╲ '   ],\n  'dot-dash'\t => [ '.╱', '.╲'   ],\n  'dot-dot-dash' => [ '⋰╱', '⋱╲' ],\n  bold\t \t => [ '#' , '#'    ],\n  'bold-dash' \t => [ '# ' , '# '  ],\n  'double' \t => [ '╱' , '╲'    ],\n  'double-dash'\t => [ '╱ ' , '╲ '  ],\n  wave\t \t => [ '╱ ' , '╲ '  ],\n  broad\t \t => [ '#' , '#'    ],\n  wide\t \t => [ '#' , '#'    ],\n  },\n  ];\n\n # ASCII and box art: the different point shapes and styles\nmy $point_shapes = \n  [ {\n    filled => \n      {\n      'star'\t\t=> '*',\n      'square'\t\t=> '#',\n      'dot'\t\t=> '.',\n      'circle'\t\t=> 'o',  # unfortunately, there is no filled o in ASCII\n      'cross'\t\t=> '+',\n      'diamond'\t\t=> '<>',\n      'x'\t\t=> 'X',\n      },\n    closed => \n      {\n      'star'\t\t=> '*',\n      'square'\t\t=> '#',\n      'dot'\t\t=> '.',\n      'circle'\t\t=> 'o',\n      'cross'\t\t=> '+',\n      'diamond'\t\t=> '<>',\n      'x'\t\t=> 'X',\n      },\n    },\n    {\n    filled =>\n      {\n      'star'\t\t=> '★',\n      'square'\t\t=> '■',\n      'dot'\t\t=> '·',\n      'circle'\t\t=> '●',\n      'cross'\t\t=> '+',\n      'diamond'\t\t=> '◆',\n      'x'\t\t=> '╳',\n      },\n    closed => \n      {\n      'star'\t\t=> '☆',\n      'square'\t\t=> '□',\n      'dot'\t\t=> '·',\n      'circle'\t\t=> '○',\n      'cross'\t\t=> '+',\n      'diamond'\t\t=> '◇',\n      'x'\t\t=> '╳',\n      },\n    }\n  ];  \n\nsub _point_style\n  {\n  my ($self, $shape, $style) = @_;\n\n  return '' if $shape eq 'invisible';\n\n  if ($style =~ /^(star|square|dot|circle|cross|diamond)\\z/)\n    {\n    # support the old \"pointstyle: diamond\" notion:\n    $shape = $style; $style = 'filled';\n    }\n\n  $style = 'filled' unless defined $style;\n  my $g = $self->{graph}->{_ascii_style} || 0;\n  $point_shapes->[$g]->{$style}->{$shape};\n  }\n\nsub _border_style\n  {\n  my ($self, $style, $type) = @_;\n\n  # make a copy so that we can modify it\n  my $g = $self->{graph}->{_ascii_style} || 0;\n  my $s = [ @{ $border_styles->[ $g ]->{$style} } ];\n\n  die (\"Unknown $type border style '$style'\") if @$s == 0;\n\n  my $shape = 'rect';\n  $shape = $self->attribute('shape') unless $self->isa_cell();\n  return $s unless $shape eq 'rounded';\n\n  # if shape: rounded, overlay the rounded edge pieces\n  splice (@$s, 0, 4, @$rounded_edges)\n    if $style =~ /^(solid|dotted|dashed|dot-dash|dot-dot-dash)\\z/;\n\n  # '####' => ' ### '\n  splice (@$s, 0, 4, (' ', ' ', ' ', ' '))\n    if $g == 0 || $style =~ /^(bold|wide|broad|double|double-dash|bold-dash)\\z/;\n\n  $s;\n  }\n\n#############################################################################\n# different arrow styles and shapes in ASCII and boxart\n\nmy $arrow_form =\n  {\n  normal => 0,\n  sleek => 1,\t\t\t# slightly squashed\n  };\n\nmy $arrow_shapes =\n  {\n  triangle => 0,\n  diamond => 1,\n  box => 2,\n  dot => 3,\n  inv => 4,\t\t\t# an inverted triangle\n  line => 5,\n  cross => 6,\n  x => 7,\n  };\n\n# todo: ≪ ≫ \n\nmy $arrow_styles = \n  [\n    [\n    # triangle\n      {\n      open   => [ '>', '<', '^', 'v' ],\n      closed => [ '>', '<', '^', 'v' ],\n      filled => [ '>', '<', '^', 'v' ],\n      },\n      {\n      open   => [ '>', '<', '∧', '∨' ],\n      closed => [ '▷', '◁', '△', '▽' ],\n      filled => [ '▶', '◀', '▲', '▼' ],\n      }\n    ], [\n    # diamond\n      {\n      open   => [ '>', '<', '^', 'v' ],\n      closed => [ '>', '<', '^', 'v' ],\n      filled => [ '>', '<', '^', 'v' ],\n      },\n      {\n      open   => [ '>', '<', '∧', '∨' ],\n      closed => [ '◇', '◇', '◇', '◇' ],\n      filled => [ '◆', '◆', '◆', '◆' ],\n      }\n    ], [\n    # box\n      {\n      open   => [ ']', '[', '°', 'u' ],\n      closed => [ 'D', 'D', 'D', 'D' ],\n      filled => [ '#', '#', '#', '#' ],\n      },\n      {\n      open   => [ '⊐', '⊐', '⊓', '⊔' ],\n      closed => [ '◻', '◻', '◻', '◻' ],\n      filled => [ '◼', '◼', '◼', '◼' ],\n      }\n    ], [\n    # dot\n      {\n      open   => [ ')', '(', '^', 'u' ],\n      closed => [ 'o', 'o', 'o', 'o' ],\n      filled => [ '*', '*', '*', '*' ],\n      },\n      {\n      open   => [ ')', '(', '◠', '◡' ],\n      closed => [ '○', '○', '○', '○' ],\n      filled => [ '●', '●', '●', '●' ],\n      }\n    ], [\n    # inv\n      {\n      open   => [ '<', '>', 'v', '^' ],\n      closed => [ '<', '>', 'v', '^' ],\n      filled => [ '<', '>', 'v', '^' ],\n      },\n      {\n      open   => [ '<', '>', '∨', '∧' ],\n      closed => [ '◁', '▷', '▽', '△' ],\n      filled => [ '◀', '▶', '▼', '▲' ],\n      }\n    ], [\n    # line\n      {\n      open   => [ '|', '|', '_', '-' ],\n      closed => [ '|', '|', '_', '-' ],\n      filled => [ '|', '|', '_', '-' ],\n      },\n      {\n      open   => [ '⎥', '⎢', '_', '¯' ],\n      closed => [ '⎥', '⎢', '_', '¯' ],\n      filled => [ '⎥', '⎢', '_', '¯' ],\n      }\n    ], [\n    # cross\n      {\n      open   => [ '+', '+', '+', '+' ],\n      closed => [ '+', '+', '+', '+' ],\n      filled => [ '+', '+', '+', '+' ],\n      },\n      {\n      open   => [ '┼', '┼', '┼', '┼' ],\n      closed => [ '┼', '┼', '┼', '┼' ],\n      filled => [ '┼', '┼', '┼', '┼' ],\n      }\n    ], [\n    # x\n      {\n      open   => [ 'x', 'x', 'x', 'x' ],\n      closed => [ 'x', 'x', 'x', 'x' ],\n      filled => [ 'x', 'x', 'x', 'x' ],\n      },\n      {\n      open   => [ 'x', 'x', 'x', 'x' ],\n      closed => [ 'x', 'x', 'x', 'x' ],\n      filled => [ '⧓', '⧓', 'x', 'x' ],\n      }\n    ]\n  ];\n\nsub _arrow\n  {\n  # return an arror, depending on style and direction\n  my ($self, $style, $dir, $shape) = @_;\n\n  $shape = '' unless defined $shape;\n  $shape = $arrow_shapes->{$shape} || 0;\n\n  my $g = $self->{graph}->{_ascii_style} || 0;\n  $arrow_styles->[$shape]->[$g]->{$style}->[$dir];\n  }\n\n# To convert an HTML arrow to Unicode:\nmy $arrow_dir = {\n  '&gt;' => 0,\n  '&lt;' => 1,\n  '^' => 2,\n  'v' => 3,\n  };\n\nsub _unicode_arrow\n  {\n  # return an arror in unicode, depending on style and direction\n  my ($self, $shape, $style, $arrow_text) = @_;\n\n  $shape = '' unless defined $shape;\n  $shape = $arrow_shapes->{$shape} || 0;\n\n  my $dir = $arrow_dir->{$arrow_text} || 0;\n\n  $arrow_styles->[$shape]->[1]->{$style}->[$dir];\n  }\n\n#############################################################################\n\n#\n# +---4---4---4---+\n# |   |   |   |   |\n# |   |   |   |   |\n# |   |   |   |   |\n# 1---0---3---0---2\t1 = T to right, 2 = T to left, 3 T to top\n# |   |       |   |\t0 = cross, 4 = T shape\n# |   |       |   |\n# |   |       |   |\n# +---+       +---+\n\nsub _draw_border\n  {\n  # draws a border into the framebuffer\n  my ($self, $fb, $do_right, $do_bottom, $do_left, $do_top, $x, $y) = @_;\n\n  return if $do_right.$do_left.$do_bottom.$do_top eq 'nonenonenonenone';\n\n  my $g = $self->{graph};\n\n  my $w = $self->{w};\n  if ($do_top ne 'none')\n    {\n    my $style = $self->_border_style($do_top, 'top');\n\n    # top-left corner piece is only there if we have a left border\n    my $tl = $style->[0]; $tl = '' if $do_left eq 'none';\n\n    # generate the top border\n    my $top = $style->[4] x (($self->{w}) / length($style->[4]) + 1);\n\n    my $len = length($style->[4]); \n\n    # for seamless rendering\n    if (defined $x)\n      {\n      my $ofs = $x % $len;\n      substr($top,0,$ofs) = '' if $ofs != 0;\n      }\n\n    # insert left upper corner (if it is there)\n    substr($top,0,1) = $tl if $tl ne '';\n\n    $top = substr($top,0,$w) if length($top) > $w;\n    \n    # top-right corner piece is only there if we have a right border\n    substr($top,-1,1) = $style->[1] if $do_right ne 'none';\n\n    # if the border must be collapsed, modify top-right edge piece:\n    if ($self->{border_collapse_right})\n      {\n      # place \"4\" (see drawing above)\n      substr($top,-1,1) = $style->[10];\n      }\n\n    # insert top row into FB\n    $self->_printfb( $fb, 0,0, $top);\n    }\n\n  if ($do_bottom ne 'none')\n    {\n    my $style = $self->_border_style($do_bottom, 'bottom');\n\n    # bottom-left corner piece is only there if we have a left border\n    my $bl = $style->[3]; $bl = '' if $do_left eq 'none';\n\n    # the bottom row '+--------+' etc\n    my $bottom = $style->[5] x (($self->{w}) / length($style->[5]) + 1);\n\n    my $len = length($style->[5]);\n \n    # for seamless rendering\n    if (defined $x)\n      {\n      my $ofs = $x % $len;\n      substr($bottom,0,$ofs) = '' if $ofs != 0;\n      }\n\n    # insert left bottom corner (if it is there)\n    substr($bottom,0,1) = $bl if $bl ne '';\n\n    $bottom = substr($bottom,0,$w) if length($bottom) > $w;\n\n    # bottom-right corner piece is only there if we have a right border\n    substr($bottom,-1,1) = $style->[2] if $do_right ne 'none';\n\n    # if the border must be collapsed, modify bottom-right edge piece:\n    if ($self->{border_collapse_right} || $self->{border_collapse_bottom})\n      {\n      if ($self->{rightbelow_count} > 0)\n        {\n        # place a cross or T piece (see drawing above)\n        my $piece = 8;\t# cross\n        # inverted T\n        $piece = 11 if $self->{rightbelow_count} < 2 && !$self->{have_below};\n        $piece = 10 if $self->{rightbelow_count} < 2 && !$self->{have_right};\n        substr($bottom,-1,1) = $style->[$piece];\n        }\n      }\n\n    # insert bottom row into FB\n    $self->_printfb( $fb, 0,$self->{h}-1, $bottom);\n    }\n\n  return if $do_right.$do_left eq 'nonenone';\t# both none => done\n\n  my $style = $self->_border_style($do_left, 'left');\n  my $left = $style->[6];\n  my $lc = scalar @{ $style->[6] } - 1;\t\t# count of characters\n\n  $style = $self->_border_style($do_right, 'right');\n  my $right = $style->[7];\n  my $rc = scalar @{ $style->[7] } - 1;\t\t# count of characters\n\n  my (@left, @right);\n  my $l = 0; my $r = 0;\t\t\t\t# start with first character\n  my $s = 1; $s = 0 if $do_top eq 'none';\n\n  my $h = $self->{h} - 2;\n  $h ++ if defined $x && $do_bottom eq 'none';\t# for seamless rendering\n  for ($s..$h)\n    {\n    push @left, $left->[$l]; $l ++; $l = 0 if $l > $lc;\n    push @right, $right->[$r]; $r ++; $r = 0 if $r > $rc;\n    }\n  # insert left/right columns into FB\n  $self->_printfb( $fb, 0, $s, @left) unless $do_left eq 'none';\n  $self->_printfb( $fb, $w-1, $s, @right) unless $do_right eq 'none';\n\n  $self;\n  }\n \nsub _draw_label\n  {\n  # Draw the node label into the framebuffer\n  my ($self, $fb, $x, $y, $shape) = @_;\n\n  if ($shape eq 'point')\n    {\n    # point-shaped nodes do not show their label in ASCII\n    my $style = $self->attribute('pointstyle');\n    my $shape = $self->attribute('pointshape');\n    my $l = $self->_point_style($shape,$style);\n\n    $self->_printfb_line ($fb, 2, $self->{h} - 2, $l) if $l;\n    return;\n    }\n\n  #        +----\n  #        | Label  \n  # 2,1: ----^\n\n  my $w = $self->{w} - 4; my $xs = 2;\n  my $h = $self->{h} - 2; my $ys = 0.5;\n  my $border = $self->attribute('borderstyle');\n  if ($border eq 'none')\n    {\n    $w += 2; $h += 2;\n    $xs = 1; $ys = 0;\n    }\n\n  my $align = $self->attribute('align');\n  $self->_printfb_aligned ($fb, $xs, $ys, $w, $h, $self->_aligned_label($align));\n  }\n\nsub as_ascii\n  {\n  # renders a node or edge like:\n  # +--------+    ..........    \"\"\n  # | A node | or : A node : or \" --> \"\n  # +--------+    ..........    \"\" \n  my ($self, $x,$y) = @_;\n\n  my $shape = 'rect';\n  $shape = $self->attribute('shape') unless $self->isa_cell();\n\n  if ($shape eq 'edge')\n    {\n    my $edge = Graph::Easy::Edge->new();\n    my $cell = Graph::Easy::Edge::Cell->new( edge => $edge, x => $x, y => $y );\n    $cell->{w} = $self->{w};\n    $cell->{h} = $self->{h};\n    $cell->{att}->{label} = $self->label();\n    $cell->{type} = \n     Graph::Easy::Edge::Cell->EDGE_HOR +\n     Graph::Easy::Edge::Cell->EDGE_LABEL_CELL;\n    return $cell->as_ascii();\n    }\n\n  # invisible nodes, or very small ones\n  return '' if $shape eq 'invisible' || $self->{w} == 0 || $self->{h} == 0;\n\n  my $fb = $self->_framebuffer($self->{w}, $self->{h});\n\n  # point-shaped nodes do not have a border\n  if ($shape ne 'point')\n    {\n    #########################################################################\n    # draw our border into the framebuffer\n\n    my $cache = $self->{cache};\n    my $b_top = $cache->{top_border} || 'none';\n    my $b_left = $cache->{left_border} || 'none';\n    my $b_right = $cache->{right_border} || 'none';\n    my $b_bottom = $cache->{bottom_border} || 'none';\n\n    $self->_draw_border($fb, $b_right, $b_bottom, $b_left, $b_top);\n    }\n\n  ###########################################################################\n  # \"draw\" the label into the framebuffer (e.g. the node/edge and the text)\n\n  $self->_draw_label($fb, $x, $y, $shape);\n  \n  join (\"\\n\", @$fb);\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::As_ascii - Generate ASCII art\n\n=head1 SYNOPSIS\n\n        use Graph::Easy;\n\n\tmy $graph = Graph::Easy->new();\n\n\t$graph->add_edge('Bonn', 'Berlin');\n\n\tprint $graph->as_ascii();\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::As_ascii> contains the code to render Nodes/Edges as\nASCII art. It is used by Graph::Easy automatically, and there should\nbe no need to use it directly.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/As_graphml.pm": "#############################################################################\n# Output an Graph::Easy object as GraphML text\n#\n#############################################################################\n\npackage Graph::Easy::As_graphml;\n\n$VERSION = '0.03';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\n\nuse Graph::Easy::Attributes;\n\n# map the Graph::Easy attribute types to a GraphML name:\nmy $attr_type_to_name =\n  {\n  ATTR_STRING()\t=> 'string',\n  ATTR_COLOR()\t=> 'string',\n  ATTR_ANGLE()\t=> 'double',\n  ATTR_PORT()\t=> 'string',\n  ATTR_UINT()\t=> 'integer',\n  ATTR_URL()\t=> 'string',\n\n  ATTR_LIST()\t=> 'string',\n  ATTR_LCTEXT()\t=> 'string',\n  ATTR_TEXT()\t=> 'string',\n  };\n\nsub _graphml_attr_keys\n  {\n  my ($self, $tpl, $tpl_no_default, $class, $att, $ids, $id) = @_;\n\n  my $base_class = $class; $base_class =~ s/\\..*//;\n  $base_class = 'graph' if $base_class =~ /group/;\n  $ids->{$base_class} = {} unless ref $ids->{$base_class};\n\n  my $txt = '';\n  for my $name (sort keys %$att)\n    {\n    my $entry = $self->_attribute_entry($class,$name);\n    # get a fresh template\n    my $t = $tpl;\n    $t = $tpl_no_default unless defined $entry->[ ATTR_DEFAULT_SLOT ];\n\n    # only keep it once\n    next if exists $ids->{$base_class}->{$name};\n\n    $t =~ s/##id##/$$id/;\n\n    # node.foo => node, group.bar => graph\n    $t =~ s/##class##/$base_class/;\n    $t =~ s/##name##/$name/;\n    $t =~ s/##type##/$attr_type_to_name->{ $entry->[ ATTR_TYPE_SLOT ] || ATTR_COLOR }/eg;\n\n    # will only be there and thus replaced if we have a default\n    if ($t =~ /##default##/)\n      {\n      my $def = $entry->[ ATTR_DEFAULT_SLOT ];\n      # not a simple value?\n      $def = $self->default_attribute($name) if ref $def;\n      $t =~ s/##default##/$def/;\n      }\n\n    # remember name => ID\n    $ids->{$base_class}->{$name} = $$id; $$id++;\n    # append the definition\n    $txt .= $t;\n    }\n  $txt;\n  }\n\n# yED example:\n\n# <data key=\"d0\">\n#  <y:ShapeNode>\n#    <y:Geometry height=\"30.0\" width=\"30.0\" x=\"277.0\" y=\"96.0\"/>\n#    <y:Fill color=\"#FFCC00\" transparent=\"false\"/>\n#    <y:BorderStyle color=\"#000000\" type=\"line\" width=\"1.0\"/>\n#    <y:NodeLabel alignment=\"center\" autoSizePolicy=\"content\" fontFamily=\"Dialog\" fontSize=\"12\" fontStyle=\"plain\" hasBackgroundColor=\"false\" hasLineColor=\"false\" height=\"18.701171875\" modelName=\"internal\" modelPosition=\"c\" textColor=\"#000000\" visible=\"true\" width=\"11.0\" x=\"9.5\" y=\"5.6494140625\">1</y:NodeLabel>\n#    <y:Shape type=\"ellipse\"/>\n#   </y:ShapeNode>\n# </data>\n\nsub _as_graphml\n  {\n  my $self = shift;\n\n  my $args = $_[0];\n  $args = { name => $_[0] } if ref($args) ne 'HASH' && @_ == 1;\n  $args = { @_ } if ref($args) ne 'HASH' && @_ > 1;\n  \n  $args->{format} = 'graph-easy' unless defined $args->{format};\n\n  if ($args->{format} !~ /^(graph-easy|Graph::Easy|yED)\\z/i)\n    {\n    return $self->error(\"Format '$args->{format}' not understood by as_graphml.\");\n    }\n  my $format = $args->{format};\n\n  # Convert the graph to a textual representation - does not need layout().\n\n  my $schema = \"http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\";\n  $schema = \"http://www.yworks.com/xml/schema/graphml/1.0/ygraphml.xsd\" if $format eq 'yED';\n  my $y_schema = '';\n  $y_schema = \"\\n    xmlns:y=\\\"http://www.yworks.com/xml/graphml\\\"\" if $format eq 'yED';\n\n  my $txt = <<EOF\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"##Y##\n    xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns\n     ##SCHEMA##\">\n\n  <!-- Created by Graph::Easy v##VERSION## at ##DATE## -->\n\nEOF\n;\n\t  \n  $txt =~ s/##DATE##/scalar localtime()/e;\n  $txt =~ s/##VERSION##/$Graph::Easy::VERSION/;\n  $txt =~ s/##SCHEMA##/$schema/;\n  $txt =~ s/##Y##/$y_schema/;\n\n  # <key id=\"d0\" for=\"node\" attr.name=\"color\" attr.type=\"string\">\n  #   <default>yellow</default>\n  # </key>\n  # <key id=\"d1\" for=\"edge\" attr.name=\"weight\" attr.type=\"double\"/>\n\n  # First gather all possible attributes, then add defines for them. This\n  # avoids lengthy re-definitions of attributes that aren't used:\n\n  my %keys;\n\n  my $tpl = '  <key id=\"##id##\" for=\"##class##\" attr.name=\"##name##\" attr.type=\"##type##\">'\n      .\"\\n    <default>##default##</default>\\n\"\n      .\"  </key>\\n\";\n  my $tpl_no_default = '  <key id=\"##id##\" for=\"##class##\" attr.name=\"##name##\" attr.type=\"##type##\"/>'.\"\\n\";\n\n  # for yED:\n  # <key for=\"node\" id=\"d0\" yfiles.type=\"nodegraphics\"/>\n  # <key attr.name=\"description\" attr.type=\"string\" for=\"node\" id=\"d1\"/>\n  # <key for=\"edge\" id=\"d2\" yfiles.type=\"edgegraphics\"/>\n  # <key attr.name=\"description\" attr.type=\"string\" for=\"edge\" id=\"d3\"/>\n  # <key for=\"graphml\" id=\"d4\" yfiles.type=\"resources\"/>\n\n  # we need to remember the mapping between attribute name and ID:\n  my $ids = {};\n  my $id = 'd0';\n\n  ###########################################################################\n  # first the class attributes\n  for my $class (sort keys %{$self->{att}})\n    {\n    my $att =  $self->{att}->{$class};\n\n    $txt .=\n\t$self->_graphml_attr_keys( $tpl, $tpl_no_default, $class, $att, $ids, \\$id);\n\n    }\n\n  my @nodes = $self->sorted_nodes('name','id');\n\n  ###########################################################################\n  # now the attributes on the objects:\n  for my $o (@nodes, values %{$self->{edges}})\n    {\n    $txt .=\n\t$self->_graphml_attr_keys( $tpl, $tpl_no_default, $o->class(),\n\t\t\t\t   $o->raw_attributes(), $ids, \\$id);\n    }\n  $txt .= \"\\n\" unless $id eq 'd0';\n\n  my $indent = '  ';\n  $txt .= $indent . '<graph id=\"G\" edgedefault=\"' . $self->type() . \"\\\">\\n\";\n\n  # output graph attributes:\n  $txt .= $self->_attributes_as_graphml($self,'  ',$ids->{graph});\n\n  # output groups recursively\n  my @groups = $self->groups_within(0);\n  foreach my $g (@groups)\n    {\n    $txt .= $g->as_graphml($indent.'  ',$ids);\t\t\t# marks nodes as processed if nec.\n    }\n \n  $indent = '    ';\t\t\n  foreach my $n (@nodes)\n    {\n    next if $n->{group};\t\t\t\t# already done in a group\n    $txt .= $n->as_graphml($indent,$ids);\t\t# <node id=\"...\" ...>\n    }\n\n  $txt .= \"\\n\";\n\n  foreach my $n (@nodes)\n    {\n    next if $n->{group};\t\t\t\t# already done in a group\n\n    my @out = $n->sorted_successors();\n    # for all outgoing connections\n    foreach my $other (@out)\n      {\n      # in case there exists more than one edge from $n --> $other\n      my @edges = $n->edges_to($other);\n      for my $edge (sort { $a->{id} <=> $b->{id} } @edges)\n        {\n        $txt .= $edge->as_graphml($indent,$ids);\t# <edge id=\"...\" ...>\n        }\n      }\n    }\n\n  $txt .= \"  </graph>\\n</graphml>\\n\";\n  $txt;\n  }\n\nsub _safe_xml\n  {\n  # make a text XML safe\n  my ($self,$txt) = @_;\n\n  $txt =~ s/&/&amp;/g;\t\t\t# quote &\n  $txt =~ s/>/&gt;/g;\t\t\t# quote >\n  $txt =~ s/</&lt;/g;\t\t\t# quote <\n  $txt =~ s/\"/&quot;/g;\t\t\t# quote \"\n  $txt =~ s/'/&apos;/g;\t\t\t# quote '\n  $txt =~ s/\\\\\\\\/\\\\/g;\t\t\t# \"\\\\\" to \"\\\"\n\n  $txt;\n  }\n\nsub _attributes_as_graphml\n  {\n  # output the attributes of an object\n  my ($graph, $self, $indent, $ids) = @_;\n\n  my $tpl = \"$indent  <data key=\\\"##id##\\\">##value##</data>\\n\";\n  my $att = $self->get_attributes();\n  my $txt = '';\n  for my $n (sort keys %$att)\n    {\n    next unless exists $ids->{$n};\n    my $def = $self->default_attribute($n);\n    next if defined $def && $def eq $att->{$n};\n    my $t = $tpl;\n    $t =~ s/##id##/$ids->{$n}/;\n    $t =~ s/##value##/$graph->_safe_xml($att->{$n})/e;\n    $txt .= $t;\n    }\n  $txt;\n  }\n\n#############################################################################\n\npackage Graph::Easy::Group;\n\nuse strict;\n\nsub as_graphml\n  {\n  my ($self, $indent, $ids) = @_;\n\n  my $txt = $indent . '<graph id=\"' . $self->_safe_xml($self->{name}) . '\" edgedefault=\"' .\n\t$self->{graph}->type() . \"\\\">\\n\";\n  $txt .= $self->{graph}->_attributes_as_graphml($self, $indent, $ids->{graph});\n\n  foreach my $n (values %{$self->{nodes}})\n    {\n    my @out = $n->sorted_successors();\n\n    $txt .= $n->as_graphml($indent.'  ', $ids); \t\t# <node id=\"...\" ...>\n\n    # for all outgoing connections\n    foreach my $other (@out)\n      {\n      # in case there exists more than one edge from $n --> $other\n      my @edges = $n->edges_to($other);\n      for my $edge (sort { $a->{id} <=> $b->{id} } @edges)\n        {\n        $txt .= $edge->as_graphml($indent.'  ',$ids);\n        }\n      $txt .= \"\\n\" if @edges > 0;\n      }\n    }\n\n  # output groups recursively\n  my @groups = $self->groups_within(0);\n  foreach my $g (@groups)\n    {\n    $txt .= $g->_as_graphml($indent.'  ',$ids);\t\t# marks nodes as processed if nec.\n    }\n\n  # XXX TODO: edges from/to this group\n\n  # close this group\n  $txt .= $indent . \"</graph>\";\n\n  $txt;\n  }\n\n#############################################################################\n\npackage Graph::Easy::Node;\n\nuse strict;\n\nsub as_graphml\n  {\n  my ($self, $indent, $ids) = @_;\n\n  my $g = $self->{graph};\n  my $txt = $indent . '<node id=\"' . $g->_safe_xml($self->{name}) . \"\\\">\\n\";\n\n  $txt .= $g->_attributes_as_graphml($self, $indent, $ids->{node});\n\n  $txt .= \"$indent</node>\\n\";\n\n  return $txt;\n  }\n\n#############################################################################\n\npackage Graph::Easy::Edge;\n\nuse strict;\n\nsub as_graphml\n  {\n  my ($self, $indent, $ids) = @_;\n\n  my $g = $self->{graph};\n  my $txt = $indent . '<edge source=\"' . $g->_safe_xml($self->{from}->{name}) . \n\t\t     '\" target=\"' . $g->_safe_xml($self->{to}->{name}) . \"\\\">\\n\";\n\n  $txt .= $g->_attributes_as_graphml($self, $indent, $ids->{edge});\n\n  $txt .= \"$indent</edge>\\n\";\n\n  $txt;\n  }\n \n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::As_graphml - Generate a GraphML text from a Graph::Easy object\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\t$graph->add_edge ('Bonn', 'Berlin');\n\n\tprint $graph->as_graphml();\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::As_graphml> contains just the code for converting a\nL<Graph::Easy|Graph::Easy> object to a GraphML text.\n\n=head2 Attributes\n\nAttributes are output in the format that C<Graph::Easy> specifies. More\ndetails about the valid attributes and their default values can be found\nin the Graph::Easy online manual:\n\nL<http://bloodgate.com/perl/graph/manual/>.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<http://graphml.graphdrawing.org/>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n\n",
  "Graph/Easy/As_graphviz.pm": "#############################################################################\n# output the graph in dot-format text\n#\n#############################################################################\n\npackage Graph::Easy::As_graphviz;\n\n$VERSION = '0.31';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\n\nmy $remap = {\n  node => {\n    'align' => undef,\n    'background' => undef,   # need a way to simulate that on non-rect nodes\n    'basename' => undef,\n    'bordercolor' => \\&_remap_color,\n    'borderstyle' => \\&_graphviz_remap_border_style,\n    'borderwidth' => undef,\n    'border' => undef,\n    'color' => \\&_remap_color,\n    'fill' => \\&_remap_color,\n    'label' => \\&_graphviz_remap_label,\n    'pointstyle' => undef,\n    'pointshape' => undef,\n    'rotate' => \\&_graphviz_remap_node_rotate,\n    'shape' => \\&_graphviz_remap_node_shape,\n    'title' => 'tooltip',\n    'rows' => undef,\n    'columns' => undef,\n    },\n  edge => {\n    'align' => undef,\n    'arrowstyle' => \\&_graphviz_remap_arrow_style,\n    'background' => undef,\n    'color' => \\&_graphviz_remap_edge_color,\n    'end' => \\&_graphviz_remap_port,\n    'headtitle' => 'headtooltip',\n    'headlink' => 'headURL',\n    'labelcolor' => \\&_graphviz_remap_label_color,\n    'start' => \\&_graphviz_remap_port,\n    'style' => \\&_graphviz_remap_edge_style,\n    'tailtitle' => 'tailtooltip',\n    'taillink' => 'tailURL',\n    'title' => 'tooltip',\n    'minlen' => \\&_graphviz_remap_edge_minlen,\n    },\n  graph => {\n    align => \\&_graphviz_remap_align,\n    background => undef,\n    bordercolor => \\&_remap_color,\n    borderstyle => \\&_graphviz_remap_border_style,\n    borderwidth => undef,\n    color => \\&_remap_color,\n    fill => \\&_remap_color,\n    gid => undef,\n    label => \\&_graphviz_remap_label,\n    labelpos => 'labelloc',\n    output => undef,\n    type => undef,\n    },\n  group => {\n    align => \\&_graphviz_remap_align,\n    background => undef,\n    bordercolor => \\&_remap_color,\n    borderstyle => \\&_graphviz_remap_border_style,\n    borderwidth => undef,\n    color => \\&_remap_color,\n    fill => \\&_remap_color,\n    labelpos => 'labelloc',\n    rank => undef,\n    title => 'tooltip',\n    },\n  all => {\n    arrowshape => undef,\n    autolink => undef,\n    autotitle => undef,\n    autolabel => undef,\n    class => undef,\n    colorscheme => undef,\n    flow => undef,\n    fontsize => \\&_graphviz_remap_fontsize,\n    font => \\&_graphviz_remap_font,\n    format => undef,\n    group => undef,\n    link => \\&_graphviz_remap_link,\n    linkbase => undef,\n    textstyle => undef,\n    textwrap => undef,\n    },\n  always => {\n    node\t=> [ qw/borderstyle label link rotate color fill/ ],\n    'node.anon' => [ qw/bordercolor borderstyle label link rotate color/ ],\n    edge\t=> [ qw/labelcolor label link color/ ],\n    graph\t=> [ qw/labelpos borderstyle label link color/ ],\n    },\n  # this routine will handle all custom \"x-dot-...\" attributes\n  x => \\&_remap_custom_dot_attributes,\n  };\n\nsub _remap_custom_dot_attributes\n  {\n  my ($self, $name, $value) = @_;\n\n  # drop anything that is not starting with \"x-dot-...\"\n  return (undef,undef) unless $name =~ /^x-dot-/;\n\n  $name =~ s/^x-dot-//;\t\t\t# \"x-dot-foo\" => \"foo\"\n  ($name,$value);\n  }\n\nmy $color_remap = {\n  bordercolor => 'color',\n  color => 'fontcolor',\n  fill => 'fillcolor',\n  };\n\nsub _remap_color\n  {\n  # remap one color value\n  my ($self, $name, $color, $object) = @_;\n\n  # guard against always doing the remap even when the attribute is not set\n  return (undef,undef) unless defined $color;\n\n  if (!ref($object) && $object eq 'graph')\n    {\n    # 'fill' => 'bgcolor';\n    $name = 'bgcolor' if $name eq 'fill';\n    }\n\n  $name = $color_remap->{$name} || $name;\n\n  $color = $self->_color_as_hex_or_hsv($object,$color);\n\n  ($name, $color);\n  }\n\nsub _color_as_hex_or_hsv\n  {\n  # Given a color in hex, hsv, hsl or rgb, will return either a hex or hsv\n  # color to preserve as much precision as possible:\n  my ($graph, $self, $color) = @_;\n\n  if ($color !~ /^#/)\n    {\n    # HSV colors with an alpha channel are not supported by graphviz, and\n    # hence converted to RGB here:\n    if ($color =~ /^hsv\\(([0-9\\.]+),([0-9\\.]+),([0-9\\.]+)\\)/)\n      {\n      # hsv(1.0,1.0,1.0) => 1.0 1.0 1.0\n      $color = \"$1 $2 $3\";\n      }\n    else\n      {\n      my $cs = ref($self) ? $self->attribute('colorscheme') :\n\t\t\t$graph->attribute($self,'colorscheme');\n      # red => hex\n      $color = $graph->color_as_hex($color, $cs);\n      }\n    }\n\n  $color;\n  }\n\nsub _graphviz_remap_align\n  {\n  my ($self, $name, $style) = @_;\n\n  my $s = lc(substr($style,0,1));\t\t# 'l', 'r', or 'c'\n\n  ('labeljust', $s);\n  }\n\nsub _graphviz_remap_edge_minlen\n  {\n  my ($self, $name, $len) = @_;\n\n  $len = int(($len + 1) / 2);\n  ($name, $len);\n  }\n\nsub _graphviz_remap_edge_color\n  {\n  my ($self, $name, $color, $object) = @_;\n\n  my $style = ref($object) ? \n    $object->attribute('style') : \n    $self->attribute('edge','style');\n\n  if (!defined $color)\n    {\n    $color = ref($object) ? \n      $object->attribute('color') : \n      $self->attribute('edge','color');\n    }\n\n  $color = '#000000' unless defined $color;\n  $color = $self->_color_as_hex_or_hsv($object, $color);\n\n  $color = $color . ':' . $color\t# 'red:red'\n    if $style =~ /^double/;\n\n  ($name, $color);\n  }\n\nsub _graphviz_remap_edge_style\n  {\n  my ($self, $name, $style) = @_;\n\n  # valid output styles are: solid dashed dotted bold invis\n\n  $style = 'solid' unless defined $style;\n\n  $style = 'dotted' if $style =~ /^dot-/;\t# dot-dash, dot-dot-dash\n  $style = 'dotted' if $style =~ /^wave/;\t# wave\n\n  # double lines will be handled in the color attribute as \"color:color\"\n  $style = 'solid' if $style eq 'double';\t# double\n  $style = 'dashed' if $style =~ /^double-dash/;\n\n  $style = 'invis' if $style eq 'invisible';\t# invisible\n\n  # XXX TODO: These should be (2, 0.5em, 1em) instead of 2,5,11\n  $style = 'setlinewidth(2), dashed' if $style =~ /^bold-dash/;\n  $style = 'setlinewidth(5)' if $style =~ /^broad/;\n  $style = 'setlinewidth(11)' if $style =~ /^wide/;\n  \n  return (undef, undef) if $style eq 'solid';\t# default style can be suppressed\n\n  ($name, $style);\n  }\n\nsub _graphviz_remap_node_rotate\n  {\n  my ($graph, $name, $angle, $self) = @_;\n\n  # do this only for objects, not classes \n  return (undef,undef) unless ref($self) && defined $angle;\n\n  return (undef,undef) if $angle == 0;\n\n  # despite what the manual says, dot rotates counter-clockwise, so fix that\n  $angle = 360 - $angle;\n\n  ('orientation', $angle);\n  }\n\nsub _graphviz_remap_port\n  {\n  my ($graph, $name, $side, $self) = @_;\n\n  # do this only for objects, not classes \n  return (undef,undef) unless ref($self) && defined $side;\n\n  # XXX TODO\n  # remap relative ports (front etc) to \"south\" etc\n\n  # has a specific port, aka shared a port with another edge\n  return (undef, undef) if $side =~ /,/;\n\n  $side = $graph->_flow_as_side($self->flow(),$side);\n\n  $side = substr($side,0,1);\t# \"south\" => \"s\"\n\n  my $n = 'tailport'; $n = 'headport' if $name eq 'end';\n\n  ($n, $side);\n  }\n\nsub _graphviz_remap_font\n  {\n  # Remap the font names\n  my ($self, $name, $style) = @_;\n\n  # XXX TODO: \"times\" => \"Times.ttf\" ?\n  ('fontname', $style);\n  }\n\nsub _graphviz_remap_fontsize\n  {\n  # make sure the fontsize is in pixel or percent\n  my ($self, $name, $style) = @_;\n\n  # XXX TODO: This should be actually 1 em\n  my $fs = '11';\n\n  if ($style =~ /^([\\d\\.]+)em\\z/)\n    {\n    $fs = $1 * 11;\n    }\n  elsif ($style =~ /^([\\d\\.]+)%\\z/)\n    {\n    $fs = ($1 / 100) * 11;\n    }\n  # this is discouraged:\n  elsif ($style =~ /^([\\d\\.]+)px\\z/)\n    {\n    $fs = $1;\n    }\n  else\n    {\n    $self->_croak(\"Illegal font-size '$style'\");\n    }\n\n  # font-size => fontsize\n  ('fontsize', $fs);\n  }\n\nsub _graphviz_remap_border_style\n  {\n  my ($self, $name, $style, $node) = @_;\n\n  my $shape = '';\n  $shape = ($node->attribute('shape') || '') if ref($node);\n\n  # some shapes don't need a border:\n  return (undef,undef) if $shape =~ /^(none|invisible|img|point)\\z/;\n\n  $style = $node->attribute('borderstyle') unless defined $style;\n \n  # valid styles are: solid dashed dotted bold invis\n\n  $style = '' unless defined $style;\n\n  $style = 'dotted' if $style =~ /^dot-/;\t# dot-dash, dot-dot-dash\n  $style = 'dashed' if $style =~ /^double-/;\t# double-dash\n  $style = 'dotted' if $style =~ /^wave/;\t# wave\n\n  # borderstyle double will be handled extra with peripheries=2 later\n  $style = 'solid' if $style eq 'double';\n\n  # XXX TODO: These should be (2, 0.5em, 1em) instead of 2,5,11\n  $style = 'setlinewidth(2)' if $style =~ /^bold/;\n  $style = 'setlinewidth(5)' if $style =~ /^broad/;\n  $style = 'setlinewidth(11)' if $style =~ /^wide/;\n\n  # \"solid 0px\" => \"none\"\n  my $w = 0; $w = $node->attribute('borderwidth') if (ref($node) && $style ne 'none');\n  $style = 'none' if $w == 0;\n\n  my @rc;\n  if ($style eq 'none')\n    {\n    my $fill = 'white'; $fill = $node->color_attribute('fill') if ref($node);\n    $style = 'filled'; @rc = ('color', $fill);\n    }\n  \n  # default style can be suppressed\n  return (undef, undef) if $style =~ /^(|solid)\\z/ && $shape ne 'rounded';\n\n  # for graphviz v2.4 and up\n  $style = 'filled' if $style eq 'solid';\n  $style = 'filled,'.$style unless $style eq 'filled';\n  $style = 'rounded,'.$style if $shape eq 'rounded' && $style ne 'none';\n\n  $style =~ s/,\\z//;\t\t# \"rounded,\" => \"rounded\"\n\n  push @rc, 'style', $style;\n  @rc;\n  }\n\nsub _graphviz_remap_link\n  {\n  my ($self, $name, $l, $object) = @_;\n\n  # do this only for objects, not classes \n  return (undef,undef) unless ref($object);\n  \n  $l = $object->link() unless defined $l;\n\n  ('URL', $l);\n  }\n\nsub _graphviz_remap_label_color\n  {\n  my ($graph, $name, $color, $self) = @_;\n\n  # do this only for objects, not classes \n  return (undef,undef) unless ref($self);\n  \n  # no label => no color nec.\n  return (undef, $color) if ($self->label()||'') eq '';\n\n  $color = $self->raw_attribute('labelcolor') unless defined $color;\n\n  # the label color falls back to the edge color\n  $color = $self->attribute('color') unless defined $color;\n\n  $color = $graph->_color_as_hex_or_hsv($self,$color);\n\n  ('fontcolor', $color);\n  }\n\nsub _graphviz_remap_node_shape\n  {\n  my ($self, $name, $style, $object) = @_;\n\n  # img needs no shape, and rounded is handled as style\n  return (undef,undef) if $style =~ /^(img|rounded)\\z/;\n\n  # valid styles are: solid dashed dotted bold invis\n\n  my $s = $style;\n  $s = 'plaintext' if $style =~ /^(invisible|none|point)\\z/;\n\n  if (ref($object))\n    {\n    my $border = $object->attribute('borderstyle');\n    $s = 'plaintext' if $border eq 'none';\n    }\n\n  ($name, $s);\n  }\n\nsub _graphviz_remap_arrow_style\n  {\n  my ($self, $name, $style) = @_;\n\n  my $s = 'normal';\n \n  $s = $style if $style =~ /^(none|open)\\z/;\n  $s = 'empty' if $style eq 'closed';\n\n  my $n = 'arrowhead';\n  $n = 'arrowtail' if $self->{_flip_edges};\n\n  ($n, $s);\n  }\n\nsub _graphviz_remap_label\n  {\n  my ($self, $name, $label, $node) = @_;\n\n  my $s = $label;\n\n  # call label() to handle thinks like \"autolabel: 15\" properly\n  $s = $node->label() if ref($node);\n\n  if (ref($node))\n    {\n    # remap all \"\\n\" and \"\\c\" to either \"\\l\" or \"\\r\", depending on align\n    my $align = $node->attribute('align');\n    my $next_line = '\\n';\n    # the align of the line-ends counts for the line _before_ them, so\n    # add one more to fix the last line\n    $next_line = '\\l', $s .= '\\l' if $align eq 'left';\n    $next_line = '\\r', $s .= '\\r' if $align eq 'right';\n\n    $s =~ s/(^|[^\\\\])\\\\n/$1$next_line/g;\t# \\n => align\n    }\n\n  $s =~ s/(^|[^\\\\])\\\\c/$1\\\\n/g;\t\t\t# \\c => \\n (for center)\n\n  my $shape = 'rect';\n  $shape = ($node->attribute('shape') || '') if ref($node);\n\n  # only for nodes and when they have a \"shape: img\"\n  if ($shape eq 'img')\n    {\n    my $s = '<<TABLE BORDER=\"0\"><TR><TD><IMG SRC=\"##url##\" /></TD></TR></TABLE>>';\n\n    my $url = $node->label();\n    $url =~ s/\\s/\\+/g;\t\t\t\t# space\n    $url =~ s/'/%27/g;\t\t\t\t# replace quotation marks\n    $s =~ s/##url##/$url/g;\n    }\n\n  ($name, $s);\n  }\n\n#############################################################################\n\nsub _att_as_graphviz\n  {\n  # convert a hash with attribute => value mappings to a string\n  my ($self, $out) = @_;\n\n  my $att = '';\n  for my $atr (keys %$out)\n    {\n    my $v = $out->{$atr};\n    $v =~ s/\\n/\\\\n/g;\n\n    $v = '\"' . $v . '\"' if $v !~ /^[a-z0-9A-Z]+\\z/;\t# quote if nec.\n\n    # convert \"x-dot-foo\" to \"foo\". Special case \"K\":\n    my $name = $atr; $name =~ s/^x-dot-//; $name = 'K' if $name eq 'k';\n\n    $att .= \"  $name=$v,\\n\";\n    }\n\n  $att =~ s/,\\n\\z/ /;\t\t\t# remove last \",\"\n  if ($att ne '')\n    {\n    # the following makes short, single definitions to fit on one line\n    if ($att !~ /\\n.*\\n/ && length($att) < 40)\n      {\n      $att =~ s/\\n/ /; $att =~ s/( )+/ /g;\n      }\n    else\n      {\n      $att =~ s/\\n/\\n  /g;\n      $att = \"\\n  $att\";\n      }\n    }\n  $att;\n  }\n\nsub _generate_group_edge\n  {\n  # Given an edge (from/to at least one group), generate the graphviz code\n  my ($self, $e, $indent) = @_;\n\n  my $edge_att = $e->attributes_as_graphviz();\n\n  my $a = ''; my $b = '';\n  my $from = $e->{from};\n  my $to = $e->{to};\n\n  ($from,$to) = ($to,$from) if $self->{_flip_edges};\n  if ($from->isa('Graph::Easy::Group'))\n    {\n    # find an arbitray node inside the group\n    my ($n, $v) = each %{$from->{nodes}};\n    \n    $a = 'ltail=\"cluster' . $from->{id}.'\"';\t# ltail=cluster0\n    $from = $v;\n    }\n\n  # XXX TODO:\n  # this fails for empty groups\n  if ($to->isa('Graph::Easy::Group'))\n    {\n    # find an arbitray node inside the group\n    my ($n, $v) = each %{$to->{nodes}};\n    \n    $b = 'lhead=\"cluster' . $to->{id}.'\"';\t# lhead=cluster0\n    $to = $v;\n    }\n\n  my $other = $to->_graphviz_point();\n  my $first = $from->_graphviz_point();\n\n  $e->{_p} = undef;\t\t\t\t# mark as processed\n\n  my $att = $a; \n  $att .= ', ' . $b if $b ne ''; $att =~ s/^,//;\n  if ($att ne '')\n    {\n    if ($edge_att eq '')\n      {\n      $edge_att = \" [ $att ]\";\n      }\n    else\n      {\n      $edge_att =~ s/ \\]/, $att \\]/;\n      }\n    }\n\n  \"$indent$first $self->{edge_type} $other$edge_att\\n\";\t\t# return edge text\n  }\n\nsub _insert_edge_attribute\n  {\n  # insert an additional attribute into an edge attribute string\n  my ($self, $att, $new_att) = @_;\n\n  return '[ $new_att ]' if $att eq '';\t\t# '' => '[ ]'\n\n  # remove any potential old attribute with the same name\n  my $att_name = $new_att; $att_name =~ s/=.*//;\n  $att =~ s/$att_name=(\"[^\"]+\"|[^\\s]+)//;\n  \n  # insert the new attribute at the end\n  $att =~ s/\\s?\\]/,$new_att ]/;\n\n  $att;\n  }\n\nsub _suppress_edge_attribute\n  {\n  # remove the named attribute from the edge attribute string\n  my ($self, $att, $sup_att) = @_;\n\n  $att =~ s/$sup_att=(\"(\\\\\"|[^\"])*\"|[^\\s\\n,;]+)[,;]?//;\n  $att;\n  }\n\nsub _generate_edge\n  {\n  # Given an edge, generate the graphviz code for it\n  my ($self, $e, $indent) = @_;\n\n  # skip links from/to groups, these will be done later\n  return '' if \n    $e->{from}->isa('Graph::Easy::Group') ||\n    $e->{to}->isa('Graph::Easy::Group');\n\n  my $invis = $self->{_graphviz_invis};\n\n  # attributes for invisible helper nodes (the color will be filled in from the edge color)\n  my $inv       = ' [ label=\"\",shape=none,style=filled,height=0,width=0,fillcolor=\"';\n\n  my $other = $e->{to}->_graphviz_point();\n  my $first = $e->{from}->_graphviz_point();\n\n  my $edge_att = $e->attributes_as_graphviz();\n  my $txt = '';\n\n  my $modify_edge = 0;\n  my $suppress_start = (!$self->{_flip_edges} ? 'arrowtail=none' : 'arrowhead=none');\n  my $suppress_end   = ( $self->{_flip_edges} ? 'arrowtail=none' : 'arrowhead=none');\n  my $suppress;\n\n  # if the edge has a shared start/end port\n  if ($e->has_ports())\n    {\n    my @edges = ();\n\n    my ($side,@port) = $e->port('start');\n    @edges = $e->{from}->edges_at_port('start',$side,@port) if defined $side && @port > 0;\n\n    if (@edges > 1)\t\t\t\t\t# has strict port\n      {\n      # access the invisible node\n      my $sp = $e->port('start');\n      my $key = \"$e->{from}->{name},start,$sp\";\n      my $invis_id = $invis->{$key};\n      $suppress = $suppress_start;\n      if (!defined $invis_id)\n\t{\n\t# create the invisible helper node\n\t# find a name for it, carefully avoiding names of other nodes: \n\t$self->{_graphviz_invis_id}++ while (defined $self->node($self->{_graphviz_invis_id}));\n\t$invis_id = $self->{_graphviz_invis_id}++;\n\n\t# output the helper node\n\tmy $e_color = $e->color_attribute('color');\n\t$txt .= $indent . \"$invis_id$inv$e_color\\\" ]\\n\";\n\tmy $e_att = $self->_insert_edge_attribute($edge_att,$suppress_end);\n\t$e_att = $self->_suppress_edge_attribute($e_att,'label');\n\tmy $before = ''; my $after = ''; my $i = $indent;\n\tif ($e->{group})\n\t  {\n\t  $before = $indent . 'subgraph \"cluster' . $e->{group}->{id} . \"\\\" {\\n\";\n\t  $after = $indent . \"}\\n\";\n\t  $i = $indent . $indent;\n\t  }\n\tif ($self->{_flip_edges})\n\t  {\n\t  $txt .= $before . $i . \"$invis_id $self->{_edge_type} $first$e_att\\n\" . $after;\n\t  }\n\telse\n\t  {\n\t  $txt .= $before . $i . \"$first $self->{_edge_type} $invis_id$e_att\\n\" . $after;\n\t  }\n\t$invis->{$key} = $invis_id;\t\t# mark as created\n\t}\n      # \"joint0\" etc\n      $first = $invis_id;\n      $modify_edge++;\n      }\n\n    ($side,@port) = $e->port('end');\n    @edges = ();\n    @edges = $e->{to}->edges_at_port('end',$side,@port) if defined $side && @port > 0;\n    if (@edges > 1)\n      {\n      my $ep = $e->port('end');\n      my $key = \"$e->{to}->{name},end,$ep\";\n      my $invis_id = $invis->{$key};\n      $suppress = $suppress_end;\n\n      if (!defined $invis_id)\n\t{\n\t# create the invisible helper node\n\t# find a name for it, carefully avoiding names of other nodes:\n\t$self->{_graphviz_invis_id}++ while (defined $self->node($self->{_graphviz_invis_id}));\n\t$invis_id = $self->{_graphviz_invis_id}++;\n\n        my $e_att = $self->_insert_edge_attribute($edge_att,$suppress_start);\n\t# output the helper node\n\tmy $e_color = $e->color_attribute('color');\n\t$txt .= $indent . \"$invis_id$inv$e_color\\\" ]\\n\";\n\tmy $before = ''; my $after = ''; my $i = $indent;\n\tif ($e->{group})\n\t  {\n\t  $before = $indent . 'subgraph \"cluster' . $e->{group}->{id} . \"\\\" {\\n\";\n\t  $after = $indent . \"}\\n\";\n\t  $i = $indent . $indent;\n\t  }\n\tif ($self->{_flip_edges})\n\t  {\n\t  $txt .= $before . $i . \"$other $self->{_edge_type} $invis_id$e_att\\n\" . $after;\n\t  }\n\telse\n\t  {\n\t  $txt .= $before . $i . \"$invis_id $self->{_edge_type} $other$e_att\\n\" . $after;\n\t  }\n\t$invis->{$key} = $invis_id;\t\t\t# mark as output\n\t}\n      # \"joint1\" etc\n      $other = $invis_id;\n      $modify_edge++;\n      }\n    }\n\n  ($other,$first) = ($first,$other) if $self->{_flip_edges};\n\n  $e->{_p} = undef;\t\t\t\t# mark as processed\n\n  $edge_att = $self->_insert_edge_attribute($edge_att,$suppress)\n    if $modify_edge;\n\n  $txt . \"$indent$first $self->{_edge_type} $other$edge_att\\n\";\t\t# return edge text\n  }\n\nsub _order_group \n  {\n  my ($self,$group) = @_;\n  $group->{_order}++;\n  for my $sg (values %{$group->{groups}})\n\t{\n\t\t$self->_order_group($sg);\n\t}\n  }\n\n\nsub _as_graphviz_group \n  {\n  my ($self,$group) = @_;\n\n  my $txt = '';\n    # quote special chars in group name\n    my $name = $group->{name}; $name =~ s/([\\[\\]\\(\\)\\{\\}\\#\"])/\\\\$1/g;\n\n   return if $group->{_p};\n    # output group attributes first\n    my $indent = '  ' x ($group->{_order});\n    $txt .= $indent.\"subgraph \\\"cluster$group->{id}\\\" {\\n${indent}label=\\\"$name\\\";\\n\";\n\n\tfor my $sg (values %{$group->{groups}})\n\t{\n\t\t#print '--'.$sg->{name}.\"\\n\";\n\t\t$txt .= $self->_as_graphviz_group($sg,$indent);\n\t\t$sg->{_p} = 1;\n\t}\n    # Make a copy of the attributes, including our class attributes:\n    my $copy = {};\n    my $attribs = $group->get_attributes();\n\n    for my $a (keys %$attribs)\n      {\n      $copy->{$a} = $attribs->{$a};\n      }\n    # set some defaults\n    $copy->{'borderstyle'} = 'solid' unless defined $copy->{'borderstyle'};\n\n    my $out = $self->_remap_attributes( $group->class(), $copy, $remap, 'noquote');\n\n    # Set some defaults:\n    $out->{fillcolor} = '#a0d0ff' unless defined $out->{fillcolor};\n    $out->{labeljust} = 'l' unless defined $out->{labeljust};\n\n    my $att = '';\n    # we need to output style first (\"filled\" and \"color\" need come later)\n    for my $atr (reverse sort keys %$out)\n      {\n      my $v = $out->{$atr};\n      $v = '\"' . $v . '\"' if $v !~ /^[a-z0-9A-Z]+\\z/;\t# quote if nec.\n\n      # convert \"x-dot-foo\" to \"foo\". Special case \"K\":\n      my $name = $atr; $name =~ s/^x-dot-//; $name = 'K' if $name eq 'k';\n\n      $att .= $indent.\"$name=$v;\\n\";\n      }\n    $txt .= $att . \"\\n\" if $att ne '';\n \n    # output nodes (w/ or w/o attributes) in that group\n    for my $n ($group->sorted_nodes())\n      {\n      # skip nodes that are relativ to others (these are done as part\n      # of the HTML-like label of their parent)\n      next if $n->{origin};\n\n      my $att = $n->attributes_as_graphviz();\n      $n->{_p} = undef;\t\t\t# mark as processed\n      $txt .= $indent . $n->as_graphviz_txt() . $att . \"\\n\";\n      }\n\n    # output node connections in this group\n    for my $e (values %{$group->{edges}})\n      {\n      next if exists $e->{_p};\n      $txt .= $self->_generate_edge($e, $indent);\n      }\n\n    $txt .= $indent.\"}\\n\";\n   \n   return $txt;\n  }\n\nsub _as_graphviz\n  {\n  my ($self) = @_;\n\n  # convert the graph to a textual representation\n  # does not need a layout() beforehand!\n\n  my $name = \"GRAPH_\" . ($self->{gid} || '0');\n\n  my $type = $self->attribute('type');\n  $type = $type eq 'directed' ? 'digraph' : 'graph';\t# directed or undirected?\n\n  $self->{_edge_type} = $type eq 'digraph' ? '->' : '--';\t# \"a -- b\" vs \"a -> b\"\n\n  my $txt = \"$type $name {\\n\\n\" .\n            \"  // Generated by Graph::Easy $Graph::Easy::VERSION\" .\n\t    \" at \" . scalar localtime() . \"\\n\\n\";\n\n\n  my $flow = $self->attribute('graph','flow');\n  $flow = 'east' unless defined $flow;\n\n  $flow = Graph::Easy->_direction_as_number($flow);\n\n  # for LR, BT layouts\n  $self->{_flip_edges} = 0;\n  $self->{_flip_edges} = 1 if $flow == 270 || $flow == 0;\n  \n  my $groups = $self->groups();\n\n  # to keep track of invisible helper nodes\n  $self->{_graphviz_invis} = {};\n  # name for invisible helper nodes\n  $self->{_graphviz_invis_id} = 'joint0';\n\n  # generate the class attributes first\n  my $atts =  $self->{att};\n  # It is not possible to set attributes for groups in the DOT language that way\n  for my $class (qw/edge graph node/)\n    {\n    next if $class =~ /\\./;\t\t# skip subclasses\n\n    my $out = $self->_remap_attributes( $class, $atts->{$class}, $remap, 'noquote');\n\n    # per default, our nodes are rectangular, white, filled boxes\n    if ($class eq 'node')\n      {\n      $out->{shape} = 'box' unless $out->{shape}; \n      $out->{style} = 'filled' unless $out->{style};\n      $out->{fontsize} = '11' unless $out->{fontsize};\n      $out->{fillcolor} = 'white' unless $out->{fillcolor};\n      }\n    elsif ($class eq 'graph')\n      {\n      $out->{rankdir} = 'LR' if $flow == 90 || $flow == 270;\n      $out->{labelloc} = 'top' if defined $out->{label} && !defined $out->{labelloc};\n      $out->{style} = 'filled' if $groups > 0;\n      }\n    elsif ($class eq 'edge')\n      {\n      $out->{dir} = 'back' if $flow == 270 || $flow == 0;\n      my ($name,$style) = $self->_graphviz_remap_arrow_style('',\n        $self->attribute('edge','arrowstyle') );\n      $out->{$name} = $style;\n      }\n\n    my $att = $self->_att_as_graphviz($out);\n\n    $txt .= \"  $class [$att];\\n\" if $att ne '';\n    }\n\n  $txt .= \"\\n\" if $txt ne '';\t\t# insert newline\n\n  ###########################################################################\n  # output groups as subgraphs\n\n  # insert the edges into the proper group\n  $self->_edges_into_groups() if $groups > 0;\n\n  # output the groups (aka subclusters)\n  for my $group (values %{$self->{groups}})\n  {\n   $self->_order_group($group);\n  }\n  for my $group (sort { $a->{_order} cmp $b->{_order} } values %{$self->{groups}})\n  {\n    $txt .= $self->_as_graphviz_group($group) || '';\n  }\n\n  my $root = $self->attribute('root');\n  $root = '' unless defined $root;\n\n  my $count = 0;\n  # output nodes with attributes first, sorted by their name\n  for my $n (sort { $a->{name} cmp $b->{name} } values %{$self->{nodes}})\n    {\n    next if exists $n->{_p};\n    # skip nodes that are relativ to others (these are done as part\n    # of the HTML-like label of their parent)\n    next if $n->{origin};\n    my $att = $n->attributes_as_graphviz($root);\n    if ($att ne '')\n      {\n      $n->{_p} = undef;\t\t\t# mark as processed\n      $count++;\n      $txt .= \"  \" . $n->as_graphviz_txt() . $att . \"\\n\"; \n      }\n    }\n \n  $txt .= \"\\n\" if $count > 0;\t\t# insert a newline\n\n  my @nodes = $self->sorted_nodes();\n\n  # output the edges\n  foreach my $n (@nodes)\n    {\n    my @out = $n->successors();\n    my $first = $n->as_graphviz_txt();\n    if ((@out == 0) && ( (scalar $n->predecessors() || 0) == 0))\n      {\n      # single node without any connections (unless already output)\n      $txt .= \"  \" . $first . \"\\n\" unless exists $n->{_p} || $n->{origin};\n      }\n    # for all outgoing connections\n    foreach my $other (reverse @out)\n      {\n      # in case there is more than one edge going from N to O\n      my @edges = $n->edges_to($other);\n      foreach my $e (@edges)\n        {\n        next if exists $e->{_p};\n        $txt .= $self->_generate_edge($e, '  ');\n        }\n      }\n    }\n\n  # insert now edges between groups (clusters/subgraphs)\n\n  foreach my $e (values %{$self->{edges}})\n    {\n    $txt .= $self->_generate_group_edge($e, '  ') \n     if $e->{from}->isa('Graph::Easy::Group') ||\n        $e->{to}->isa('Graph::Easy::Group');\n    }\n\n  # clean up\n  for my $n ( values %{$self->{nodes}}, values %{$self->{edges}})\n    {\n    delete $n->{_p};\n    }\n  delete $self->{_graphviz_invis};\t\t# invisible helper nodes for joints\n  delete $self->{_flip_edges};\n  delete $self->{_edge_type};\n\n  $txt .  \"\\n}\\n\";\t\t\t\t# close the graph\n  }\n\npackage Graph::Easy::Node;\n\nsub attributes_as_graphviz\n  {\n  # return the attributes of this node as text description\n  my ($self, $root) = @_;\n  $root = '' unless defined $root;\n\n  my $att = '';\n  my $class = $self->class();\n\n  return '' unless ref $self->{graph};\n\n  my $g = $self->{graph};\n\n  # get all attributes, excluding the class attributes\n  my $a = $self->raw_attributes();\n\n  # add the attributes that are listed under \"always\":\n  my $attr = $self->{att};\n  my $base_class = $class; $base_class =~ s/\\..*//;\n  my $list = $remap->{always}->{$class} || $remap->{always}->{$base_class};\n  for my $name (@$list)\n    {\n    # for speed, try to look it up directly\n\n    # look if we have a code ref:\n    if ( ref($remap->{$base_class}->{$name}) ||\n         ref($remap->{all}->{$name}) )\n      {\n      $a->{$name} = $self->raw_attribute($name);\n      if (!defined $a->{$name})\n        {\n        my $b_attr = $g->get_attribute($base_class,$name);\n        my $c_attr = $g->get_attribute($class,$name);\n        if (defined $b_attr && defined $c_attr && $b_attr ne $c_attr)\n          {\n          $a->{$name} = $c_attr;\n          $a->{$name} = $b_attr unless defined $a->{$name};\n          }\n        }\n      }\n    else\n      {\n      $a->{$name} = $attr->{$name};\n      $a->{$name} = $self->attribute($name) unless defined $a->{$name} && $a->{$name} ne 'inherit';\n      }\n    }\n\n  $a = $g->_remap_attributes( $self, $a, $remap, 'noquote');\n\n  # do not needlessly output labels:\n  delete $a->{label} if !$self->isa('Graph::Easy::Edge') &&\t\t# not an edge\n\texists $a->{label} && $a->{label} eq $self->{name};\n\n  # generate HTML-like labels for nodes with children, but do so only\n  # for the node which is not itself a child\n  if (!$self->{origin} && $self->{children} && keys %{$self->{children}} > 0)\n    {\n    #print \"Generating HTML-like label for $self->{name}\\n\";\n    $a->{label} = $self->_html_like_label();\n    # make Graphviz avoid the outer border\n    $a->{shape} = 'none';\n    }\n\n  # bidirectional and undirected edges\n  if ($self->{bidirectional})\n    {\n    delete $a->{dir};\n    my ($n,$s) = Graph::Easy::_graphviz_remap_arrow_style(\n\t$self,'', $self->attribute('arrowstyle'));\n    $a->{arrowhead} = $s; \n    $a->{arrowtail} = $s; \n    }\n  if ($self->{undirected})\n    {\n    delete $a->{dir};\n    $a->{arrowhead} = 'none'; \n    $a->{arrowtail} = 'none'; \n    }\n\n  if (!$self->isa_cell())\n    {\n    # borderstyle: double:\n    my $style = $self->attribute('borderstyle');\n    my $w = $self->attribute('borderwidth');\n    $a->{peripheries} = 2 if $style =~ /^double/ && $w > 0;\n    }\n\n  # For nodes with shape plaintext, set the fillcolor to the background of\n  # the graph/group\n  my $shape = $a->{shape} || 'rect';\n  if ($class =~ /node/ && $shape eq 'plaintext')\n    {\n    my $p = $self->parent();\n    $a->{fillcolor} = $p->attribute('fill');\n    $a->{fillcolor} = 'white' if $a->{fillcolor} eq 'inherit';\n    }\n\n  $shape = $self->attribute('shape') unless $self->isa_cell();\n\n  # for point-shaped nodes, include the point as label and set width/height\n  if ($shape eq 'point')\n    {\n    require Graph::Easy::As_ascii;\t\t# for _u8 and point-style\n\n    my $style = $self->_point_style( \n\t$self->attribute('pointshape'), \n\t$self->attribute('pointstyle') );\n\n    $a->{label} = $style;\n    # for point-shaped invisible nodes, set height/width = 0\n    $a->{width} = 0, $a->{height} = 0 if $style eq '';  \n    }\n  if ($shape eq 'invisible')\n    {\n    $a->{label} = ' ';\n    }\n\n  $a->{rank} = '0' if $root ne '' && $root eq $self->{name};\n\n  # create the attributes as text:\n  for my $atr (sort keys %$a)\n    {\n    my $v = $a->{$atr};\n    $v =~ s/\"/\\\\\"/g;\t\t# '2\"' => '2\\\"'\n\n    # don't quote labels like \"<<TABLE..\"\n    if ($atr eq 'label' && $v =~ /^<<TABLE/)\n      {\n      my $va = $v; $va =~ s/\\\\\"/\"/g;\t\t# unescape \\\"\n      $att .= \"$atr=$va, \";\n      next;\n      }\n\n    $v = '\"' . $v . '\"' if $v !~ /^[a-z0-9A-Z]+\\z/\n\t  || $atr eq 'URL';\t# quote if nec.\n\n    # convert \"x-dot-foo\" to \"foo\". Special case \"K\":\n    my $name = $atr; $name =~ s/^x-dot-//; $name = 'K' if $name eq 'k';\n\n    $att .= \"$name=$v, \";\n    }\n  $att =~ s/,\\s$//;             # remove last \",\"\n\n  # generate attribute text if nec.\n  $att = ' [ ' . $att . ' ]' if $att ne '';\n\n  $att;\n  }\n\nsub _html_like_label\n  {\n  # Generate a HTML-like label from one node with its relative children\n  my ($self) = @_;\n\n  my $cells = {};\n  my $rc = $self->_do_place(0,0, { cells => $cells, cache => {} } );\n\n  # <TABLE BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\"><TR><TD>Name2</TD></TR><TR><TD\n  # ALIGN =\"LEFT\" BALIGN=\"LEFT\" PORT=\"E4\">Somewhere<BR/>test1<BR>test</TD></TR></TABLE>\n\n  my $label = '<<TABLE BORDER=\"0\"><TR>';\n\n  my $old_y = 0; my $old_x = 0;\n  # go through all children, and sort them by Y then X coordinate\n  my @cells = ();\n  for my $cell (sort {\n\tmy ($ax,$ay) = split /,/,$a;\n\tmy ($bx,$by) = split /,/,$b;\n\t$ay <=> $by or $ax <=> $bx; } keys %$cells )\n    {\n    #print \"cell $cell\\n\";\n    my ($x,$y) = split /,/, $cell;\n    if ($y > $old_y)\n      {\n      $label .= '</TR><TR>'; $old_x = 0;\n      }\n    my $n = $cells->{$cell};\n    my $l = $n->label();\n    $l =~ s/\\\\n/<BR\\/>/g;\n    my $portname = $n->{autosplit_portname};\n    $portname = $n->label() unless defined $portname;\n    my $name = $self->{name};\n    $portname =~ s/\\\"/\\\\\"/g;\t\t\t# quote \"\n    $name =~ s/\\\"/\\\\\"/g;\t\t\t# quote \"\n    # store the \"nodename:portname\" combination for potential edges\n    $n->{_graphviz_portname} = '\"' . $name . '\":\"' . $portname . '\"';\n    if (($x - $old_x) > 0)\n      {\n      # need some spacers\n      $label .= '<TD BORDER=\"0\" COLSPAN=\"' . ($x - $old_x) . '\"></TD>';\n      } \n    $label .= '<TD BORDER=\"1\" PORT=\"' . $portname . '\">' . $l . '</TD>';\n    $old_y = $y + $n->{cy}; $old_x = $x + $n->{cx};\n    }\n\n  # return \"<<TABLE.... /TABLE>>\"\n  $label . '</TR></TABLE>>';\n  }\n\nsub _graphviz_point\n  {\n  # return the node as the target/source of an edge\n  # either \"name\", or \"name:port\"\n  my ($n) = @_;\n\n  return $n->{_graphviz_portname} if exists $n->{_graphviz_portname};\n\n  $n->as_graphviz_txt();\n  }\n\nsub as_graphviz_txt\n  {\n  # return the node itself (w/o attributes) as graphviz representation\n  my $self = shift;\n\n  my $name = $self->{name};\n\n  # escape special chars in name (including doublequote!)\n  $name =~ s/([\\[\\]\\(\\)\\{\\}\"])/\\\\$1/g;\n\n  # quote if necessary:\n  # 2, A, A2, \"2A\", \"2 A\" etc\n  $name = '\"' . $name . '\"' if $name !~ /^([a-zA-Z_]+|\\d+)\\z/ ||\n \t$name =~ /^(subgraph|graph|node|edge|strict)\\z/i;\t# reserved keyword\n\n  $name;\n  }\n \n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::As_graphviz - Generate graphviz description from graph object\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\tprint $graph->as_graphviz();\n\n\t# prints something like:\n\n\t# digraph NAME { Bonn -> Berlin }\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::As_graphviz> contains just the code for converting a\nL<Graph::Easy|Graph::Easy> object to a textual description suitable for\nfeeding it to Graphviz programs like C<dot>.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<Graph::Easy::Parser::Graphviz>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/As_txt.pm": "#############################################################################\n# Output an Graph::Easy object as textual description\n#\n\npackage Graph::Easy::As_txt;\n\n$VERSION = '0.15';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\n\nsub _as_txt\n  {\n  my ($self) = @_;\n\n  # Convert the graph to a textual representation - does not need layout().\n  $self->_assign_ranks();\n\n  # generate the class attributes first\n  my $txt = '';\n  my $att =  $self->{att};\n  for my $class (sort keys %$att)\n    {\n\n    my $out = $self->_remap_attributes(\n     $class, $att->{$class}, {}, 'noquote', 'encode' );\n\n    my $att = '';\n    for my $atr (sort keys %$out)\n      {\n      # border is handled special below\n      next if $atr =~ /^border/;\n      $att .= \"  $atr: $out->{$atr};\\n\";\n      }\n\n    # edges do not have a border\n    if ($class !~ /^edge/)\n      {\n      my $border = $self->border_attribute($class) || '';\n\n      # 'solid 1px #000000' =~ /^solid/;\n      # 'solid 1px #000000' =~ /^solid 1px #000000/;\n      $border = '' if $self->default_attribute($class,'border') =~ /^$border/;\n\n      $att .= \"  border: $border;\\n\" if $border ne '';\n      }\n\n    if ($att ne '')\n      {\n      # the following makes short, single definitions to fit on one line\n      if ($att !~ /\\n.*\\n/ && length($att) < 40)\n        {\n        $att =~ s/\\n/ /; $att =~ s/^  / /;\n        }\n      else\n        {\n        $att = \"\\n$att\";\n        }\n      $txt .= \"$class {$att}\\n\";\n      }\n    }\n\n  $txt .= \"\\n\" if $txt ne '';\t\t# insert newline\n\n  my @nodes = $self->sorted_nodes('name','id');\n\n  my $count = 0;\n  # output nodes with attributes first, sorted by their name\n  foreach my $n (@nodes)\n    {\n    $n->{_p} = undef;\t\t\t# mark as not yet processed\n    my $att = $n->attributes_as_txt();\n    if ($att ne '')\n      {\n      $n->{_p} = 1;\t\t\t# mark as processed\n      $count++;\n      $txt .= $n->as_pure_txt() . $att . \"\\n\"; \n      }\n    }\n \n  $txt .= \"\\n\" if $count > 0;\t\t# insert a newline\n\n  # output groups first, with their nodes\n  foreach my $gn (sort keys %{$self->{groups}})\n    {\n    my $group = $self->{groups}->{$gn};\n    $txt .= $group->as_txt();\t\t# marks nodes as processed if nec.\n    $count++;\n    }\n\n  # XXX TODO:\n  # Output all nodes with rank=0 first, and also follow their successors\n  # What is left will then be done next, with rank=1 etc.\n  # This output order let's us output node chains in compact form as:\n  # [A]->[B]->[C]->[D]\n  # [B]->[E]\n  # instead of having:\n  # [A]->[B]\n  # [B]->[E]\n  # [B]->[C] etc\n \n  @nodes = $self->sorted_nodes('rank','name');\n  foreach my $n (@nodes)\n    {\n    my @out = $n->sorted_successors();\n    my $first = $n->as_pure_txt(); \t\t# [ A | B ]\n    if ( defined $n->{autosplit} || ((@out == 0) && ( (scalar $n->predecessors() || 0) == 0)))\n      {\n      # single node without any connections (unless already output)\n      next if exists $n->{autosplit} && !defined $n->{autosplit};\n      $txt .= $first . \"\\n\" unless defined $n->{_p};\n      }\n\n    $first = $n->_as_part_txt();\t\t# [ A.0 ]\n    # for all outgoing connections\n    foreach my $other (@out)\n      {\n      # in case there exists more than one edge from $n --> $other\n      my @edges = $n->edges_to($other);\n      for my $edge (sort { $a->{id} <=> $b->{id} } @edges)\n        {\n        $txt .= $first . $edge->as_txt() . $other->_as_part_txt() . \"\\n\";\n        }\n      }\n    }\n\n  foreach my $n (@nodes)\n    {\n    delete $n->{_p};\t\t\t# clean up\n    }\n\n  $txt;\n  }\n\n#############################################################################\n\npackage Graph::Easy::Group;\n\nuse strict;\n\nsub as_txt\n  {\n  my $self = shift;\n\n  my $n = '';\n  if (!$self->isa('Graph::Easy::Group::Anon'))\n    {\n    $n = $self->{name};\n    # quote special chars in name\n    $n =~ s/([\\[\\]\\(\\)\\{\\}\\#])/\\\\$1/g;\n    $n = ' ' . $n;\n    }\n\n  my $txt = \"($n\";\n\n  $n = $self->{nodes};\n\n  $txt .= (keys %$n > 0 ? \"\\n\" : ' ');\n  for my $name ( sort keys %$n )\n    {\n    $n->{$name}->{_p} = 1;                              # mark as processed\n    $txt .= '  ' . $n->{$name}->as_pure_txt() . \"\\n\";\n    }\n  $txt .= \")\" . $self->attributes_as_txt() . \"\\n\\n\";\n\n  # insert all the edges of the group\n\n  #\n  $txt;\n  }\n\n#############################################################################\n\npackage Graph::Easy::Node;\n\nuse strict;\n\nsub attributes_as_txt\n  {\n  # return the attributes of this node as text description\n  my ($self, $remap) = @_;\n\n  # nodes that were autosplit\n  if (exists $self->{autosplit})\n    {\n    # other nodes are invisible in as_txt: \n    return '' unless defined $self->{autosplit};\n    # the first one might have had a label set\n    }\n\n  my $att = '';\n  my $class = $self->class();\n  my $g = $self->{graph};\n\n  # XXX TODO: remove atttributes that are simple the default attributes\n\n  my $attributes = $self->{att};\n  if (exists $self->{autosplit})\n    {\n    # for the first node in a row of autosplit nodes, we need to create\n    # the correct attributes, e.g. \"silver|red|\" instead of just silver:\n    my $basename = $self->{autosplit_basename};\n    $attributes = { };\n\n    my $parts = $self->{autosplit_parts};\n    # gather all possible attribute names, otherwise an attribute set\n    # on only one part (like via \"color: |red;\" would not show up:\n    my $names = {};\n    for my $child ($self, @$parts)\n      {\n      for my $k (keys %{$child->{att}})\n        {\n        $names->{$k} = undef;\n        }\n      }\n\n    for my $k (keys %$names)\n      {\n      next if $k eq 'basename';\n      my $val = $self->{att}->{$k};\n      $val = '' unless defined $val;\n      my $first = $val; my $not_equal = 0;\n      $val .= '|';\n      for my $child (@$parts)\n        {\n        # only consider our own autosplit parts (check should not be nec.)\n#        next if !exists $child->{autosplit_basename} ||\n#                        $child->{autosplit_basename} ne $basename;\n\n        my $v = $child->{att}->{$k}; $v = '' if !defined $v;\n        $not_equal ++ if $v ne $first;\n        $val .= $v . '|';\n        }\n      # all parts equal, so do \"red|red|red\" => \"red\"\n      $val = $first if $not_equal == 0;\n\n      $val =~ s/\\|+\\z/\\|/;\t\t\t\t# \"silver|||\" => \"silver|\"\n      $val =~ s/\\|\\z// if $val =~ /\\|.*\\|/;\t\t# \"silver|\" => \"silver|\"\n      \t\t\t\t\t\t\t# but \"red|blue|\" => \"red|blue\"\n      $attributes->{$k} = $val unless $val eq '|';\t# skip '|'\n      }\n    $attributes->{basename} = $self->{att}->{basename} if defined $self->{att}->{basename};\n    }\n\n  my $new = $g->_remap_attributes( $self, $attributes, $remap, 'noquote', 'encode' );\n\n  # For nodes, we do not output their group attribute, since they simple appear\n  # at the right place in the txt:\n  delete $new->{group};\n\n  # for groups inside groups, insert their group attribute\n  $new->{group} = $self->{group}->{name} \n    if $self->isa('Graph::Easy::Group') && exists $self->{group};\n\n  if (defined $self->{origin})\n    {\n    $new->{origin} = $self->{origin}->{name};\n    $new->{offset} = join(',', $self->offset());\n    }\n\n  # shorten output for multi-celled nodes\n  # for \"rows: 2;\" still output \"rows: 2;\", because it is shorter\n  if (exists $new->{columns})\n    {\n    $new->{size} = ($new->{columns}||1) . ',' . ($new->{rows}||1);\n    delete $new->{rows};\n    delete $new->{columns};\n    # don't output the default size\n    delete $new->{size} if $new->{size} eq '1,1';\n    } \n\n  for my $atr (sort keys %$new)\n    {\n    next if $atr =~ /^border/;                  # handled special\n\n    $att .= \"$atr: $new->{$atr}; \";\n    }\n\n  if (!$self->isa_cell())\n    {\n    my $border;\n    if (!exists $self->{autosplit})\n      {\n      $border = $self->border_attribute();\n      }\n    else\n      {\n      $border = Graph::Easy::_border_attribute(\n\t$attributes->{borderstyle}||'',\n\t$attributes->{borderwidth}||'',\n\t$attributes->{bordercolor}||'');\n      }\n\n    # XXX TODO: should do this for all attributes, not only for border\n    # XXX TODO: this seems wrong anyway\n\n    # don't include default border\n    $border = '' if ref $g && $g->attribute($class,'border') eq $border;\n    $att .= \"border: $border; \" if $border ne '';\n    }\n\n  # if we have a subclass, we probably need to include it\n  my $c = '';\n  $c = $1 if $class =~ /\\.(\\w+)/;\n\n  # but we do not need to include it if our group has a nodeclass attribute\n  $c = '' if ref($self->{group}) && $self->{group}->attribute('nodeclass') eq $c;\n\n  # include our subclass as attribute\n  $att .= \"class: $c; \" if $c ne '' && $c ne 'anon';\n\n  # generate attribute text if nec.\n  $att = ' { ' . $att . '}' if $att ne '';\n\n  $att;\n  }\n\nsub _as_part_txt\n  {\n  # for edges, we need the name of the part of the first part, not the entire\n  # autosplit text\n  my $self = shift;\n\n  my $name = $self->{name};\n\n  # quote special chars in name\n  $name =~ s/([\\[\\]\\|\\{\\}\\#])/\\\\$1/g;\n\n  '[ ' .  $name . ' ]';\n  }\n\nsub as_pure_txt\n  {\n  my $self = shift;\n\n  if (exists $self->{autosplit} && defined $self->{autosplit})\n    {\n    my $name = $self->{autosplit};\n\n    # quote special chars in name (but not |)\n    $name =~ s/([\\[\\]\\{\\}\\#])/\\\\$1/g;\n \n    return '[ '. $name .' ]' \n    }\n\n  my $name = $self->{name};\n\n  # quote special chars in name\n  $name =~ s/([\\[\\]\\|\\{\\}\\#])/\\\\$1/g;\n\n  '[ ' .  $name . ' ]';\n  }\n\nsub as_txt\n  {\n  my $self = shift;\n\n  if (exists $self->{autosplit})\n    {\n    return '' unless defined $self->{autosplit};\n    my $name = $self->{autosplit};\n    # quote special chars in name (but not |)\n    $name =~ s/([\\[\\]\\{\\}\\#])/\\\\$1/g;\n    return '[ ' . $name . ' ]' \n    }\n\n  my $name = $self->{name};\n\n  # quote special chars in name\n  $name =~ s/([\\[\\]\\|\\{\\}\\#])/\\\\$1/g;\n\n  '[ ' .  $name . ' ]' . $self->attributes_as_txt();\n  }\n\n#############################################################################\n\npackage Graph::Easy::Edge;\n\nmy $styles = {\n  solid => '--',\n  dotted => '..',\n  double => '==',\n  'double-dash' => '= ',\n  dashed => '- ',\n  'dot-dash' => '.-',\n  'dot-dot-dash' => '..-',\n  wave => '~~',\n  };\n\nsub _as_txt\n  {\n  my $self = shift;\n\n  # '- Name ' or ''\n  my $n = $self->{att}->{label}; $n = '' unless defined $n;\n\n  my $left = ' '; $left = ' <' if $self->{bidirectional};\n  my $right = '> '; $right = ' ' if $self->{undirected};\n  \n  my $s = $self->style() || 'solid';\n\n  my $style = '--';\n\n  # suppress border on edges\n  my $suppress = { all => { label => undef } };\n  if ($s =~ /^(bold|bold-dash|broad|wide|invisible)\\z/)\n    {\n    # output \"--> { style: XXX; }\"\n    $style = '--';\n    }\n  else\n    {\n    # output \"-->\" or \"..>\" etc\n    $suppress->{all}->{style} = undef;\n\n    $style = $styles->{ $s };\n    if (!defined $style)\n      {\n      require Carp;\n      Carp::confess (\"Unknown edge style '$s'\\n\");\n      }\n    }\n \n  $n = $style . \" $n \" if $n ne '';\n\n  # make \" -  \" into \" - -  \"\n  $style = $style . $style if $self->{undirected} && substr($style,1,1) eq ' ';\n\n  # ' - Name -->' or ' --> ' or ' -- '\n  my $a = $self->attributes_as_txt($suppress) . ' '; $a =~ s/^\\s//;\n  $left . $n . $style . $right . $a;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::As_txt - Generate textual description from graph object\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\tprint $graph->as_txt();\n\n\t# prints something like:\n\n\t# [ Bonn ] -> [ Berlin ]\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::As_txt> contains just the code for converting a\nL<Graph::Easy|Graph::Easy> object to a human-readable textual description.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n\n",
  "Graph/Easy/As_vcg.pm": "#############################################################################\n# Output the graph as VCG or GDL text.\n#\n#############################################################################\n\npackage Graph::Easy::As_vcg;\n\n$VERSION = '0.05';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\n\nmy $vcg_remap = {\n  node => {\n    align => \\&_vcg_remap_align,\n    autolabel => undef,\n    autolink => undef,\n    autotitle => undef,\n    background => undef, \n    basename => undef,\n    class => undef,\n    colorscheme => undef,\n    columns => undef,\n    flow => undef,\n    fontsize => undef,\n    format => undef,\n    group => undef,\n    id => undef,\n    link => undef,\n    linkbase => undef,\n    offset => undef,\n    origin => undef,\n    pointstyle => undef,\n    rank => 'level',\n    rotate => undef,\n    rows => undef,\n    shape => \\&_vcg_remap_shape,\n    size => undef,\n    textstyle => undef,\n    textwrap => undef,\n    title => undef,\n    },\n  edge => {\n    color => 'color',\t\t\t# this entry overrides 'all'!\n    align => undef,\n    arrowshape => undef,\n    arrowstyle => undef,\n    autojoin => undef,\n    autolabel => undef,\n    autolink => undef,\n    autosplit => undef,\n    autotitle => undef,\n    border => undef,\n    bordercolor => undef,\n    borderstyle => undef,\n    borderwidth => undef,\n    colorscheme => undef,\n    end => undef,\n    fontsize => undef,\n    format => undef,\n    id => undef,\n    labelcolor => 'textcolor',\n    link => undef,\n    linkbase => undef,\n    minlen => undef,\n    start => undef,\n    # XXX TODO: remap unknown styles\n    style => 'linestyle',\n    textstyle => undef,\n    textwrap => undef,\n    title => undef, \n    },\n  graph => {\n    align => \\&_vcg_remap_align,\n    flow => \\&_vcg_remap_flow,\n    label => 'title',\n    type => undef,\n    },\n  group => {\n    },\n  all => {\n    background => undef,\n    color => 'textcolor',\n    comment => undef,\n    fill => 'color',\n    font => 'fontname',\n    },\n  always => {\n    },\n  # this routine will handle all custom \"x-dot-...\" attributes\n  x => \\&_remap_custom_vcg_attributes,\n  };\n\nsub _remap_custom_vcg_attributes\n  {\n  my ($self, $name, $value) = @_;\n\n  # drop anything that is not starting with \"x-vcg-...\"\n  return (undef,undef) unless $name =~ /^x-vcg-/;\n\n  $name =~ s/^x-vcg-//;\t\t\t# \"x-vcg-foo\" => \"foo\"\n  ($name,$value);\n  }\n\nmy $vcg_shapes = {\n  rect => 'box',\n  diamond => 'rhomb',\n  triangle => 'triangle',\n  invtriangle => 'triangle',\n  ellipse => 'ellipse',\n  circle => 'circle',\n  hexagon => 'hexagon',\n  trapezium => 'trapeze',\n  invtrapezium => 'uptrapeze',\n  invparallelogram => 'lparallelogram',\n  parallelogram => 'rparallelogram',\n  };\n\nsub _vcg_remap_shape\n  {\n  my ($self, $name, $shape) = @_;\n\n  return ('invisible','yes') if $shape eq 'invisible';\n\n  ('shape', $vcg_shapes->{$shape} || 'box');\n  }\n\nsub _vcg_remap_align\n  {\n  my ($self, $name, $style) = @_;\n\n  # center => center, left => left_justify, right => right_justify\n  $style .= '_justify' unless $style eq 'center';\n\n  ('textmode', $style);\n  }\n\nmy $vcg_flow = {\n  'south' => 'top_to_bottom',\n  'north' => 'bottom_to_top',\n  'down' => 'top_to_bottom',\n  'up' => 'bottom_to_top',\n  'east' => 'left_to_right',\n  'west' => 'right_to_left',\n  'right' => 'left_to_right',\n  'left' => 'right_to_left',\n  };\n\nsub _vcg_remap_flow\n  {\n  my ($self, $name, $style) = @_;\n\n  ('orientation', $vcg_flow->{$style} || 'top_to_bottom');\n  }\n\nsub _class_attributes_as_vcg\n  {\n  # convert a hash with attribute => value mappings to a string\n  my ($self, $a, $class) = @_;\n\n\n  my $att = '';\n  $class = '' if $class eq 'graph';\n  $class .= '.' if $class ne '';\n  \n  # create the attributes as text:\n  for my $atr (sort keys %$a)\n    {\n    my $v = $a->{$atr};\n    $v =~ s/\"/\\\\\"/g;            # '2\"' => '2\\\"'\n    $v = '\"' . $v . '\"' unless $v =~ /^[0-9]+\\z/;       # 1, \"1a\"\n    $att .= \"  $class$atr: $v\\n\";\n    }\n  $att =~ s/,\\s$//;             # remove last \",\"\n\n  $att = \"\\n$att\" unless $att eq '';\n  $att;\n  }\n\n#############################################################################\n\nsub _generate_vcg_edge\n  {\n  # Given an edge, generate the VCG code for it\n  my ($self, $e, $indent) = @_;\n\n  # skip links from/to groups, these will be done later\n  return '' if \n    $e->{from}->isa('Graph::Easy::Group') ||\n    $e->{to}->isa('Graph::Easy::Group');\n\n  my $edge_att = $e->attributes_as_vcg();\n\n  $e->{_p} = undef;\t\t\t\t# mark as processed\n  \"  edge:$edge_att\\n\";\t\t\t\t# return edge text\n  }\n\nsub _as_vcg\n  {\n  my ($self) = @_;\n\n  # convert the graph to a textual representation\n  # does not need a layout() beforehand!\n\n  # gather all edge classes to build the classname attribute from them:\n  $self->{_vcg_edge_classes} = {};\n  for my $e (values %{$self->{edges}})\n    {\n    my $class = $e->sub_class();\n    $self->{_vcg_edge_classes}->{$class} = undef if defined $class && $class ne '';\n    }\n  # sort gathered class names and map them to integers\n  my $class_names = '';\n  if (keys %{$self->{_vcg_edge_classes}} > 0)\n    {\n    my $i = 1;\n    $class_names = \"\\n\";\n    for my $ec (sort keys %{$self->{_vcg_edge_classes}})\n      {\n      $self->{_vcg_edge_classes}->{$ec} = $i;\t# remember mapping\n      $class_names .= \"  classname $i: \\\"$ec\\\"\\n\";\n      $i++;\n      }\n    }\n\n  # generate the class attributes first\n  my $label = $self->label();\n  my $t = ''; $t = \"\\n  title: \\\"$label\\\"\" if $label ne '';\n\n  my $txt = \"graph: {$t\\n\\n\" .\n            \"  // Generated by Graph::Easy $Graph::Easy::VERSION\" .\n\t    \" at \" . scalar localtime() . \"\\n\" .\n\t    $class_names;\n\n  my $groups = $self->groups();\n\n  # to keep track of invisible helper nodes\n  $self->{_vcg_invis} = {};\n  # name for invisible helper nodes\n  $self->{_vcg_invis_id} = 'joint0';\n\n  my $atts = $self->{att};\n  # insert the class attributes\n  for my $class (qw/edge graph node/)\n    {\n    next if $class =~ /\\./;\t\t# skip subclasses\n\n    my $out = $self->_remap_attributes( $class, $atts->{$class}, $vcg_remap, 'noquote');\n    $txt .= $self->_class_attributes_as_vcg($out, $class);\n    }\n\n  $txt .= \"\\n\" if $txt ne '';\t\t# insert newline\n\n  ###########################################################################\n  # output groups as subgraphs\n\n  # insert the edges into the proper group\n  $self->_edges_into_groups() if $groups > 0;\n\n  # output the groups (aka subclusters)\n  my $indent = '    ';\n  for my $group (sort { $a->{name} cmp $b->{name} } values %{$self->{groups}})\n    {\n    # quote special chars in group name\n    my $name = $group->{name}; $name =~ s/([\\[\\]\\(\\)\\{\\}\\#\"])/\\\\$1/g;\n\n#    # output group attributes first\n#    $txt .= \"  subgraph \\\"cluster$group->{id}\\\" {\\n${indent}label=\\\"$name\\\";\\n\";\n   \n    # Make a copy of the attributes, including our class attributes:\n    my $copy = {};\n    my $attribs = $group->get_attributes();\n\n    for my $a (keys %$attribs)\n      {\n      $copy->{$a} = $attribs->{$a};\n      }\n#    # set some defaults\n#    $copy->{'borderstyle'} = 'solid' unless defined $copy->{'borderstyle'};\n\n    my $out = {};\n#    my $out = $self->_remap_attributes( $group->class(), $copy, $vcg_remap, 'noquote');\n\n    # Set some defaults:\n    $out->{fillcolor} = '#a0d0ff' unless defined $out->{fillcolor};\n#    $out->{labeljust} = 'l' unless defined $out->{labeljust};\n\n    my $att = '';\n    # we need to output style first (\"filled\" and \"color\" need come later)\n    for my $atr (reverse sort keys %$out)\n      {\n      my $v = $out->{$atr};\n      $v = '\"' . $v . '\"';\n      $att .= \"    $atr: $v\\n\";\n      }\n    $txt .= $att . \"\\n\" if $att ne '';\n \n#    # output nodes (w/ or w/o attributes) in that group\n#    for my $n ($group->sorted_nodes())\n#      {\n#      my $att = $n->attributes_as_vcg();\n#      $n->{_p} = undef;\t\t\t# mark as processed\n#      $txt .= $indent . $n->as_graphviz_txt() . $att . \"\\n\";\n#      }\n\n#    # output node connections in this group\n#    for my $e (values %{$group->{edges}})\n#      {\n#      next if exists $e->{_p};\n#      $txt .= $self->_generate_edge($e, $indent);\n#      }\n\n    $txt .= \"  }\\n\";\n    }\n\n  my $root = $self->attribute('root');\n  $root = '' unless defined $root;\n\n  my $count = 0;\n  # output nodes with attributes first, sorted by their name\n  for my $n (sort { $a->{name} cmp $b->{name} } values %{$self->{nodes}})\n    {\n    next if exists $n->{_p};\n    my $att = $n->attributes_as_vcg($root);\n    if ($att ne '')\n      {\n      $n->{_p} = undef;\t\t\t# mark as processed\n      $count++;\n      $txt .= \"  node:\" . $att . \"\\n\"; \n      }\n    }\n \n  $txt .= \"\\n\" if $count > 0;\t\t# insert a newline\n\n  my @nodes = $self->sorted_nodes();\n\n  foreach my $n (@nodes)\n    {\n    my @out = $n->successors();\n    my $first = $n->as_vcg_txt();\n    if ((@out == 0) && ( (scalar $n->predecessors() || 0) == 0))\n      {\n      # single node without any connections (unless already output)\n      $txt .= \"  node: { title: \" . $first . \" }\\n\" unless exists $n->{_p};\n      }\n    # for all outgoing connections\n    foreach my $other (reverse @out)\n      {\n      # in case there is more than one edge going from N to O\n      my @edges = $n->edges_to($other);\n      foreach my $e (@edges)\n        {\n        next if exists $e->{_p};\n        $txt .= $self->_generate_vcg_edge($e, '  ');\n        }\n      }\n    }\n\n  # insert now edges between groups (clusters/subgraphs)\n\n#  foreach my $e (values %{$self->{edges}})\n#    {\n#    $txt .= $self->_generate_group_edge($e, '  ') \n#     if $e->{from}->isa('Graph::Easy::Group') ||\n#        $e->{to}->isa('Graph::Easy::Group');\n#    }\n\n  # clean up\n  for my $n ( values %{$self->{nodes}}, values %{$self->{edges}})\n    {\n    delete $n->{_p};\n    }\n  delete $self->{_vcg_invis};\t\t# invisible helper nodes for joints\n  delete $self->{_vcg_invis_id};\t# invisible helper node name\n  delete $self->{_vcg_edge_classes};\n\n  $txt .  \"\\n}\\n\";\t\t\t# close the graph\n  }\n\npackage Graph::Easy::Node;\n\nsub attributes_as_vcg\n  {\n  # return the attributes of this node as text description\n  my ($self, $root) = @_;\n  $root = '' unless defined $root;\n\n  my $att = '';\n  my $class = $self->class();\n\n  return '' unless ref $self->{graph};\n\n  my $g = $self->{graph};\n\n  # get all attributes, excluding the class attributes\n  my $a = $self->raw_attributes();\n\n  # add the attributes that are listed under \"always\":\n  my $attr = $self->{att};\n  my $base_class = $class; $base_class =~ s/\\..*//;\n  my $list = $vcg_remap->{always}->{$class} || $vcg_remap->{always}->{$base_class};\n\n  for my $name (@$list)\n    {\n    # for speed, try to look it up directly\n\n    # look if we have a code ref, if yes, simple set the value to undef\n    # and let the coderef handle it later:\n    if ( ref($vcg_remap->{$base_class}->{$name}) ||\n         ref($vcg_remap->{all}->{$name}) )\n      {\n      $a->{$name} = $attr->{$name};\n      }\n    else\n      {\n      $a->{$name} = $attr->{$name};\n      $a->{$name} = $self->attribute($name) unless defined $a->{$name} && $a->{$name} ne 'inherit';\n      }\n    }\n\n  $a = $g->_remap_attributes( $self, $a, $vcg_remap, 'noquote');\n\n  if ($self->isa('Graph::Easy::Edge'))\n    {\n    $a->{sourcename} = $self->{from}->{name};\n    $a->{targetname} = $self->{to}->{name};\n    my $class = $self->sub_class();\n    $a->{class} = $self->{graph}->{_vcg_edge_classes}->{ $class } if defined $class && $class ne '';\n    }\n  else\n    {\n    # title: \"Bonn\"\n    $a->{title} = $self->{name};\n    }\n\n  # do not needlessly output labels:\n  delete $a->{label} if !$self->isa('Graph::Easy::Edge') &&\t\t# not an edge\n\texists $a->{label} && $a->{label} eq $self->{name};\n\n  # bidirectional and undirected edges\n  if ($self->{bidirectional})\n    {\n    delete $a->{dir};\n    my ($n,$s) = Graph::Easy::_graphviz_remap_arrow_style(\n\t$self,'', $self->attribute('arrowstyle'));\n    $a->{arrowhead} = $s; \n    $a->{arrowtail} = $s; \n    }\n  if ($self->{undirected})\n    {\n    delete $a->{dir};\n    $a->{arrowhead} = 'none'; \n    $a->{arrowtail} = 'none'; \n    }\n\n  # borderstyle: double:\n  if (!$self->isa('Graph::Easy::Edge'))\n    {\n    my $style = $self->attribute('borderstyle');\n    $a->{peripheries} = 2 if $style =~ /^double/;\n    }\n\n  # For nodes with shape plaintext, set the fillcolor to the background of\n  # the graph/group\n  my $shape = $a->{shape} || 'rect';\n  if ($class =~ /node/ && $shape eq 'plaintext')\n    {\n    my $p = $self->parent();\n    $a->{fillcolor} = $p->attribute('fill');\n    $a->{fillcolor} = 'white' if $a->{fillcolor} eq 'inherit';\n    }\n\n  $shape = $self->attribute('shape') unless $self->isa_cell();\n\n  # for point-shaped nodes, include the point as label and set width/height\n  if ($shape eq 'point')\n    {\n    require Graph::Easy::As_ascii;\t\t# for _u8 and point-style\n\n    my $style = $self->_point_style( $self->attribute('pointstyle') );\n\n    $a->{label} = $style;\n    # for point-shaped invisible nodes, set height/width = 0\n    $a->{width} = 0, $a->{height} = 0 if $style eq '';  \n    }\n  if ($shape eq 'invisible')\n    {\n    $a->{label} = ' ';\n    }\n\n  $a->{rank} = '0' if $root ne '' && $root eq $self->{name};\n\n  # create the attributes as text:\n  for my $atr (sort keys %$a)\n    {\n    my $v = $a->{$atr};\n    $v =~ s/\"/\\\\\"/g;\t\t# '2\"' => '2\\\"'\n    $v = '\"' . $v . '\"' unless $v =~ /^[0-9]+\\z/;\t# 1, \"1a\"\n    $att .= \"$atr: $v \";\n    }\n  $att =~ s/,\\s$//;             # remove last \",\"\n\n  # generate attribute text if nec.\n  $att = ' { ' . $att . '}' if $att ne '';\n\n  $att;\n  }\n\nsub as_vcg_txt\n  {\n  # return the node itself (w/o attributes) as VCG representation\n  my $self = shift;\n\n  my $name = $self->{name};\n\n  # escape special chars in name (including doublequote!)\n  $name =~ s/([\\[\\]\\(\\)\\{\\}\"])/\\\\$1/g;\n\n  # quote:\n  '\"' . $name . '\"';\n  }\n \n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::As_vcg - Generate VCG/GDL text from Graph::Easy object\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\tprint $graph->as_vcg();\n\n\nThis prints something like this:\n\n\tgraph: {\n\t\tnode: { title: \"Bonn\" }\n\t\tnode: { title: \"Berlin\" }\n\t\tedge: { sourcename: \"Bonn\" targetname: \"Berlin\" }\n\t}\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::As_vcg> contains just the code for converting a\nL<Graph::Easy|Graph::Easy> object to either a VCG \nor GDL textual description.\n\nNote that the generated format is compatible to C<GDL> aka I<Graph\nDescription Language>.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<http://rw4.cs.uni-sb.de/~sander/html/gsvcg1.html>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004-2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Attributes.pm": "#############################################################################\n# Define and check attributes for a Graph::Easy textual description.\n#\n#############################################################################\n\npackage Graph::Easy::Attributes;\n\n$VERSION = '0.32';\n\npackage Graph::Easy;\n\nuse strict;\nuse utf8;\t\t# for examples like \"Fähre\"\n\n# to make it easier to remember the attribute names:\nmy $att_aliases = {\n  'auto-label' => 'autolabel',\n  'auto-link' => 'autolink',\n  'auto-title' => 'autotitle',\n  'arrow-style' => 'arrowstyle',\n  'arrow-shape' => 'arrowshape',\n  'border-color' => 'bordercolor',\n  'border-style' => 'borderstyle',\n  'border-width' => 'borderwidth',\n  'font-size' => 'fontsize',\n  'label-color' => 'labelcolor',\n  'label-pos' => 'labelpos',\n  'text-style' => 'textstyle',\n  'text-wrap' => 'textwrap',\n  'point-style' => 'pointstyle',\n  'point-shape' => 'pointshape',\n  };\n\nsub _att_aliases { $att_aliases; }\n\n#############################################################################\n# color handling\n\n# The W3C/SVG/CSS color scheme\n\nmy $color_names = {\n  w3c =>\n  {\n  inherit\t\t=> 'inherit',\n  aliceblue             => '#f0f8ff',\n  antiquewhite          => '#faebd7',\n  aquamarine            => '#7fffd4',\n  aqua                  => '#00ffff',\n  azure                 => '#f0ffff',\n  beige                 => '#f5f5dc',\n  bisque                => '#ffe4c4',\n  black                 => '#000000',\n  blanchedalmond        => '#ffebcd',\n  blue                  => '#0000ff',\n  blueviolet            => '#8a2be2',\n  brown                 => '#a52a2a',\n  burlywood             => '#deb887',\n  cadetblue             => '#5f9ea0',\n  chartreuse            => '#7fff00',\n  chocolate             => '#d2691e',\n  coral                 => '#ff7f50',\n  cornflowerblue        => '#6495ed',\n  cornsilk              => '#fff8dc',\n  crimson               => '#dc143c',\n  cyan                  => '#00ffff',\n  darkblue              => '#00008b',\n  darkcyan              => '#008b8b',\n  darkgoldenrod         => '#b8860b',\n  darkgray              => '#a9a9a9',\n  darkgreen             => '#006400',\n  darkgrey              => '#a9a9a9',\n  darkkhaki             => '#bdb76b',\n  darkmagenta           => '#8b008b',\n  darkolivegreen        => '#556b2f',\n  darkorange            => '#ff8c00',\n  darkorchid            => '#9932cc',\n  darkred               => '#8b0000',\n  darksalmon            => '#e9967a',\n  darkseagreen          => '#8fbc8f',\n  darkslateblue         => '#483d8b',\n  darkslategray         => '#2f4f4f',\n  darkslategrey         => '#2f4f4f',\n  darkturquoise         => '#00ced1',\n  darkviolet            => '#9400d3',\n  deeppink              => '#ff1493',\n  deepskyblue           => '#00bfff',\n  dimgray               => '#696969',\n  dodgerblue            => '#1e90ff',\n  firebrick             => '#b22222',\n  floralwhite           => '#fffaf0',\n  forestgreen           => '#228b22',\n  fuchsia               => '#ff00ff',\n  gainsboro             => '#dcdcdc',\n  ghostwhite            => '#f8f8ff',\n  goldenrod             => '#daa520',\n  gold                  => '#ffd700',\n  gray                  => '#808080',\n  green                 => '#008000',\n  greenyellow           => '#adff2f',\n  grey                  => '#808080',\n  honeydew              => '#f0fff0',\n  hotpink               => '#ff69b4',\n  indianred             => '#cd5c5c',\n  indigo                => '#4b0082',\n  ivory                 => '#fffff0',\n  khaki                 => '#f0e68c',\n  lavenderblush         => '#fff0f5',\n  lavender              => '#e6e6fa',\n  lawngreen             => '#7cfc00',\n  lemonchiffon          => '#fffacd',\n  lightblue             => '#add8e6',\n  lightcoral            => '#f08080',\n  lightcyan             => '#e0ffff',\n  lightgoldenrodyellow  => '#fafad2',\n  lightgray             => '#d3d3d3',\n  lightgreen            => '#90ee90',\n  lightgrey             => '#d3d3d3',\n  lightpink             => '#ffb6c1',\n  lightsalmon           => '#ffa07a',\n  lightseagreen         => '#20b2aa',\n  lightskyblue          => '#87cefa',\n  lightslategray        => '#778899',\n  lightslategrey        => '#778899',\n  lightsteelblue        => '#b0c4de',\n  lightyellow           => '#ffffe0',\n  limegreen             => '#32cd32',\n  lime\t\t\t=> '#00ff00',\n  linen                 => '#faf0e6',\n  magenta               => '#ff00ff',\n  maroon                => '#800000',\n  mediumaquamarine      => '#66cdaa',\n  mediumblue            => '#0000cd',\n  mediumorchid          => '#ba55d3',\n  mediumpurple          => '#9370db',\n  mediumseagreen        => '#3cb371',\n  mediumslateblue       => '#7b68ee',\n  mediumspringgreen     => '#00fa9a',\n  mediumturquoise       => '#48d1cc',\n  mediumvioletred       => '#c71585',\n  midnightblue          => '#191970',\n  mintcream             => '#f5fffa',\n  mistyrose             => '#ffe4e1',\n  moccasin              => '#ffe4b5',\n  navajowhite           => '#ffdead',\n  navy                  => '#000080',\n  oldlace               => '#fdf5e6',\n  olivedrab             => '#6b8e23',\n  olive                 => '#808000',\n  orangered             => '#ff4500',\n  orange                => '#ffa500',\n  orchid                => '#da70d6',\n  palegoldenrod         => '#eee8aa',\n  palegreen             => '#98fb98',\n  paleturquoise         => '#afeeee',\n  palevioletred         => '#db7093',\n  papayawhip            => '#ffefd5',\n  peachpuff             => '#ffdab9',\n  peru                  => '#cd853f',\n  pink                  => '#ffc0cb',\n  plum                  => '#dda0dd',\n  powderblue            => '#b0e0e6',\n  purple                => '#800080',\n  red                   => '#ff0000',\n  rosybrown             => '#bc8f8f',\n  royalblue             => '#4169e1',\n  saddlebrown           => '#8b4513',\n  salmon                => '#fa8072',\n  sandybrown            => '#f4a460',\n  seagreen              => '#2e8b57',\n  seashell              => '#fff5ee',\n  sienna                => '#a0522d',\n  silver                => '#c0c0c0',\n  skyblue               => '#87ceeb',\n  slateblue             => '#6a5acd',\n  slategray             => '#708090',\n  slategrey             => '#708090',\n  snow                  => '#fffafa',\n  springgreen           => '#00ff7f',\n  steelblue             => '#4682b4',\n  tan                   => '#d2b48c',\n  teal                  => '#008080',\n  thistle               => '#d8bfd8',\n  tomato                => '#ff6347',\n  turquoise             => '#40e0d0',\n  violet                => '#ee82ee',\n  wheat                 => '#f5deb3',\n  white                 => '#ffffff',\n  whitesmoke            => '#f5f5f5',\n  yellowgreen           => '#9acd32',\n  yellow                => '#ffff00',\n  },\n\n  x11 => {\n    inherit\t\t=> 'inherit',\n    aliceblue\t\t=> '#f0f8ff',\n    antiquewhite\t=> '#faebd7',\n    antiquewhite1\t=> '#ffefdb',\n    antiquewhite2\t=> '#eedfcc',\n    antiquewhite3\t=> '#cdc0b0',\n    antiquewhite4\t=> '#8b8378',\n    aquamarine\t\t=> '#7fffd4',\n    aquamarine1\t\t=> '#7fffd4',\n    aquamarine2\t\t=> '#76eec6',\n    aquamarine3\t\t=> '#66cdaa',\n    aquamarine4\t\t=> '#458b74',\n    azure\t\t=> '#f0ffff',\n    azure1\t\t=> '#f0ffff',\n    azure2\t\t=> '#e0eeee',\n    azure3\t\t=> '#c1cdcd',\n    azure4\t\t=> '#838b8b',\n    beige\t\t=> '#f5f5dc',\n    bisque\t\t=> '#ffe4c4',\n    bisque1\t\t=> '#ffe4c4',\n    bisque2\t\t=> '#eed5b7',\n    bisque3\t\t=> '#cdb79e',\n    bisque4\t\t=> '#8b7d6b',\n    black\t\t=> '#000000',\n    blanchedalmond\t=> '#ffebcd',\n    blue\t\t=> '#0000ff',\n    blue1\t\t=> '#0000ff',\n    blue2\t\t=> '#0000ee',\n    blue3\t\t=> '#0000cd',\n    blue4\t\t=> '#00008b',\n    blueviolet\t\t=> '#8a2be2',\n    brown\t\t=> '#a52a2a',\n    brown1\t\t=> '#ff4040',\n    brown2\t\t=> '#ee3b3b',\n    brown3\t\t=> '#cd3333',\n    brown4\t\t=> '#8b2323',\n    burlywood\t\t=> '#deb887',\n    burlywood1\t\t=> '#ffd39b',\n    burlywood2\t\t=> '#eec591',\n    burlywood3\t\t=> '#cdaa7d',\n    burlywood4\t\t=> '#8b7355',\n    cadetblue\t\t=> '#5f9ea0',\n    cadetblue1\t\t=> '#98f5ff',\n    cadetblue2\t\t=> '#8ee5ee',\n    cadetblue3\t\t=> '#7ac5cd',\n    cadetblue4\t\t=> '#53868b',\n    chartreuse\t\t=> '#7fff00',\n    chartreuse1\t\t=> '#7fff00',\n    chartreuse2\t\t=> '#76ee00',\n    chartreuse3\t\t=> '#66cd00',\n    chartreuse4\t\t=> '#458b00',\n    chocolate\t\t=> '#d2691e',\n    chocolate1\t\t=> '#ff7f24',\n    chocolate2\t\t=> '#ee7621',\n    chocolate3\t\t=> '#cd661d',\n    chocolate4\t\t=> '#8b4513',\n    coral\t\t=> '#ff7f50',\n    coral1\t\t=> '#ff7256',\n    coral2\t\t=> '#ee6a50',\n    coral3\t\t=> '#cd5b45',\n    coral4\t\t=> '#8b3e2f',\n    cornflowerblue\t=> '#6495ed',\n    cornsilk\t\t=> '#fff8dc',\n    cornsilk1\t\t=> '#fff8dc',\n    cornsilk2\t\t=> '#eee8cd',\n    cornsilk3\t\t=> '#cdc8b1',\n    cornsilk4\t\t=> '#8b8878',\n    crimson\t\t=> '#dc143c',\n    cyan\t\t=> '#00ffff',\n    cyan1\t\t=> '#00ffff',\n    cyan2\t\t=> '#00eeee',\n    cyan3\t\t=> '#00cdcd',\n    cyan4\t\t=> '#008b8b',\n    darkgoldenrod\t=> '#b8860b',\n    darkgoldenrod1\t=> '#ffb90f',\n    darkgoldenrod2\t=> '#eead0e',\n    darkgoldenrod3\t=> '#cd950c',\n    darkgoldenrod4\t=> '#8b6508',\n    darkgreen\t\t=> '#006400',\n    darkkhaki\t\t=> '#bdb76b',\n    darkolivegreen\t=> '#556b2f',\n    darkolivegreen1\t=> '#caff70',\n    darkolivegreen2\t=> '#bcee68',\n    darkolivegreen3\t=> '#a2cd5a',\n    darkolivegreen4\t=> '#6e8b3d',\n    darkorange\t\t=> '#ff8c00',\n    darkorange1\t\t=> '#ff7f00',\n    darkorange2\t\t=> '#ee7600',\n    darkorange3\t\t=> '#cd6600',\n    darkorange4\t\t=> '#8b4500',\n    darkorchid\t\t=> '#9932cc',\n    darkorchid1\t\t=> '#bf3eff',\n    darkorchid2\t\t=> '#b23aee',\n    darkorchid3\t\t=> '#9a32cd',\n    darkorchid4\t\t=> '#68228b',\n    darksalmon\t\t=> '#e9967a',\n    darkseagreen\t=> '#8fbc8f',\n    darkseagreen1\t=> '#c1ffc1',\n    darkseagreen2\t=> '#b4eeb4',\n    darkseagreen3\t=> '#9bcd9b',\n    darkseagreen4\t=> '#698b69',\n    darkslateblue\t=> '#483d8b',\n    darkslategray\t=> '#2f4f4f',\n    darkslategray1\t=> '#97ffff',\n    darkslategray2\t=> '#8deeee',\n    darkslategray3\t=> '#79cdcd',\n    darkslategray4\t=> '#528b8b',\n    darkslategrey\t=> '#2f4f4f',\n    darkturquoise\t=> '#00ced1',\n    darkviolet\t\t=> '#9400d3',\n    deeppink\t\t=> '#ff1493',\n    deeppink1\t\t=> '#ff1493',\n    deeppink2\t\t=> '#ee1289',\n    deeppink3\t\t=> '#cd1076',\n    deeppink4\t\t=> '#8b0a50',\n    deepskyblue\t\t=> '#00bfff',\n    deepskyblue1\t=> '#00bfff',\n    deepskyblue2\t=> '#00b2ee',\n    deepskyblue3\t=> '#009acd',\n    deepskyblue4\t=> '#00688b',\n    dimgray\t\t=> '#696969',\n    dimgrey\t\t=> '#696969',\n    dodgerblue\t\t=> '#1e90ff',\n    dodgerblue1\t\t=> '#1e90ff',\n    dodgerblue2\t\t=> '#1c86ee',\n    dodgerblue3\t\t=> '#1874cd',\n    dodgerblue4\t\t=> '#104e8b',\n    firebrick\t\t=> '#b22222',\n    firebrick1\t\t=> '#ff3030',\n    firebrick2\t\t=> '#ee2c2c',\n    firebrick3\t\t=> '#cd2626',\n    firebrick4\t\t=> '#8b1a1a',\n    floralwhite\t\t=> '#fffaf0',\n    forestgreen\t\t=> '#228b22',\n    gainsboro\t\t=> '#dcdcdc',\n    ghostwhite\t\t=> '#f8f8ff',\n    gold\t\t=> '#ffd700',\n    gold1\t\t=> '#ffd700',\n    gold2\t\t=> '#eec900',\n    gold3\t\t=> '#cdad00',\n    gold4\t\t=> '#8b7500',\n    goldenrod\t\t=> '#daa520',\n    goldenrod1\t\t=> '#ffc125',\n    goldenrod2\t\t=> '#eeb422',\n    goldenrod3\t\t=> '#cd9b1d',\n    goldenrod4\t\t=> '#8b6914',\n    gray\t\t=> '#c0c0c0',\n    gray0\t\t=> '#000000',\n    gray1\t\t=> '#030303',\n    gray2\t\t=> '#050505',\n    gray3\t\t=> '#080808',\n    gray4\t\t=> '#0a0a0a',\n    gray5\t\t=> '#0d0d0d',\n    gray6\t\t=> '#0f0f0f',\n    gray7\t\t=> '#121212',\n    gray8\t\t=> '#141414',\n    gray9\t\t=> '#171717',\n    gray10\t\t=> '#1a1a1a',\n    gray11\t\t=> '#1c1c1c',\n    gray12\t\t=> '#1f1f1f',\n    gray13\t\t=> '#212121',\n    gray14\t\t=> '#242424',\n    gray15\t\t=> '#262626',\n    gray16\t\t=> '#292929',\n    gray17\t\t=> '#2b2b2b',\n    gray18\t\t=> '#2e2e2e',\n    gray19\t\t=> '#303030',\n    gray20\t\t=> '#333333',\n    gray21\t\t=> '#363636',\n    gray22\t\t=> '#383838',\n    gray23\t\t=> '#3b3b3b',\n    gray24\t\t=> '#3d3d3d',\n    gray25\t\t=> '#404040',\n    gray26\t\t=> '#424242',\n    gray27\t\t=> '#454545',\n    gray28\t\t=> '#474747',\n    gray29\t\t=> '#4a4a4a',\n    gray30\t\t=> '#4d4d4d',\n    gray31\t\t=> '#4f4f4f',\n    gray32\t\t=> '#525252',\n    gray33\t\t=> '#545454',\n    gray34\t\t=> '#575757',\n    gray35\t\t=> '#595959',\n    gray36\t\t=> '#5c5c5c',\n    gray37\t\t=> '#5e5e5e',\n    gray38\t\t=> '#616161',\n    gray39\t\t=> '#636363',\n    gray40\t\t=> '#666666',\n    gray41\t\t=> '#696969',\n    gray42\t\t=> '#6b6b6b',\n    gray43\t\t=> '#6e6e6e',\n    gray44\t\t=> '#707070',\n    gray45\t\t=> '#737373',\n    gray46\t\t=> '#757575',\n    gray47\t\t=> '#787878',\n    gray48\t\t=> '#7a7a7a',\n    gray49\t\t=> '#7d7d7d',\n    gray50\t\t=> '#7f7f7f',\n    gray51\t\t=> '#828282',\n    gray52\t\t=> '#858585',\n    gray53\t\t=> '#878787',\n    gray54\t\t=> '#8a8a8a',\n    gray55\t\t=> '#8c8c8c',\n    gray56\t\t=> '#8f8f8f',\n    gray57\t\t=> '#919191',\n    gray58\t\t=> '#949494',\n    gray59\t\t=> '#969696',\n    gray60\t\t=> '#999999',\n    gray61\t\t=> '#9c9c9c',\n    gray62\t\t=> '#9e9e9e',\n    gray63\t\t=> '#a1a1a1',\n    gray64\t\t=> '#a3a3a3',\n    gray65\t\t=> '#a6a6a6',\n    gray66\t\t=> '#a8a8a8',\n    gray67\t\t=> '#ababab',\n    gray68\t\t=> '#adadad',\n    gray69\t\t=> '#b0b0b0',\n    gray70\t\t=> '#b3b3b3',\n    gray71\t\t=> '#b5b5b5',\n    gray72\t\t=> '#b8b8b8',\n    gray73\t\t=> '#bababa',\n    gray74\t\t=> '#bdbdbd',\n    gray75\t\t=> '#bfbfbf',\n    gray76\t\t=> '#c2c2c2',\n    gray77\t\t=> '#c4c4c4',\n    gray78\t\t=> '#c7c7c7',\n    gray79\t\t=> '#c9c9c9',\n    gray80\t\t=> '#cccccc',\n    gray81\t\t=> '#cfcfcf',\n    gray82\t\t=> '#d1d1d1',\n    gray83\t\t=> '#d4d4d4',\n    gray84\t\t=> '#d6d6d6',\n    gray85\t\t=> '#d9d9d9',\n    gray86\t\t=> '#dbdbdb',\n    gray87\t\t=> '#dedede',\n    gray88\t\t=> '#e0e0e0',\n    gray89\t\t=> '#e3e3e3',\n    gray90\t\t=> '#e5e5e5',\n    gray91\t\t=> '#e8e8e8',\n    gray92\t\t=> '#ebebeb',\n    gray93\t\t=> '#ededed',\n    gray94\t\t=> '#f0f0f0',\n    gray95\t\t=> '#f2f2f2',\n    gray96\t\t=> '#f5f5f5',\n    gray97\t\t=> '#f7f7f7',\n    gray98\t\t=> '#fafafa',\n    gray99\t\t=> '#fcfcfc',\n    gray100\t\t=> '#ffffff',\n    green\t\t=> '#00ff00',\n    green1\t\t=> '#00ff00',\n    green2\t\t=> '#00ee00',\n    green3\t\t=> '#00cd00',\n    green4\t\t=> '#008b00',\n    greenyellow\t\t=> '#adff2f',\n    grey\t\t=> '#c0c0c0',\n    grey0\t\t=> '#000000',\n    grey1\t\t=> '#030303',\n    grey2\t\t=> '#050505',\n    grey3\t\t=> '#080808',\n    grey4\t\t=> '#0a0a0a',\n    grey5\t\t=> '#0d0d0d',\n    grey6\t\t=> '#0f0f0f',\n    grey7\t\t=> '#121212',\n    grey8\t\t=> '#141414',\n    grey9\t\t=> '#171717',\n    grey10\t\t=> '#1a1a1a',\n    grey11\t\t=> '#1c1c1c',\n    grey12\t\t=> '#1f1f1f',\n    grey13\t\t=> '#212121',\n    grey14\t\t=> '#242424',\n    grey15\t\t=> '#262626',\n    grey16\t\t=> '#292929',\n    grey17\t\t=> '#2b2b2b',\n    grey18\t\t=> '#2e2e2e',\n    grey19\t\t=> '#303030',\n    grey20\t\t=> '#333333',\n    grey21\t\t=> '#363636',\n    grey22\t\t=> '#383838',\n    grey23\t\t=> '#3b3b3b',\n    grey24\t\t=> '#3d3d3d',\n    grey25\t\t=> '#404040',\n    grey26\t\t=> '#424242',\n    grey27\t\t=> '#454545',\n    grey28\t\t=> '#474747',\n    grey29\t\t=> '#4a4a4a',\n    grey30\t\t=> '#4d4d4d',\n    grey31\t\t=> '#4f4f4f',\n    grey32\t\t=> '#525252',\n    grey33\t\t=> '#545454',\n    grey34\t\t=> '#575757',\n    grey35\t\t=> '#595959',\n    grey36\t\t=> '#5c5c5c',\n    grey37\t\t=> '#5e5e5e',\n    grey38\t\t=> '#616161',\n    grey39\t\t=> '#636363',\n    grey40\t\t=> '#666666',\n    grey41\t\t=> '#696969',\n    grey42\t\t=> '#6b6b6b',\n    grey43\t\t=> '#6e6e6e',\n    grey44\t\t=> '#707070',\n    grey45\t\t=> '#737373',\n    grey46\t\t=> '#757575',\n    grey47\t\t=> '#787878',\n    grey48\t\t=> '#7a7a7a',\n    grey49\t\t=> '#7d7d7d',\n    grey50\t\t=> '#7f7f7f',\n    grey51\t\t=> '#828282',\n    grey52\t\t=> '#858585',\n    grey53\t\t=> '#878787',\n    grey54\t\t=> '#8a8a8a',\n    grey55\t\t=> '#8c8c8c',\n    grey56\t\t=> '#8f8f8f',\n    grey57\t\t=> '#919191',\n    grey58\t\t=> '#949494',\n    grey59\t\t=> '#969696',\n    grey60\t\t=> '#999999',\n    grey61\t\t=> '#9c9c9c',\n    grey62\t\t=> '#9e9e9e',\n    grey63\t\t=> '#a1a1a1',\n    grey64\t\t=> '#a3a3a3',\n    grey65\t\t=> '#a6a6a6',\n    grey66\t\t=> '#a8a8a8',\n    grey67\t\t=> '#ababab',\n    grey68\t\t=> '#adadad',\n    grey69\t\t=> '#b0b0b0',\n    grey70\t\t=> '#b3b3b3',\n    grey71\t\t=> '#b5b5b5',\n    grey72\t\t=> '#b8b8b8',\n    grey73\t\t=> '#bababa',\n    grey74\t\t=> '#bdbdbd',\n    grey75\t\t=> '#bfbfbf',\n    grey76\t\t=> '#c2c2c2',\n    grey77\t\t=> '#c4c4c4',\n    grey78\t\t=> '#c7c7c7',\n    grey79\t\t=> '#c9c9c9',\n    grey80\t\t=> '#cccccc',\n    grey81\t\t=> '#cfcfcf',\n    grey82\t\t=> '#d1d1d1',\n    grey83\t\t=> '#d4d4d4',\n    grey84\t\t=> '#d6d6d6',\n    grey85\t\t=> '#d9d9d9',\n    grey86\t\t=> '#dbdbdb',\n    grey87\t\t=> '#dedede',\n    grey88\t\t=> '#e0e0e0',\n    grey89\t\t=> '#e3e3e3',\n    grey90\t\t=> '#e5e5e5',\n    grey91\t\t=> '#e8e8e8',\n    grey92\t\t=> '#ebebeb',\n    grey93\t\t=> '#ededed',\n    grey94\t\t=> '#f0f0f0',\n    grey95\t\t=> '#f2f2f2',\n    grey96\t\t=> '#f5f5f5',\n    grey97\t\t=> '#f7f7f7',\n    grey98\t\t=> '#fafafa',\n    grey99\t\t=> '#fcfcfc',\n    grey100\t\t=> '#ffffff',\n    honeydew\t\t=> '#f0fff0',\n    honeydew1\t\t=> '#f0fff0',\n    honeydew2\t\t=> '#e0eee0',\n    honeydew3\t\t=> '#c1cdc1',\n    honeydew4\t\t=> '#838b83',\n    hotpink\t\t=> '#ff69b4',\n    hotpink1\t\t=> '#ff6eb4',\n    hotpink2\t\t=> '#ee6aa7',\n    hotpink3\t\t=> '#cd6090',\n    hotpink4\t\t=> '#8b3a62',\n    indianred\t\t=> '#cd5c5c',\n    indianred1\t\t=> '#ff6a6a',\n    indianred2\t\t=> '#ee6363',\n    indianred3\t\t=> '#cd5555',\n    indianred4\t\t=> '#8b3a3a',\n    indigo\t\t=> '#4b0082',\n    ivory\t\t=> '#fffff0',\n    ivory1\t\t=> '#fffff0',\n    ivory2\t\t=> '#eeeee0',\n    ivory3\t\t=> '#cdcdc1',\n    ivory4\t\t=> '#8b8b83',\n    khaki\t\t=> '#f0e68c',\n    khaki1\t\t=> '#fff68f',\n    khaki2\t\t=> '#eee685',\n    khaki3\t\t=> '#cdc673',\n    khaki4\t\t=> '#8b864e',\n    lavender\t\t=> '#e6e6fa',\n    lavenderblush\t=> '#fff0f5',\n    lavenderblush1\t=> '#fff0f5',\n    lavenderblush2\t=> '#eee0e5',\n    lavenderblush3\t=> '#cdc1c5',\n    lavenderblush4\t=> '#8b8386',\n    lawngreen\t\t=> '#7cfc00',\n    lemonchiffon\t=> '#fffacd',\n    lemonchiffon1\t=> '#fffacd',\n    lemonchiffon2\t=> '#eee9bf',\n    lemonchiffon3\t=> '#cdc9a5',\n    lemonchiffon4\t=> '#8b8970',\n    lightblue\t\t=> '#add8e6',\n    lightblue1\t\t=> '#bfefff',\n    lightblue2\t\t=> '#b2dfee',\n    lightblue3\t\t=> '#9ac0cd',\n    lightblue4\t\t=> '#68838b',\n    lightcoral\t\t=> '#f08080',\n    lightcyan\t\t=> '#e0ffff',\n    lightcyan1\t\t=> '#e0ffff',\n    lightcyan2\t\t=> '#d1eeee',\n    lightcyan3\t\t=> '#b4cdcd',\n    lightcyan4\t\t=> '#7a8b8b',\n    lightgoldenrod\t=> '#eedd82',\n    lightgoldenrod1\t=> '#ffec8b',\n    lightgoldenrod2\t=> '#eedc82',\n    lightgoldenrod3\t=> '#cdbe70',\n    lightgoldenrod4\t=> '#8b814c',\n    lightgoldenrodyellow\t=> '#fafad2',\n    lightgray\t\t=> '#d3d3d3',\n    lightgrey\t\t=> '#d3d3d3',\n    lightpink\t\t=> '#ffb6c1',\n    lightpink1\t\t=> '#ffaeb9',\n    lightpink2\t\t=> '#eea2ad',\n    lightpink3\t\t=> '#cd8c95',\n    lightpink4\t\t=> '#8b5f65',\n    lightsalmon\t\t=> '#ffa07a',\n    lightsalmon1\t=> '#ffa07a',\n    lightsalmon2\t=> '#ee9572',\n    lightsalmon3\t=> '#cd8162',\n    lightsalmon4\t=> '#8b5742',\n    lightseagreen\t=> '#20b2aa',\n    lightskyblue\t=> '#87cefa',\n    lightskyblue1\t=> '#b0e2ff',\n    lightskyblue2\t=> '#a4d3ee',\n    lightskyblue3\t=> '#8db6cd',\n    lightskyblue4\t=> '#607b8b',\n    lightslateblue\t=> '#8470ff',\n    lightslategray\t=> '#778899',\n    lightslategrey\t=> '#778899',\n    lightsteelblue\t=> '#b0c4de',\n    lightsteelblue1\t=> '#cae1ff',\n    lightsteelblue2\t=> '#bcd2ee',\n    lightsteelblue3\t=> '#a2b5cd',\n    lightsteelblue4\t=> '#6e7b8b',\n    lightyellow\t\t=> '#ffffe0',\n    lightyellow1\t=> '#ffffe0',\n    lightyellow2\t=> '#eeeed1',\n    lightyellow3\t=> '#cdcdb4',\n    lightyellow4\t=> '#8b8b7a',\n    limegreen\t\t=> '#32cd32',\n    linen\t\t=> '#faf0e6',\n    magenta\t\t=> '#ff00ff',\n    magenta1\t\t=> '#ff00ff',\n    magenta2\t\t=> '#ee00ee',\n    magenta3\t\t=> '#cd00cd',\n    magenta4\t\t=> '#8b008b',\n    maroon\t\t=> '#b03060',\n    maroon1\t\t=> '#ff34b3',\n    maroon2\t\t=> '#ee30a7',\n    maroon3\t\t=> '#cd2990',\n    maroon4\t\t=> '#8b1c62',\n    mediumaquamarine\t=> '#66cdaa',\n    mediumblue\t\t=> '#0000cd',\n    mediumorchid\t=> '#ba55d3',\n    mediumorchid1\t=> '#e066ff',\n    mediumorchid2\t=> '#d15fee',\n    mediumorchid3\t=> '#b452cd',\n    mediumorchid4\t=> '#7a378b',\n    mediumpurple\t=> '#9370db',\n    mediumpurple1\t=> '#ab82ff',\n    mediumpurple2\t=> '#9f79ee',\n    mediumpurple3\t=> '#8968cd',\n    mediumpurple4\t=> '#5d478b',\n    mediumseagreen\t=> '#3cb371',\n    mediumslateblue\t=> '#7b68ee',\n    mediumspringgreen\t=> '#00fa9a',\n    mediumturquoise\t=> '#48d1cc',\n    mediumvioletred\t=> '#c71585',\n    midnightblue\t=> '#191970',\n    mintcream\t\t=> '#f5fffa',\n    mistyrose\t\t=> '#ffe4e1',\n    mistyrose1\t\t=> '#ffe4e1',\n    mistyrose2\t\t=> '#eed5d2',\n    mistyrose3\t\t=> '#cdb7b5',\n    mistyrose4\t\t=> '#8b7d7b',\n    moccasin\t\t=> '#ffe4b5',\n    navajowhite\t\t=> '#ffdead',\n    navajowhite1\t=> '#ffdead',\n    navajowhite2\t=> '#eecfa1',\n    navajowhite3\t=> '#cdb38b',\n    navajowhite4\t=> '#8b795e',\n    navy\t\t=> '#000080',\n    navyblue\t\t=> '#000080',\n    oldlace\t\t=> '#fdf5e6',\n    olivedrab\t\t=> '#6b8e23',\n    olivedrab1\t\t=> '#c0ff3e',\n    olivedrab2\t\t=> '#b3ee3a',\n    olivedrab3\t\t=> '#9acd32',\n    olivedrab4\t\t=> '#698b22',\n    orange\t\t=> '#ffa500',\n    orange1\t\t=> '#ffa500',\n    orange2\t\t=> '#ee9a00',\n    orange3\t\t=> '#cd8500',\n    orange4\t\t=> '#8b5a00',\n    orangered\t\t=> '#ff4500',\n    orangered1\t\t=> '#ff4500',\n    orangered2\t\t=> '#ee4000',\n    orangered3\t\t=> '#cd3700',\n    orangered4\t\t=> '#8b2500',\n    orchid\t\t=> '#da70d6',\n    orchid1\t\t=> '#ff83fa',\n    orchid2\t\t=> '#ee7ae9',\n    orchid3\t\t=> '#cd69c9',\n    orchid4\t\t=> '#8b4789',\n    palegoldenrod\t=> '#eee8aa',\n    palegreen\t\t=> '#98fb98',\n    palegreen1\t\t=> '#9aff9a',\n    palegreen2\t\t=> '#90ee90',\n    palegreen3\t\t=> '#7ccd7c',\n    palegreen4\t\t=> '#548b54',\n    paleturquoise\t=> '#afeeee',\n    paleturquoise1\t=> '#bbffff',\n    paleturquoise2\t=> '#aeeeee',\n    paleturquoise3\t=> '#96cdcd',\n    paleturquoise4\t=> '#668b8b',\n    palevioletred\t=> '#db7093',\n    palevioletred1\t=> '#ff82ab',\n    palevioletred2\t=> '#ee799f',\n    palevioletred3\t=> '#cd6889',\n    palevioletred4\t=> '#8b475d',\n    papayawhip\t\t=> '#ffefd5',\n    peachpuff\t\t=> '#ffdab9',\n    peachpuff1\t\t=> '#ffdab9',\n    peachpuff2\t\t=> '#eecbad',\n    peachpuff3\t\t=> '#cdaf95',\n    peachpuff4\t\t=> '#8b7765',\n    peru\t\t=> '#cd853f',\n    pink\t\t=> '#ffc0cb',\n    pink1\t\t=> '#ffb5c5',\n    pink2\t\t=> '#eea9b8',\n    pink3\t\t=> '#cd919e',\n    pink4\t\t=> '#8b636c',\n    plum\t\t=> '#dda0dd',\n    plum1\t\t=> '#ffbbff',\n    plum2\t\t=> '#eeaeee',\n    plum3\t\t=> '#cd96cd',\n    plum4\t\t=> '#8b668b',\n    powderblue\t\t=> '#b0e0e6',\n    purple\t\t=> '#a020f0',\n    purple1\t\t=> '#9b30ff',\n    purple2\t\t=> '#912cee',\n    purple3\t\t=> '#7d26cd',\n    purple4\t\t=> '#551a8b',\n    red \t\t=> '#ff0000',\n    red1\t\t=> '#ff0000',\n    red2\t\t=> '#ee0000',\n    red3\t\t=> '#cd0000',\n    red4\t\t=> '#8b0000',\n    rosybrown\t\t=> '#bc8f8f',\n    rosybrown1\t\t=> '#ffc1c1',\n    rosybrown2\t\t=> '#eeb4b4',\n    rosybrown3\t\t=> '#cd9b9b',\n    rosybrown4\t\t=> '#8b6969',\n    royalblue\t\t=> '#4169e1',\n    royalblue1\t\t=> '#4876ff',\n    royalblue2\t\t=> '#436eee',\n    royalblue3\t\t=> '#3a5fcd',\n    royalblue4\t\t=> '#27408b',\n    saddlebrown\t\t=> '#8b4513',\n    salmon\t\t=> '#fa8072',\n    salmon1\t\t=> '#ff8c69',\n    salmon2\t\t=> '#ee8262',\n    salmon3\t\t=> '#cd7054',\n    salmon4\t\t=> '#8b4c39',\n    sandybrown\t\t=> '#f4a460',\n    seagreen\t\t=> '#2e8b57',\n    seagreen1\t\t=> '#54ff9f',\n    seagreen2\t\t=> '#4eee94',\n    seagreen3\t\t=> '#43cd80',\n    seagreen4\t\t=> '#2e8b57',\n    seashell\t\t=> '#fff5ee',\n    seashell1\t\t=> '#fff5ee',\n    seashell2\t\t=> '#eee5de',\n    seashell3\t\t=> '#cdc5bf',\n    seashell4\t\t=> '#8b8682',\n    sienna\t\t=> '#a0522d',\n    sienna1\t\t=> '#ff8247',\n    sienna2\t\t=> '#ee7942',\n    sienna3\t\t=> '#cd6839',\n    sienna4\t\t=> '#8b4726',\n    skyblue\t\t=> '#87ceeb',\n    skyblue1\t\t=> '#87ceff',\n    skyblue2\t\t=> '#7ec0ee',\n    skyblue3\t\t=> '#6ca6cd',\n    skyblue4\t\t=> '#4a708b',\n    slateblue\t\t=> '#6a5acd',\n    slateblue1\t\t=> '#836fff',\n    slateblue2\t\t=> '#7a67ee',\n    slateblue3\t\t=> '#6959cd',\n    slateblue4\t\t=> '#473c8b',\n    slategray\t\t=> '#708090',\n    slategray1\t\t=> '#c6e2ff',\n    slategray2\t\t=> '#b9d3ee',\n    slategray3\t\t=> '#9fb6cd',\n    slategray4\t\t=> '#6c7b8b',\n    slategrey\t\t=> '#708090',\n    snow\t\t=> '#fffafa',\n    snow1\t\t=> '#fffafa',\n    snow2\t\t=> '#eee9e9',\n    snow3\t\t=> '#cdc9c9',\n    snow4\t\t=> '#8b8989',\n    springgreen\t\t=> '#00ff7f',\n    springgreen1\t=> '#00ff7f',\n    springgreen2\t=> '#00ee76',\n    springgreen3\t=> '#00cd66',\n    springgreen4\t=> '#008b45',\n    steelblue\t\t=> '#4682b4',\n    steelblue1\t\t=> '#63b8ff',\n    steelblue2\t\t=> '#5cacee',\n    steelblue3\t\t=> '#4f94cd',\n    steelblue4\t\t=> '#36648b',\n    tan \t\t=> '#d2b48c',\n    tan1\t\t=> '#ffa54f',\n    tan2\t\t=> '#ee9a49',\n    tan3\t\t=> '#cd853f',\n    tan4\t\t=> '#8b5a2b',\n    thistle\t\t=> '#d8bfd8',\n    thistle1\t\t=> '#ffe1ff',\n    thistle2\t\t=> '#eed2ee',\n    thistle3\t\t=> '#cdb5cd',\n    thistle4\t\t=> '#8b7b8b',\n    tomato\t\t=> '#ff6347',\n    tomato1\t\t=> '#ff6347',\n    tomato2\t\t=> '#ee5c42',\n    tomato3\t\t=> '#cd4f39',\n    tomato4\t\t=> '#8b3626',\n    transparent\t\t=> '#fffffe',\n    turquoise\t\t=> '#40e0d0',\n    turquoise1\t\t=> '#00f5ff',\n    turquoise2\t\t=> '#00e5ee',\n    turquoise3\t\t=> '#00c5cd',\n    turquoise4\t\t=> '#00868b',\n    violet\t\t=> '#ee82ee',\n    violetred\t\t=> '#d02090',\n    violetred1\t\t=> '#ff3e96',\n    violetred2\t\t=> '#ee3a8c',\n    violetred3\t\t=> '#cd3278',\n    violetred4\t\t=> '#8b2252',\n    wheat\t\t=> '#f5deb3',\n    wheat1\t\t=> '#ffe7ba',\n    wheat2\t\t=> '#eed8ae',\n    wheat3\t\t=> '#cdba96',\n    wheat4\t\t=> '#8b7e66',\n    white\t\t=> '#ffffff',\n    whitesmoke\t\t=> '#f5f5f5',\n    yellow\t\t=> '#ffff00',\n    yellow1\t\t=> '#ffff00',\n    yellow2\t\t=> '#eeee00',\n    yellow3\t\t=> '#cdcd00',\n    yellow4\t\t=> '#8b8b00',\n    yellowgreen\t\t=> '#9acd32',\n    # The following 12 colors exist here so that a \"color: 3; colorscheme: accent3\"\n    # will not report an \"unknown color 3\" from the Parser. As a side-effect\n    # you will not get an error for a plain \"color: 3\".\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', 8  => '#ff7f00', \n    9  => '#cab2d6', 10  => '#6a3d9a', 11  => '#ffff99', 12  => '#b15928', \n  },\n# The following color specifications were developed by:\n#  Cynthia Brewer (http://colorbrewer.org/)\n# See the LICENSE FILE for the full license that applies to them.\n\n  accent3 => {\n    1  => '#7fc97f', 2  => '#beaed4', 3  => '#fdc086', \n  },\n  accent4 => {\n    1  => '#7fc97f', 2  => '#beaed4', 3  => '#fdc086', 4  => '#ffff99', \n  },\n  accent5 => {\n    1  => '#7fc97f', 2  => '#beaed4', 3  => '#fdc086', 4  => '#ffff99', \n    5  => '#386cb0', \n  },\n  accent6 => {\n    1  => '#7fc97f', 2  => '#beaed4', 3  => '#fdc086', 4  => '#ffff99', \n    5  => '#386cb0', 6  => '#f0027f', \n  },\n  accent7 => {\n    1  => '#7fc97f', 2  => '#beaed4', 3  => '#fdc086', 4  => '#ffff99', \n    5  => '#386cb0', 6  => '#f0027f', 7  => '#bf5b17', \n  },\n  accent8 => {\n    1  => '#7fc97f', 2  => '#beaed4', 3  => '#fdc086', 4  => '#ffff99', \n    5  => '#386cb0', 6  => '#f0027f', 7  => '#bf5b17', 8  => '#666666', \n  },\n  blues3 => {\n    1  => '#deebf7', 2  => '#9ecae1', 3  => '#3182bd', \n  },\n  blues4 => {\n    1  => '#eff3ff', 2  => '#bdd7e7', 3  => '#6baed6', 4  => '#2171b5', \n  },\n  blues5 => {\n    1  => '#eff3ff', 2  => '#bdd7e7', 3  => '#6baed6', 4  => '#3182bd', \n    5  => '#08519c', \n  },\n  blues6 => {\n    1  => '#eff3ff', 2  => '#c6dbef', 3  => '#9ecae1', 4  => '#6baed6', \n    5  => '#3182bd', 6  => '#08519c', \n  },\n  blues7 => {\n    1  => '#eff3ff', 2  => '#c6dbef', 3  => '#9ecae1', 4  => '#6baed6', \n    5  => '#4292c6', 6  => '#2171b5', 7  => '#084594', \n  },\n  blues8 => {\n    1  => '#f7fbff', 2  => '#deebf7', 3  => '#c6dbef', 4  => '#9ecae1', \n    5  => '#6baed6', 6  => '#4292c6', 7  => '#2171b5', 8  => '#084594', \n  },\n  blues9 => {\n    1  => '#f7fbff', 2  => '#deebf7', 3  => '#c6dbef', 4  => '#9ecae1', \n    5  => '#6baed6', 6  => '#4292c6', 7  => '#2171b5', 8  => '#08519c', \n    9  => '#08306b', \n  },\n  brbg3 => {\n    1  => '#d8b365', 2  => '#f5f5f5', 3  => '#5ab4ac', \n  },\n  brbg4 => {\n    1  => '#a6611a', 2  => '#dfc27d', 3  => '#80cdc1', 4  => '#018571', \n  },\n  brbg5 => {\n    1  => '#a6611a', 2  => '#dfc27d', 3  => '#f5f5f5', 4  => '#80cdc1', \n    5  => '#018571', \n  },\n  brbg6 => {\n    1  => '#8c510a', 2  => '#d8b365', 3  => '#f6e8c3', 4  => '#c7eae5', \n    5  => '#5ab4ac', 6  => '#01665e', \n  },\n  brbg7 => {\n    1  => '#8c510a', 2  => '#d8b365', 3  => '#f6e8c3', 4  => '#f5f5f5', \n    5  => '#c7eae5', 6  => '#5ab4ac', 7  => '#01665e', \n  },\n  brbg8 => {\n    1  => '#8c510a', 2  => '#bf812d', 3  => '#dfc27d', 4  => '#f6e8c3', \n    5  => '#c7eae5', 6  => '#80cdc1', 7  => '#35978f', 8  => '#01665e', \n  },\n  brbg9 => {\n    1  => '#8c510a', 2  => '#bf812d', 3  => '#dfc27d', 4  => '#f6e8c3', \n    5  => '#f5f5f5', 6  => '#c7eae5', 7  => '#80cdc1', 8  => '#35978f', \n    9  => '#01665e', \n  },\n  brbg10 => {\n    1  => '#543005', 2  => '#8c510a', 3  => '#bf812d', 4  => '#dfc27d', \n    5  => '#f6e8c3', 6  => '#c7eae5', 7  => '#80cdc1', 8  => '#35978f', \n    9  => '#01665e', 10  => '#003c30', \n  },\n  brbg11 => {\n    1  => '#543005', 2  => '#8c510a', 3  => '#bf812d', 4  => '#dfc27d', \n    5  => '#f6e8c3', 6  => '#f5f5f5', 7  => '#c7eae5', 8  => '#80cdc1', \n    9  => '#35978f', 10  => '#01665e', 11  => '#003c30', \n  },\n  bugn3 => {\n    1  => '#e5f5f9', 2  => '#99d8c9', 3  => '#2ca25f', \n  },\n  bugn4 => {\n    1  => '#edf8fb', 2  => '#b2e2e2', 3  => '#66c2a4', 4  => '#238b45', \n  },\n  bugn5 => {\n    1  => '#edf8fb', 2  => '#b2e2e2', 3  => '#66c2a4', 4  => '#2ca25f', \n    5  => '#006d2c', \n  },\n  bugn6 => {\n    1  => '#edf8fb', 2  => '#ccece6', 3  => '#99d8c9', 4  => '#66c2a4', \n    5  => '#2ca25f', 6  => '#006d2c', \n  },\n  bugn7 => {\n    1  => '#edf8fb', 2  => '#ccece6', 3  => '#99d8c9', 4  => '#66c2a4', \n    5  => '#41ae76', 6  => '#238b45', 7  => '#005824', \n  },\n  bugn8 => {\n    1  => '#f7fcfd', 2  => '#e5f5f9', 3  => '#ccece6', 4  => '#99d8c9', \n    5  => '#66c2a4', 6  => '#41ae76', 7  => '#238b45', 8  => '#005824', \n  },\n  bugn9 => {\n    1  => '#f7fcfd', 2  => '#e5f5f9', 3  => '#ccece6', 4  => '#99d8c9', \n    5  => '#66c2a4', 6  => '#41ae76', 7  => '#238b45', 8  => '#006d2c', \n    9  => '#00441b', \n  },\n  bupu3 => {\n    1  => '#e0ecf4', 2  => '#9ebcda', 3  => '#8856a7', \n  },\n  bupu4 => {\n    1  => '#edf8fb', 2  => '#b3cde3', 3  => '#8c96c6', 4  => '#88419d', \n  },\n  bupu5 => {\n    1  => '#edf8fb', 2  => '#b3cde3', 3  => '#8c96c6', 4  => '#8856a7', \n    5  => '#810f7c', \n  },\n  bupu6 => {\n    1  => '#edf8fb', 2  => '#bfd3e6', 3  => '#9ebcda', 4  => '#8c96c6', \n    5  => '#8856a7', 6  => '#810f7c', \n  },\n  bupu7 => {\n    1  => '#edf8fb', 2  => '#bfd3e6', 3  => '#9ebcda', 4  => '#8c96c6', \n    5  => '#8c6bb1', 6  => '#88419d', 7  => '#6e016b', \n  },\n  bupu8 => {\n    1  => '#f7fcfd', 2  => '#e0ecf4', 3  => '#bfd3e6', 4  => '#9ebcda', \n    5  => '#8c96c6', 6  => '#8c6bb1', 7  => '#88419d', 8  => '#6e016b', \n  },\n  bupu9 => {\n    1  => '#f7fcfd', 2  => '#e0ecf4', 3  => '#bfd3e6', 4  => '#9ebcda', \n    5  => '#8c96c6', 6  => '#8c6bb1', 7  => '#88419d', 8  => '#810f7c', \n    9  => '#4d004b', \n  },\n  dark23 => {\n    1  => '#1b9e77', 2  => '#d95f02', 3  => '#7570b3', \n  },\n  dark24 => {\n    1  => '#1b9e77', 2  => '#d95f02', 3  => '#7570b3', 4  => '#e7298a', \n  },\n  dark25 => {\n    1  => '#1b9e77', 2  => '#d95f02', 3  => '#7570b3', 4  => '#e7298a', \n    5  => '#66a61e', \n  },\n  dark26 => {\n    1  => '#1b9e77', 2  => '#d95f02', 3  => '#7570b3', 4  => '#e7298a', \n    5  => '#66a61e', 6  => '#e6ab02', \n  },\n  dark27 => {\n    1  => '#1b9e77', 2  => '#d95f02', 3  => '#7570b3', 4  => '#e7298a', \n    5  => '#66a61e', 6  => '#e6ab02', 7  => '#a6761d', \n  },\n  dark28 => {\n    1  => '#1b9e77', 2  => '#d95f02', 3  => '#7570b3', 4  => '#e7298a', \n    5  => '#66a61e', 6  => '#e6ab02', 7  => '#a6761d', 8  => '#666666', \n  },\n  gnbu3 => {\n    1  => '#e0f3db', 2  => '#a8ddb5', 3  => '#43a2ca', \n  },\n  gnbu4 => {\n    1  => '#f0f9e8', 2  => '#bae4bc', 3  => '#7bccc4', 4  => '#2b8cbe', \n  },\n  gnbu5 => {\n    1  => '#f0f9e8', 2  => '#bae4bc', 3  => '#7bccc4', 4  => '#43a2ca', \n    5  => '#0868ac', \n  },\n  gnbu6 => {\n    1  => '#f0f9e8', 2  => '#ccebc5', 3  => '#a8ddb5', 4  => '#7bccc4', \n    5  => '#43a2ca', 6  => '#0868ac', \n  },\n  gnbu7 => {\n    1  => '#f0f9e8', 2  => '#ccebc5', 3  => '#a8ddb5', 4  => '#7bccc4', \n    5  => '#4eb3d3', 6  => '#2b8cbe', 7  => '#08589e', \n  },\n  gnbu8 => {\n    1  => '#f7fcf0', 2  => '#e0f3db', 3  => '#ccebc5', 4  => '#a8ddb5', \n    5  => '#7bccc4', 6  => '#4eb3d3', 7  => '#2b8cbe', 8  => '#08589e', \n  },\n  gnbu9 => {\n    1  => '#f7fcf0', 2  => '#e0f3db', 3  => '#ccebc5', 4  => '#a8ddb5', \n    5  => '#7bccc4', 6  => '#4eb3d3', 7  => '#2b8cbe', 8  => '#0868ac', \n    9  => '#084081', \n  },\n  greens3 => {\n    1  => '#e5f5e0', 2  => '#a1d99b', 3  => '#31a354', \n  },\n  greens4 => {\n    1  => '#edf8e9', 2  => '#bae4b3', 3  => '#74c476', 4  => '#238b45', \n  },\n  greens5 => {\n    1  => '#edf8e9', 2  => '#bae4b3', 3  => '#74c476', 4  => '#31a354', \n    5  => '#006d2c', \n  },\n  greens6 => {\n    1  => '#edf8e9', 2  => '#c7e9c0', 3  => '#a1d99b', 4  => '#74c476', \n    5  => '#31a354', 6  => '#006d2c', \n  },\n  greens7 => {\n    1  => '#edf8e9', 2  => '#c7e9c0', 3  => '#a1d99b', 4  => '#74c476', \n    5  => '#41ab5d', 6  => '#238b45', 7  => '#005a32', \n  },\n  greens8 => {\n    1  => '#f7fcf5', 2  => '#e5f5e0', 3  => '#c7e9c0', 4  => '#a1d99b', \n    5  => '#74c476', 6  => '#41ab5d', 7  => '#238b45', 8  => '#005a32', \n  },\n  greens9 => {\n    1  => '#f7fcf5', 2  => '#e5f5e0', 3  => '#c7e9c0', 4  => '#a1d99b', \n    5  => '#74c476', 6  => '#41ab5d', 7  => '#238b45', 8  => '#006d2c', \n    9  => '#00441b', \n  },\n  greys3 => {\n    1  => '#f0f0f0', 2  => '#bdbdbd', 3  => '#636363', \n  },\n  greys4 => {\n    1  => '#f7f7f7', 2  => '#cccccc', 3  => '#969696', 4  => '#525252', \n  },\n  greys5 => {\n    1  => '#f7f7f7', 2  => '#cccccc', 3  => '#969696', 4  => '#636363', \n    5  => '#252525', \n  },\n  greys6 => {\n    1  => '#f7f7f7', 2  => '#d9d9d9', 3  => '#bdbdbd', 4  => '#969696', \n    5  => '#636363', 6  => '#252525', \n  },\n  greys7 => {\n    1  => '#f7f7f7', 2  => '#d9d9d9', 3  => '#bdbdbd', 4  => '#969696', \n    5  => '#737373', 6  => '#525252', 7  => '#252525', \n  },\n  greys8 => {\n    1  => '#ffffff', 2  => '#f0f0f0', 3  => '#d9d9d9', 4  => '#bdbdbd', \n    5  => '#969696', 6  => '#737373', 7  => '#525252', 8  => '#252525', \n  },\n  greys9 => {\n    1  => '#ffffff', 2  => '#f0f0f0', 3  => '#d9d9d9', 4  => '#bdbdbd', \n    5  => '#969696', 6  => '#737373', 7  => '#525252', 8  => '#252525', \n    9  => '#000000', \n  },\n  oranges3 => {\n    1  => '#fee6ce', 2  => '#fdae6b', 3  => '#e6550d', \n  },\n  oranges4 => {\n    1  => '#feedde', 2  => '#fdbe85', 3  => '#fd8d3c', 4  => '#d94701', \n  },\n  oranges5 => {\n    1  => '#feedde', 2  => '#fdbe85', 3  => '#fd8d3c', 4  => '#e6550d', \n    5  => '#a63603', \n  },\n  oranges6 => {\n    1  => '#feedde', 2  => '#fdd0a2', 3  => '#fdae6b', 4  => '#fd8d3c', \n    5  => '#e6550d', 6  => '#a63603', \n  },\n  oranges7 => {\n    1  => '#feedde', 2  => '#fdd0a2', 3  => '#fdae6b', 4  => '#fd8d3c', \n    5  => '#f16913', 6  => '#d94801', 7  => '#8c2d04', \n  },\n  oranges8 => {\n    1  => '#fff5eb', 2  => '#fee6ce', 3  => '#fdd0a2', 4  => '#fdae6b', \n    5  => '#fd8d3c', 6  => '#f16913', 7  => '#d94801', 8  => '#8c2d04', \n  },\n  oranges9 => {\n    1  => '#fff5eb', 2  => '#fee6ce', 3  => '#fdd0a2', 4  => '#fdae6b', \n    5  => '#fd8d3c', 6  => '#f16913', 7  => '#d94801', 8  => '#a63603', \n    9  => '#7f2704', \n  },\n  orrd3 => {\n    1  => '#fee8c8', 2  => '#fdbb84', 3  => '#e34a33', \n  },\n  orrd4 => {\n    1  => '#fef0d9', 2  => '#fdcc8a', 3  => '#fc8d59', 4  => '#d7301f', \n  },\n  orrd5 => {\n    1  => '#fef0d9', 2  => '#fdcc8a', 3  => '#fc8d59', 4  => '#e34a33', \n    5  => '#b30000', \n  },\n  orrd6 => {\n    1  => '#fef0d9', 2  => '#fdd49e', 3  => '#fdbb84', 4  => '#fc8d59', \n    5  => '#e34a33', 6  => '#b30000', \n  },\n  orrd7 => {\n    1  => '#fef0d9', 2  => '#fdd49e', 3  => '#fdbb84', 4  => '#fc8d59', \n    5  => '#ef6548', 6  => '#d7301f', 7  => '#990000', \n  },\n  orrd8 => {\n    1  => '#fff7ec', 2  => '#fee8c8', 3  => '#fdd49e', 4  => '#fdbb84', \n    5  => '#fc8d59', 6  => '#ef6548', 7  => '#d7301f', 8  => '#990000', \n  },\n  orrd9 => {\n    1  => '#fff7ec', 2  => '#fee8c8', 3  => '#fdd49e', 4  => '#fdbb84', \n    5  => '#fc8d59', 6  => '#ef6548', 7  => '#d7301f', 8  => '#b30000', \n    9  => '#7f0000', \n  },\n  paired3 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', \n  },\n  paired4 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n  },\n  paired5 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', \n  },\n  paired6 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', \n  },\n  paired7 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', \n  },\n  paired8 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', 8  => '#ff7f00', \n  },\n  paired9 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', 8  => '#ff7f00', \n    9  => '#cab2d6', \n  },\n  paired10 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', 8  => '#ff7f00', \n    9  => '#cab2d6', 10  => '#6a3d9a', \n  },\n  paired11 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', 8  => '#ff7f00', \n    9  => '#cab2d6', 10  => '#6a3d9a', 11  => '#ffff99', \n  },\n  paired12 => {\n    1  => '#a6cee3', 2  => '#1f78b4', 3  => '#b2df8a', 4  => '#33a02c', \n    5  => '#fb9a99', 6  => '#e31a1c', 7  => '#fdbf6f', 8  => '#ff7f00', \n    9  => '#cab2d6', 10  => '#6a3d9a', 11  => '#ffff99', 12  => '#b15928', \n  },\n  pastel13 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', \n  },\n  pastel14 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', 4  => '#decbe4', \n  },\n  pastel15 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', 4  => '#decbe4', \n    5  => '#fed9a6', \n  },\n  pastel16 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', 4  => '#decbe4', \n    5  => '#fed9a6', 6  => '#ffffcc', \n  },\n  pastel17 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', 4  => '#decbe4', \n    5  => '#fed9a6', 6  => '#ffffcc', 7  => '#e5d8bd', \n  },\n  pastel18 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', 4  => '#decbe4', \n    5  => '#fed9a6', 6  => '#ffffcc', 7  => '#e5d8bd', 8  => '#fddaec', \n  },\n  pastel19 => {\n    1  => '#fbb4ae', 2  => '#b3cde3', 3  => '#ccebc5', 4  => '#decbe4', \n    5  => '#fed9a6', 6  => '#ffffcc', 7  => '#e5d8bd', 8  => '#fddaec', \n    9  => '#f2f2f2', \n  },\n  pastel23 => {\n    1  => '#b3e2cd', 2  => '#fdcdac', 3  => '#cbd5e8', \n  },\n  pastel24 => {\n    1  => '#b3e2cd', 2  => '#fdcdac', 3  => '#cbd5e8', 4  => '#f4cae4', \n  },\n  pastel25 => {\n    1  => '#b3e2cd', 2  => '#fdcdac', 3  => '#cbd5e8', 4  => '#f4cae4', \n    5  => '#e6f5c9', \n  },\n  pastel26 => {\n    1  => '#b3e2cd', 2  => '#fdcdac', 3  => '#cbd5e8', 4  => '#f4cae4', \n    5  => '#e6f5c9', 6  => '#fff2ae', \n  },\n  pastel27 => {\n    1  => '#b3e2cd', 2  => '#fdcdac', 3  => '#cbd5e8', 4  => '#f4cae4', \n    5  => '#e6f5c9', 6  => '#fff2ae', 7  => '#f1e2cc', \n  },\n  pastel28 => {\n    1  => '#b3e2cd', 2  => '#fdcdac', 3  => '#cbd5e8', 4  => '#f4cae4', \n    5  => '#e6f5c9', 6  => '#fff2ae', 7  => '#f1e2cc', 8  => '#cccccc', \n  },\n  piyg3 => {\n    1  => '#e9a3c9', 2  => '#f7f7f7', 3  => '#a1d76a', \n  },\n  piyg4 => {\n    1  => '#d01c8b', 2  => '#f1b6da', 3  => '#b8e186', 4  => '#4dac26', \n  },\n  piyg5 => {\n    1  => '#d01c8b', 2  => '#f1b6da', 3  => '#f7f7f7', 4  => '#b8e186', \n    5  => '#4dac26', \n  },\n  piyg6 => {\n    1  => '#c51b7d', 2  => '#e9a3c9', 3  => '#fde0ef', 4  => '#e6f5d0', \n    5  => '#a1d76a', 6  => '#4d9221', \n  },\n  piyg7 => {\n    1  => '#c51b7d', 2  => '#e9a3c9', 3  => '#fde0ef', 4  => '#f7f7f7', \n    5  => '#e6f5d0', 6  => '#a1d76a', 7  => '#4d9221', \n  },\n  piyg8 => {\n    1  => '#c51b7d', 2  => '#de77ae', 3  => '#f1b6da', 4  => '#fde0ef', \n    5  => '#e6f5d0', 6  => '#b8e186', 7  => '#7fbc41', 8  => '#4d9221', \n  },\n  piyg9 => {\n    1  => '#c51b7d', 2  => '#de77ae', 3  => '#f1b6da', 4  => '#fde0ef', \n    5  => '#f7f7f7', 6  => '#e6f5d0', 7  => '#b8e186', 8  => '#7fbc41', \n    9  => '#4d9221', \n  },\n  piyg10 => {\n    1  => '#8e0152', 2  => '#c51b7d', 3  => '#de77ae', 4  => '#f1b6da', \n    5  => '#fde0ef', 6  => '#e6f5d0', 7  => '#b8e186', 8  => '#7fbc41', \n    9  => '#4d9221', 10  => '#276419', \n  },\n  piyg11 => {\n    1  => '#8e0152', 2  => '#c51b7d', 3  => '#de77ae', 4  => '#f1b6da', \n    5  => '#fde0ef', 6  => '#f7f7f7', 7  => '#e6f5d0', 8  => '#b8e186', \n    9  => '#7fbc41', 10  => '#4d9221', 11  => '#276419', \n  },\n  prgn3 => {\n    1  => '#af8dc3', 2  => '#f7f7f7', 3  => '#7fbf7b', \n  },\n  prgn4 => {\n    1  => '#7b3294', 2  => '#c2a5cf', 3  => '#a6dba0', 4  => '#008837', \n  },\n  prgn5 => {\n    1  => '#7b3294', 2  => '#c2a5cf', 3  => '#f7f7f7', 4  => '#a6dba0', \n    5  => '#008837', \n  },\n  prgn6 => {\n    1  => '#762a83', 2  => '#af8dc3', 3  => '#e7d4e8', 4  => '#d9f0d3', \n    5  => '#7fbf7b', 6  => '#1b7837', \n  },\n  prgn7 => {\n    1  => '#762a83', 2  => '#af8dc3', 3  => '#e7d4e8', 4  => '#f7f7f7', \n    5  => '#d9f0d3', 6  => '#7fbf7b', 7  => '#1b7837', \n  },\n  prgn8 => {\n    1  => '#762a83', 2  => '#9970ab', 3  => '#c2a5cf', 4  => '#e7d4e8', \n    5  => '#d9f0d3', 6  => '#a6dba0', 7  => '#5aae61', 8  => '#1b7837', \n  },\n  prgn9 => {\n    1  => '#762a83', 2  => '#9970ab', 3  => '#c2a5cf', 4  => '#e7d4e8', \n    5  => '#f7f7f7', 6  => '#d9f0d3', 7  => '#a6dba0', 8  => '#5aae61', \n    9  => '#1b7837', \n  },\n  prgn10 => {\n    1  => '#40004b', 2  => '#762a83', 3  => '#9970ab', 4  => '#c2a5cf', \n    5  => '#e7d4e8', 6  => '#d9f0d3', 7  => '#a6dba0', 8  => '#5aae61', \n    9  => '#1b7837', 10  => '#00441b', \n  },\n  prgn11 => {\n    1  => '#40004b', 2  => '#762a83', 3  => '#9970ab', 4  => '#c2a5cf', \n    5  => '#e7d4e8', 6  => '#f7f7f7', 7  => '#d9f0d3', 8  => '#a6dba0', \n    9  => '#5aae61', 10  => '#1b7837', 11  => '#00441b', \n  },\n  pubu3 => {\n    1  => '#ece7f2', 2  => '#a6bddb', 3  => '#2b8cbe', \n  },\n  pubu4 => {\n    1  => '#f1eef6', 2  => '#bdc9e1', 3  => '#74a9cf', 4  => '#0570b0', \n  },\n  pubu5 => {\n    1  => '#f1eef6', 2  => '#bdc9e1', 3  => '#74a9cf', 4  => '#2b8cbe', \n    5  => '#045a8d', \n  },\n  pubu6 => {\n    1  => '#f1eef6', 2  => '#d0d1e6', 3  => '#a6bddb', 4  => '#74a9cf', \n    5  => '#2b8cbe', 6  => '#045a8d', \n  },\n  pubu7 => {\n    1  => '#f1eef6', 2  => '#d0d1e6', 3  => '#a6bddb', 4  => '#74a9cf', \n    5  => '#3690c0', 6  => '#0570b0', 7  => '#034e7b', \n  },\n  pubu8 => {\n    1  => '#fff7fb', 2  => '#ece7f2', 3  => '#d0d1e6', 4  => '#a6bddb', \n    5  => '#74a9cf', 6  => '#3690c0', 7  => '#0570b0', 8  => '#034e7b', \n  },\n  pubu9 => {\n    1  => '#fff7fb', 2  => '#ece7f2', 3  => '#d0d1e6', 4  => '#a6bddb', \n    5  => '#74a9cf', 6  => '#3690c0', 7  => '#0570b0', 8  => '#045a8d', \n    9  => '#023858', \n  },\n  pubugn3 => {\n    1  => '#ece2f0', 2  => '#a6bddb', 3  => '#1c9099', \n  },\n  pubugn4 => {\n    1  => '#f6eff7', 2  => '#bdc9e1', 3  => '#67a9cf', 4  => '#02818a', \n  },\n  pubugn5 => {\n    1  => '#f6eff7', 2  => '#bdc9e1', 3  => '#67a9cf', 4  => '#1c9099', \n    5  => '#016c59', \n  },\n  pubugn6 => {\n    1  => '#f6eff7', 2  => '#d0d1e6', 3  => '#a6bddb', 4  => '#67a9cf', \n    5  => '#1c9099', 6  => '#016c59', \n  },\n  pubugn7 => {\n    1  => '#f6eff7', 2  => '#d0d1e6', 3  => '#a6bddb', 4  => '#67a9cf', \n    5  => '#3690c0', 6  => '#02818a', 7  => '#016450', \n  },\n  pubugn8 => {\n    1  => '#fff7fb', 2  => '#ece2f0', 3  => '#d0d1e6', 4  => '#a6bddb', \n    5  => '#67a9cf', 6  => '#3690c0', 7  => '#02818a', 8  => '#016450', \n  },\n  pubugn9 => {\n    1  => '#fff7fb', 2  => '#ece2f0', 3  => '#d0d1e6', 4  => '#a6bddb', \n    5  => '#67a9cf', 6  => '#3690c0', 7  => '#02818a', 8  => '#016c59', \n    9  => '#014636', \n  },\n  puor3 => {\n    1  => '#f1a340', 2  => '#f7f7f7', 3  => '#998ec3', \n  },\n  puor4 => {\n    1  => '#e66101', 2  => '#fdb863', 3  => '#b2abd2', 4  => '#5e3c99', \n  },\n  puor5 => {\n    1  => '#e66101', 2  => '#fdb863', 3  => '#f7f7f7', 4  => '#b2abd2', \n    5  => '#5e3c99', \n  },\n  puor6 => {\n    1  => '#b35806', 2  => '#f1a340', 3  => '#fee0b6', 4  => '#d8daeb', \n    5  => '#998ec3', 6  => '#542788', \n  },\n  puor7 => {\n    1  => '#b35806', 2  => '#f1a340', 3  => '#fee0b6', 4  => '#f7f7f7', \n    5  => '#d8daeb', 6  => '#998ec3', 7  => '#542788', \n  },\n  puor8 => {\n    1  => '#b35806', 2  => '#e08214', 3  => '#fdb863', 4  => '#fee0b6', \n    5  => '#d8daeb', 6  => '#b2abd2', 7  => '#8073ac', 8  => '#542788', \n  },\n  puor9 => {\n    1  => '#b35806', 2  => '#e08214', 3  => '#fdb863', 4  => '#fee0b6', \n    5  => '#f7f7f7', 6  => '#d8daeb', 7  => '#b2abd2', 8  => '#8073ac', \n    9  => '#542788', \n  },\n  purd3 => {\n    1  => '#e7e1ef', 2  => '#c994c7', 3  => '#dd1c77', \n  },\n  purd4 => {\n    1  => '#f1eef6', 2  => '#d7b5d8', 3  => '#df65b0', 4  => '#ce1256', \n  },\n  purd5 => {\n    1  => '#f1eef6', 2  => '#d7b5d8', 3  => '#df65b0', 4  => '#dd1c77', \n    5  => '#980043', \n  },\n  purd6 => {\n    1  => '#f1eef6', 2  => '#d4b9da', 3  => '#c994c7', 4  => '#df65b0', \n    5  => '#dd1c77', 6  => '#980043', \n  },\n  purd7 => {\n    1  => '#f1eef6', 2  => '#d4b9da', 3  => '#c994c7', 4  => '#df65b0', \n    5  => '#e7298a', 6  => '#ce1256', 7  => '#91003f', \n  },\n  purd8 => {\n    1  => '#f7f4f9', 2  => '#e7e1ef', 3  => '#d4b9da', 4  => '#c994c7', \n    5  => '#df65b0', 6  => '#e7298a', 7  => '#ce1256', 8  => '#91003f', \n  },\n  purd9 => {\n    1  => '#f7f4f9', 2  => '#e7e1ef', 3  => '#d4b9da', 4  => '#c994c7', \n    5  => '#df65b0', 6  => '#e7298a', 7  => '#ce1256', 8  => '#980043', \n    9  => '#67001f', \n  },\n  puor10 => {\n    1  => '#7f3b08', 2  => '#b35806', 3  => '#e08214', 4  => '#fdb863', \n    5  => '#fee0b6', 6  => '#d8daeb', 7  => '#b2abd2', 8  => '#8073ac', \n    9  => '#542788', 10  => '#2d004b', \n  },\n  puor11 => {\n    1  => '#7f3b08', 2  => '#b35806', 3  => '#e08214', 4  => '#fdb863', \n    5  => '#fee0b6', 6  => '#f7f7f7', 7  => '#d8daeb', 8  => '#b2abd2', \n    9  => '#8073ac', 10  => '#542788', 11  => '#2d004b', \n  },\n  purples3 => {\n    1  => '#efedf5', 2  => '#bcbddc', 3  => '#756bb1', \n  },\n  purples4 => {\n    1  => '#f2f0f7', 2  => '#cbc9e2', 3  => '#9e9ac8', 4  => '#6a51a3', \n  },\n  purples5 => {\n    1  => '#f2f0f7', 2  => '#cbc9e2', 3  => '#9e9ac8', 4  => '#756bb1', \n    5  => '#54278f', \n  },\n  purples6 => {\n    1  => '#f2f0f7', 2  => '#dadaeb', 3  => '#bcbddc', 4  => '#9e9ac8', \n    5  => '#756bb1', 6  => '#54278f', \n  },\n  purples7 => {\n    1  => '#f2f0f7', 2  => '#dadaeb', 3  => '#bcbddc', 4  => '#9e9ac8', \n    5  => '#807dba', 6  => '#6a51a3', 7  => '#4a1486', \n  },\n  purples8 => {\n    1  => '#fcfbfd', 2  => '#efedf5', 3  => '#dadaeb', 4  => '#bcbddc', \n    5  => '#9e9ac8', 6  => '#807dba', 7  => '#6a51a3', 8  => '#4a1486', \n  },\n  purples9 => {\n    1  => '#fcfbfd', 2  => '#efedf5', 3  => '#dadaeb', 4  => '#bcbddc', \n    5  => '#9e9ac8', 6  => '#807dba', 7  => '#6a51a3', 8  => '#54278f', \n    9  => '#3f007d', \n  },\n  rdbu10 => {\n    1  => '#67001f', 2  => '#b2182b', 3  => '#d6604d', 4  => '#f4a582', \n    5  => '#fddbc7', 6  => '#d1e5f0', 7  => '#92c5de', 8  => '#4393c3', \n    9  => '#2166ac', 10  => '#053061', \n  },\n  rdbu11 => {\n    1  => '#67001f', 2  => '#b2182b', 3  => '#d6604d', 4  => '#f4a582', \n    5  => '#fddbc7', 6  => '#f7f7f7', 7  => '#d1e5f0', 8  => '#92c5de', \n    9  => '#4393c3', 10  => '#2166ac', 11  => '#053061', \n  },\n  rdbu3 => {\n    1  => '#ef8a62', 2  => '#f7f7f7', 3  => '#67a9cf', \n  },\n  rdbu4 => {\n    1  => '#ca0020', 2  => '#f4a582', 3  => '#92c5de', 4  => '#0571b0', \n  },\n  rdbu5 => {\n    1  => '#ca0020', 2  => '#f4a582', 3  => '#f7f7f7', 4  => '#92c5de', \n    5  => '#0571b0', \n  },\n  rdbu6 => {\n    1  => '#b2182b', 2  => '#ef8a62', 3  => '#fddbc7', 4  => '#d1e5f0', \n    5  => '#67a9cf', 6  => '#2166ac', \n  },\n  rdbu7 => {\n    1  => '#b2182b', 2  => '#ef8a62', 3  => '#fddbc7', 4  => '#f7f7f7', \n    5  => '#d1e5f0', 6  => '#67a9cf', 7  => '#2166ac', \n  },\n  rdbu8 => {\n    1  => '#b2182b', 2  => '#d6604d', 3  => '#f4a582', 4  => '#fddbc7', \n    5  => '#d1e5f0', 6  => '#92c5de', 7  => '#4393c3', 8  => '#2166ac', \n  },\n  rdbu9 => {\n    1  => '#b2182b', 2  => '#d6604d', 3  => '#f4a582', 4  => '#fddbc7', \n    5  => '#f7f7f7', 6  => '#d1e5f0', 7  => '#92c5de', 8  => '#4393c3', \n    9  => '#2166ac', \n  },\n  rdgy3 => {\n    1  => '#ef8a62', 2  => '#ffffff', 3  => '#999999', \n  },\n  rdgy4 => {\n    1  => '#ca0020', 2  => '#f4a582', 3  => '#bababa', 4  => '#404040', \n  },\n  rdgy5 => {\n    1  => '#ca0020', 2  => '#f4a582', 3  => '#ffffff', 4  => '#bababa', \n    5  => '#404040', \n  },\n  rdgy6 => {\n    1  => '#b2182b', 2  => '#ef8a62', 3  => '#fddbc7', 4  => '#e0e0e0', \n    5  => '#999999', 6  => '#4d4d4d', \n  },\n  rdgy7 => {\n    1  => '#b2182b', 2  => '#ef8a62', 3  => '#fddbc7', 4  => '#ffffff', \n    5  => '#e0e0e0', 6  => '#999999', 7  => '#4d4d4d', \n  },\n  rdgy8 => {\n    1  => '#b2182b', 2  => '#d6604d', 3  => '#f4a582', 4  => '#fddbc7', \n    5  => '#e0e0e0', 6  => '#bababa', 7  => '#878787', 8  => '#4d4d4d', \n  },\n  rdgy9 => {\n    1  => '#b2182b', 2  => '#d6604d', 3  => '#f4a582', 4  => '#fddbc7', \n    5  => '#ffffff', 6  => '#e0e0e0', 7  => '#bababa', 8  => '#878787', \n    9  => '#4d4d4d', \n  },\n  rdpu3 => {\n    1  => '#fde0dd', 2  => '#fa9fb5', 3  => '#c51b8a', \n  },\n  rdpu4 => {\n    1  => '#feebe2', 2  => '#fbb4b9', 3  => '#f768a1', 4  => '#ae017e', \n  },\n  rdpu5 => {\n    1  => '#feebe2', 2  => '#fbb4b9', 3  => '#f768a1', 4  => '#c51b8a', \n    5  => '#7a0177', \n  },\n  rdpu6 => {\n    1  => '#feebe2', 2  => '#fcc5c0', 3  => '#fa9fb5', 4  => '#f768a1', \n    5  => '#c51b8a', 6  => '#7a0177', \n  },\n  rdpu7 => {\n    1  => '#feebe2', 2  => '#fcc5c0', 3  => '#fa9fb5', 4  => '#f768a1', \n    5  => '#dd3497', 6  => '#ae017e', 7  => '#7a0177', \n  },\n  rdpu8 => {\n    1  => '#fff7f3', 2  => '#fde0dd', 3  => '#fcc5c0', 4  => '#fa9fb5', \n    5  => '#f768a1', 6  => '#dd3497', 7  => '#ae017e', 8  => '#7a0177', \n  },\n  rdpu9 => {\n    1  => '#fff7f3', 2  => '#fde0dd', 3  => '#fcc5c0', 4  => '#fa9fb5', \n    5  => '#f768a1', 6  => '#dd3497', 7  => '#ae017e', 8  => '#7a0177', \n    9  => '#49006a', \n  },\n  rdgy10 => {\n    1  => '#67001f', 2  => '#b2182b', 3  => '#d6604d', 4  => '#f4a582', \n    5  => '#fddbc7', 6  => '#e0e0e0', 7  => '#bababa', 8  => '#878787', \n    9  => '#4d4d4d', 10  => '#1a1a1a', \n  },\n  rdgy11 => {\n    1  => '#67001f', 2  => '#b2182b', 3  => '#d6604d', 4  => '#f4a582', \n    5  => '#fddbc7', 6  => '#ffffff', 7  => '#e0e0e0', 8  => '#bababa', \n    9  => '#878787', 10  => '#4d4d4d', 11  => '#1a1a1a', \n  },\n  rdylbu3 => {\n    1  => '#fc8d59', 2  => '#ffffbf', 3  => '#91bfdb', \n  },\n  rdylbu4 => {\n    1  => '#d7191c', 2  => '#fdae61', 3  => '#abd9e9', 4  => '#2c7bb6', \n  },\n  rdylbu5 => {\n    1  => '#d7191c', 2  => '#fdae61', 3  => '#ffffbf', 4  => '#abd9e9', \n    5  => '#2c7bb6', \n  },\n  rdylbu6 => {\n    1  => '#d73027', 2  => '#fc8d59', 3  => '#fee090', 4  => '#e0f3f8', \n    5  => '#91bfdb', 6  => '#4575b4', \n  },\n  rdylbu7 => {\n    1  => '#d73027', 2  => '#fc8d59', 3  => '#fee090', 4  => '#ffffbf', \n    5  => '#e0f3f8', 6  => '#91bfdb', 7  => '#4575b4', \n  },\n  rdylbu8 => {\n    1  => '#d73027', 2  => '#f46d43', 3  => '#fdae61', 4  => '#fee090', \n    5  => '#e0f3f8', 6  => '#abd9e9', 7  => '#74add1', 8  => '#4575b4', \n  },\n  rdylbu9 => {\n    1  => '#d73027', 2  => '#f46d43', 3  => '#fdae61', 4  => '#fee090', \n    5  => '#ffffbf', 6  => '#e0f3f8', 7  => '#abd9e9', 8  => '#74add1', \n    9  => '#4575b4', \n  },\n  rdylbu10 => {\n    1  => '#a50026', 2  => '#d73027', 3  => '#f46d43', 4  => '#fdae61', \n    5  => '#fee090', 6  => '#e0f3f8', 7  => '#abd9e9', 8  => '#74add1', \n    9  => '#4575b4', 10  => '#313695', \n  },\n  rdylbu11 => {\n    1  => '#a50026', 2  => '#d73027', 3  => '#f46d43', 4  => '#fdae61', \n    5  => '#fee090', 6  => '#ffffbf', 7  => '#e0f3f8', 8  => '#abd9e9', \n    9  => '#74add1', 10  => '#4575b4', 11  => '#313695', \n  },\n  rdylgn3 => {\n    1  => '#fc8d59', 2  => '#ffffbf', 3  => '#91cf60', \n  },\n  rdylgn4 => {\n    1  => '#d7191c', 2  => '#fdae61', 3  => '#a6d96a', 4  => '#1a9641', \n  },\n  rdylgn5 => {\n    1  => '#d7191c', 2  => '#fdae61', 3  => '#ffffbf', 4  => '#a6d96a', \n    5  => '#1a9641', \n  },\n  rdylgn6 => {\n    1  => '#d73027', 2  => '#fc8d59', 3  => '#fee08b', 4  => '#d9ef8b', \n    5  => '#91cf60', 6  => '#1a9850', \n  },\n  rdylgn7 => {\n    1  => '#d73027', 2  => '#fc8d59', 3  => '#fee08b', 4  => '#ffffbf', \n    5  => '#d9ef8b', 6  => '#91cf60', 7  => '#1a9850', \n  },\n  rdylgn8 => {\n    1  => '#d73027', 2  => '#f46d43', 3  => '#fdae61', 4  => '#fee08b', \n    5  => '#d9ef8b', 6  => '#a6d96a', 7  => '#66bd63', 8  => '#1a9850', \n  },\n  rdylgn9 => {\n    1  => '#d73027', 2  => '#f46d43', 3  => '#fdae61', 4  => '#fee08b', \n    5  => '#ffffbf', 6  => '#d9ef8b', 7  => '#a6d96a', 8  => '#66bd63', \n    9  => '#1a9850', \n  },\n  rdylgn10 => {\n    1  => '#a50026', 2  => '#d73027', 3  => '#f46d43', 4  => '#fdae61', \n    5  => '#fee08b', 6  => '#d9ef8b', 7  => '#a6d96a', 8  => '#66bd63', \n    9  => '#1a9850', 10  => '#006837', \n  },\n  rdylgn11 => {\n    1  => '#a50026', 2  => '#d73027', 3  => '#f46d43', 4  => '#fdae61', \n    5  => '#fee08b', 6  => '#ffffbf', 7  => '#d9ef8b', 8  => '#a6d96a', \n    9  => '#66bd63', 10  => '#1a9850', 11  => '#006837', \n  },\n  reds3 => {\n    1  => '#fee0d2', 2  => '#fc9272', 3  => '#de2d26', \n  },\n  reds4 => {\n    1  => '#fee5d9', 2  => '#fcae91', 3  => '#fb6a4a', 4  => '#cb181d', \n  },\n  reds5 => {\n    1  => '#fee5d9', 2  => '#fcae91', 3  => '#fb6a4a', 4  => '#de2d26', \n    5  => '#a50f15', \n  },\n  reds6 => {\n    1  => '#fee5d9', 2  => '#fcbba1', 3  => '#fc9272', 4  => '#fb6a4a', \n    5  => '#de2d26', 6  => '#a50f15', \n  },\n  reds7 => {\n    1  => '#fee5d9', 2  => '#fcbba1', 3  => '#fc9272', 4  => '#fb6a4a', \n    5  => '#ef3b2c', 6  => '#cb181d', 7  => '#99000d', \n  },\n  reds8 => {\n    1  => '#fff5f0', 2  => '#fee0d2', 3  => '#fcbba1', 4  => '#fc9272', \n    5  => '#fb6a4a', 6  => '#ef3b2c', 7  => '#cb181d', 8  => '#99000d', \n  },\n  reds9 => {\n    1  => '#fff5f0', 2  => '#fee0d2', 3  => '#fcbba1', 4  => '#fc9272', \n    5  => '#fb6a4a', 6  => '#ef3b2c', 7  => '#cb181d', 8  => '#a50f15', \n    9  => '#67000d', \n  },\n  set13 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', \n  },\n  set14 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', 4  => '#984ea3', \n  },\n  set15 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', 4  => '#984ea3', \n    5  => '#ff7f00', \n  },\n  set16 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', 4  => '#984ea3', \n    5  => '#ff7f00', 6  => '#ffff33', \n  },\n  set17 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', 4  => '#984ea3', \n    5  => '#ff7f00', 6  => '#ffff33', 7  => '#a65628', \n  },\n  set18 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', 4  => '#984ea3', \n    5  => '#ff7f00', 6  => '#ffff33', 7  => '#a65628', 8  => '#f781bf', \n  },\n  set19 => {\n    1  => '#e41a1c', 2  => '#377eb8', 3  => '#4daf4a', 4  => '#984ea3', \n    5  => '#ff7f00', 6  => '#ffff33', 7  => '#a65628', 8  => '#f781bf', \n    9  => '#999999', \n  },\n  set23 => {\n    1  => '#66c2a5', 2  => '#fc8d62', 3  => '#8da0cb', \n  },\n  set24 => {\n    1  => '#66c2a5', 2  => '#fc8d62', 3  => '#8da0cb', 4  => '#e78ac3', \n  },\n  set25 => {\n    1  => '#66c2a5', 2  => '#fc8d62', 3  => '#8da0cb', 4  => '#e78ac3', \n    5  => '#a6d854', \n  },\n  set26 => {\n    1  => '#66c2a5', 2  => '#fc8d62', 3  => '#8da0cb', 4  => '#e78ac3', \n    5  => '#a6d854', 6  => '#ffd92f', \n  },\n  set27 => {\n    1  => '#66c2a5', 2  => '#fc8d62', 3  => '#8da0cb', 4  => '#e78ac3', \n    5  => '#a6d854', 6  => '#ffd92f', 7  => '#e5c494', \n  },\n  set28 => {\n    1  => '#66c2a5', 2  => '#fc8d62', 3  => '#8da0cb', 4  => '#e78ac3', \n    5  => '#a6d854', 6  => '#ffd92f', 7  => '#e5c494', 8  => '#b3b3b3', \n  },\n  set33 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', \n  },\n  set34 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n  },\n  set35 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', \n  },\n  set36 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', \n  },\n  set37 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', 7  => '#b3de69', \n  },\n  set38 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', 7  => '#b3de69', 8  => '#fccde5', \n  },\n  set39 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', 7  => '#b3de69', 8  => '#fccde5', \n    9  => '#d9d9d9', \n  },\n  set310 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', 7  => '#b3de69', 8  => '#fccde5', \n    9  => '#d9d9d9', 10  => '#bc80bd', \n  },\n  set311 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', 7  => '#b3de69', 8  => '#fccde5', \n    9  => '#d9d9d9', 10  => '#bc80bd', 11  => '#ccebc5', \n  },\n  set312 => {\n    1  => '#8dd3c7', 2  => '#ffffb3', 3  => '#bebada', 4  => '#fb8072', \n    5  => '#80b1d3', 6  => '#fdb462', 7  => '#b3de69', 8  => '#fccde5', \n    9  => '#d9d9d9', 10  => '#bc80bd', 11  => '#ccebc5', 12  => '#ffed6f', \n  },\n  spectral3 => {\n    1  => '#fc8d59', 2  => '#ffffbf', 3  => '#99d594', \n  },\n  spectral4 => {\n    1  => '#d7191c', 2  => '#fdae61', 3  => '#abdda4', 4  => '#2b83ba', \n  },\n  spectral5 => {\n    1  => '#d7191c', 2  => '#fdae61', 3  => '#ffffbf', 4  => '#abdda4', \n    5  => '#2b83ba', \n  },\n  spectral6 => {\n    1  => '#d53e4f', 2  => '#fc8d59', 3  => '#fee08b', 4  => '#e6f598', \n    5  => '#99d594', 6  => '#3288bd', \n  },\n  spectral7 => {\n    1  => '#d53e4f', 2  => '#fc8d59', 3  => '#fee08b', 4  => '#ffffbf', \n    5  => '#e6f598', 6  => '#99d594', 7  => '#3288bd', \n  },\n  spectral8 => {\n    1  => '#d53e4f', 2  => '#f46d43', 3  => '#fdae61', 4  => '#fee08b', \n    5  => '#e6f598', 6  => '#abdda4', 7  => '#66c2a5', 8  => '#3288bd', \n  },\n  spectral9 => {\n    1  => '#d53e4f', 2  => '#f46d43', 3  => '#fdae61', 4  => '#fee08b', \n    5  => '#ffffbf', 6  => '#e6f598', 7  => '#abdda4', 8  => '#66c2a5', \n    9  => '#3288bd', \n  },\n  spectral10 => {\n    1  => '#9e0142', 2  => '#d53e4f', 3  => '#f46d43', 4  => '#fdae61', \n    5  => '#fee08b', 6  => '#e6f598', 7  => '#abdda4', 8  => '#66c2a5', \n    9  => '#3288bd', 10  => '#5e4fa2', \n  },\n  spectral11 => {\n    1  => '#9e0142', 2  => '#d53e4f', 3  => '#f46d43', 4  => '#fdae61', \n    5  => '#fee08b', 6  => '#ffffbf', 7  => '#e6f598', 8  => '#abdda4', \n    9  => '#66c2a5', 10  => '#3288bd', 11  => '#5e4fa2', \n  },\n  ylgn3 => {\n    1  => '#f7fcb9', 2  => '#addd8e', 3  => '#31a354', \n  },\n  ylgn4 => {\n    1  => '#ffffcc', 2  => '#c2e699', 3  => '#78c679', 4  => '#238443', \n  },\n  ylgn5 => {\n    1  => '#ffffcc', 2  => '#c2e699', 3  => '#78c679', 4  => '#31a354', \n    5  => '#006837', \n  },\n  ylgn6 => {\n    1  => '#ffffcc', 2  => '#d9f0a3', 3  => '#addd8e', 4  => '#78c679', \n    5  => '#31a354', 6  => '#006837', \n  },\n  ylgn7 => {\n    1  => '#ffffcc', 2  => '#d9f0a3', 3  => '#addd8e', 4  => '#78c679', \n    5  => '#41ab5d', 6  => '#238443', 7  => '#005a32', \n  },\n  ylgn8 => {\n    1  => '#ffffe5', 2  => '#f7fcb9', 3  => '#d9f0a3', 4  => '#addd8e', \n    5  => '#78c679', 6  => '#41ab5d', 7  => '#238443', 8  => '#005a32', \n  },\n  ylgn9 => {\n    1  => '#ffffe5', 2  => '#f7fcb9', 3  => '#d9f0a3', 4  => '#addd8e', \n    5  => '#78c679', 6  => '#41ab5d', 7  => '#238443', 8  => '#006837', \n    9  => '#004529', \n  },\n  ylgnbu3 => {\n    1  => '#edf8b1', 2  => '#7fcdbb', 3  => '#2c7fb8', \n  },\n  ylgnbu4 => {\n    1  => '#ffffcc', 2  => '#a1dab4', 3  => '#41b6c4', 4  => '#225ea8', \n  },\n  ylgnbu5 => {\n    1  => '#ffffcc', 2  => '#a1dab4', 3  => '#41b6c4', 4  => '#2c7fb8', \n    5  => '#253494', \n  },\n  ylgnbu6 => {\n    1  => '#ffffcc', 2  => '#c7e9b4', 3  => '#7fcdbb', 4  => '#41b6c4', \n    5  => '#2c7fb8', 6  => '#253494', \n  },\n  ylgnbu7 => {\n    1  => '#ffffcc', 2  => '#c7e9b4', 3  => '#7fcdbb', 4  => '#41b6c4', \n    5  => '#1d91c0', 6  => '#225ea8', 7  => '#0c2c84', \n  },\n  ylgnbu8 => {\n    1  => '#ffffd9', 2  => '#edf8b1', 3  => '#c7e9b4', 4  => '#7fcdbb', \n    5  => '#41b6c4', 6  => '#1d91c0', 7  => '#225ea8', 8  => '#0c2c84', \n  },\n  ylgnbu9 => {\n    1  => '#ffffd9', 2  => '#edf8b1', 3  => '#c7e9b4', 4  => '#7fcdbb', \n    5  => '#41b6c4', 6  => '#1d91c0', 7  => '#225ea8', 8  => '#253494', \n    9  => '#081d58', \n  },\n  ylorbr3 => {\n    1  => '#fff7bc', 2  => '#fec44f', 3  => '#d95f0e', \n  },\n  ylorbr4 => {\n    1  => '#ffffd4', 2  => '#fed98e', 3  => '#fe9929', 4  => '#cc4c02', \n  },\n  ylorbr5 => {\n    1  => '#ffffd4', 2  => '#fed98e', 3  => '#fe9929', 4  => '#d95f0e', \n    5  => '#993404', \n  },\n  ylorbr6 => {\n    1  => '#ffffd4', 2  => '#fee391', 3  => '#fec44f', 4  => '#fe9929', \n    5  => '#d95f0e', 6  => '#993404', \n  },\n  ylorbr7 => {\n    1  => '#ffffd4', 2  => '#fee391', 3  => '#fec44f', 4  => '#fe9929', \n    5  => '#ec7014', 6  => '#cc4c02', 7  => '#8c2d04', \n  },\n  ylorbr8 => {\n    1  => '#ffffe5', 2  => '#fff7bc', 3  => '#fee391', 4  => '#fec44f', \n    5  => '#fe9929', 6  => '#ec7014', 7  => '#cc4c02', 8  => '#8c2d04', \n  },\n  ylorbr9 => {\n    1  => '#ffffe5', 2  => '#fff7bc', 3  => '#fee391', 4  => '#fec44f', \n    5  => '#fe9929', 6  => '#ec7014', 7  => '#cc4c02', 8  => '#993404', \n    9  => '#662506', \n  },\n  ylorrd3 => {\n    1  => '#ffeda0', 2  => '#feb24c', 3  => '#f03b20', \n  },\n  ylorrd4 => {\n    1  => '#ffffb2', 2  => '#fecc5c', 3  => '#fd8d3c', 4  => '#e31a1c', \n  },\n  ylorrd5 => {\n    1  => '#ffffb2', 2  => '#fecc5c', 3  => '#fd8d3c', 4  => '#f03b20', \n    5  => '#bd0026', \n  },\n  ylorrd6 => {\n    1  => '#ffffb2', 2  => '#fed976', 3  => '#feb24c', 4  => '#fd8d3c', \n    5  => '#f03b20', 6  => '#bd0026', \n  },\n  ylorrd7 => {\n    1  => '#ffffb2', 2  => '#fed976', 3  => '#feb24c', 4  => '#fd8d3c', \n    5  => '#fc4e2a', 6  => '#e31a1c', 7  => '#b10026', \n  },\n  ylorrd8 => {\n    1  => '#ffffcc', 2  => '#ffeda0', 3  => '#fed976', 4  => '#feb24c', \n    5  => '#fd8d3c', 6  => '#fc4e2a', 7  => '#e31a1c', 8  => '#b10026', \n  },\n  ylorrd9 => {\n    1  => '#ffffcc', 2  => '#ffeda0', 3  => '#fed976', 4  => '#feb24c', \n    5  => '#fd8d3c', 6  => '#fc4e2a', 7  => '#e31a1c', 8  => '#bd0026', \n    9  => '#800026', \n  },\n  };\n\n# reverse mapping value => name\nmy $color_values = { };\nmy $all_color_names = { };\n\n{\n  # reverse mapping \"#ff0000 => 'red'\"\n  # also build a list of all possible color names\n  for my $n (keys %$color_names)\n    {\n    my $s = $color_names->{$n};\n    $color_values->{ $n } = {};\n    my $t = $color_values->{$n};\n    # sort the names on their length\n    for my $c (sort { length($a) <=> length($b) || $a cmp $b } keys %$s)\n      {\n      # don't add \"blue1\" if it is already set as \"blue\"\n      $t->{ $s->{$c} } = $c unless exists $t->{ $s->{$c} };\n      # mark as existing\n      $all_color_names->{ $c } = undef;\n      }\n    }\n}\n\nour $qr_custom_attribute = qr/^x-([a-z_0-9]+-)*[a-z_0-9]+\\z/;\n\nsub color_names\n  {\n  $color_names;\n  }\n\nsub color_name\n  {\n  # return \"red\" for \"#ff0000\"\n  my ($self,$color,$scheme) = @_;\n\n  $scheme ||= 'w3c';\n  $color_values->{$scheme}->{$color} || $color;\n  }\n\nsub color_value\n  {\n  # return \"#ff0000\" for \"red\"\n  my ($self,$color,$scheme) = @_;\n\n  $scheme ||= 'w3c';\n\n  # 'w3c/red' => 'w3c', 'red'\n  $scheme = $1 if $color =~ s/^([a-z0-9])\\///;\n\n  $color_names->{$scheme}->{$color} || $color;\n  }\n\nsub _color_scheme\n  {\n  # check that a given color scheme is valid\n  my ($self, $scheme) = @_;\n\n  return $scheme if $scheme eq 'inherit';\n  exists $color_names->{ $scheme } ? $scheme : undef;\n  }\n\nsub _color\n  {\n  # Check that a given color name (like 'red'), or value (like '#ff0000')\n  # or rgb(1,2,3) is valid. Used by valid_attribute().\n\n  # Note that for color names, the color scheme is not known here, so we\n  # can only look if the color name is potentially possible. F.i. under\n  # the Brewer scheme ylorrd9, '1' is a valid color name, while 'red'\n  # would not. To resolve such conflicts, we will fallback to 'x11'\n  # (the largest of the schemes) if the color name doesn't exist in\n  # the current scheme.\n  my ($self, $org_color) = @_;\n\n  $org_color = lc($org_color);\t\t# color names are case insensitive\n  $org_color =~ s/\\s//g;\t\t# remove spaces to unify format\n  my $color = $org_color;\n\n  if ($color =~ s/^(w3c|[a-z]+\\d{0,2})\\///)\n    {\n    my $scheme = $1;\n    return $org_color if exists $color_names->{$scheme}->{$color};\n    # if it didn't work, then fall back to x11\n    $scheme = 'x11';\n    return (exists $color_names->{$scheme}->{$color} ? $org_color : undef);\n    }\n\n  # scheme unknown, fall back to generic handling\n\n  # red => red\n  return $org_color if exists $all_color_names->{$color};\n\n  # #ff0000 => #ff0000, rgb(1,2,3) => rgb(1,2,3)\n  defined $self->color_as_hex($color) ? $org_color : undef;\n  }\n\nsub _hsv_to_rgb\n  {\n  # H=0..360, S=0..1.0, V=0..1.0\n  my ($h, $s, $v) = @_;\n\n  my $e = 0.0001;\n\n  if ($s < $e)\n    {\n    $v = abs(int(256 * $v)); $v = 255 if $v > 255;\n    return ($v,$v,$v);\n    }\n\n  my ($r,$g,$b);\n  $h *= 360;\n\n  my $h1 = int($h / 60);\n  my $f = $h / 60 - $h1;\n  my $p = $v * (1 - $s);\n  my $q = $v * (1 - ($s * $f));\n  my $t = $v * (1 - ($s * (1-$f)));\n\n  if ($h1 == 0 || $h1 == 6)\n    {\n    $r = $v; $g = $t; $b = $p;\n    }\n  elsif ($h1 == 1)\n    {\n    $r = $q; $g = $v; $b = $p;\n    }\n  elsif ($h1 == 2)\n    {\n    $r = $p; $g = $v; $b = $t;\n    }\n  elsif ($h1 == 3)\n    {\n    $r = $p; $g = $q; $b = $v;\n    }\n  elsif ($h1 == 4)\n    {\n    $r = $t; $g = $p; $b = $v;\n    }\n  else\n    {\n    $r = $v; $g = $p; $b = $q;\n    }\n  # clamp values to 0.255\n  $r = abs(int($r*256));\n  $g = abs(int($g*256));\n  $b = abs(int($b*256));\n  $r = 255 if $r > 255;\n  $g = 255 if $g > 255;\n  $b = 255 if $b > 255;\n\n  ($r,$g,$b);\n  }\n\nsub _hsl_to_rgb\n  {\n  # H=0..360, S=0..100, L=0..100\n  my ($h, $s, $l) = @_;\n\n  my $e = 0.0001;\n  if ($s < $e)\n    {\n    # achromatic or grey\n    $l = abs(int(256 * $l)); $l = 255 if $l > 255;\n    return ($l,$l,$l);\n    }\n\n  my $t2;\n  if ($l < 0.5)\n    {\n    $t2 = $l * ($s + 1);\n    }\n  else\n    {\n    $t2 = $l + $s - ($l * $s);\n    }\n  my $t1 = $l * 2 - $t2;\n\n  my ($r,$g,$b);\n\n  # 0..359\n  $h %= 360 if $h >= 360;\n\n  # $h = 0..1\n  $h /= 360;\n\n  my $tr = $h + 1/3;\n  my $tg = $h;\n  my $tb = $h - 1/3;\n\n  $tr += 1 if $tr < 0; $tr -= 1 if $tr > 1;\n  $tg += 1 if $tg < 0; $tg -= 1 if $tg > 1;\n  $tb += 1 if $tb < 0; $tb -= 1 if $tb > 1;\n\n  my $i = 0; my @temp3 = ($tr,$tg,$tb);\n  my @rc;\n  for my $c ($r,$g,$b)\n    {\n    my $t3 = $temp3[$i++];\n\n    if ($t3 < 1/6)\n      {\n      $c = $t1 + ($t2 - $t1) * 6 * $t3;\n      }\n    elsif ($t3 < 1/2)\n      {\n      $c = $t2;\n      }\n    elsif ($t3 < 2/3)\n      {\n      $c = $t1 + ($t2 - $t1) * 6 * (2/3 - $t3);\n      }\n    else\n      {\n      $c = $t1;\n      }\n    $c = int($c * 256); $c = 255 if $c > 255;\n    push @rc, $c;\n    }\n\n  @rc;\n  }\n\nmy $factors = {\n  'rgb' => [ 255, 255, 255, 255 ],\n  'hsv' => [ 1, 1, 1, 255 ],\n  'hsl' => [ 360, 1, 1, 255 ],\n  };\n\nsub color_as_hex\n  {\n  # Turn \"red\" or rgb(255,0,0) or \"#f00\" into \"#ff0000\". Return undef for\n  # invalid colors.\n  my ($self,$color,$scheme) = @_;\n\n  $scheme ||= 'w3c';\n  $color = lc($color);\n  # 'w3c/red' => 'w3c', 'red'\n  $scheme = $1 if $color =~ s/^([a-z0-9])\\///;\n\n  # convert \"red\" to \"ffff00\"\n  return $color_names->{$scheme}->{$color} \n   if exists $color_names->{$scheme}->{$color};\n\n  # fallback to x11 scheme if color doesn't exist\n  return $color_names->{x11}->{$color} \n   if exists $color_names->{x11}->{$color};\n\n  my $qr_num = qr/\\s*\n\t((?:[0-9]{1,3}%?) |\t\t# 12%, 10, 2 etc\n\t (?:[0-9]?\\.[0-9]{1,5}) )\t# .1, 0.1, 2.5 etc\n    /x;\n\n  # rgb(255,100%,1.0) => '#ffffff'\n  if ($color =~ /^(rgb|hsv|hsl)\\($qr_num,$qr_num,$qr_num(?:,$qr_num)?\\s*\\)\\z/)\n    {\n    my $r = $2; my $g = $3; my $b = $4; my $a = $5; $a = 255 unless defined $a;\n    my $format = $1;\n\n    my $i = 0;\n    for my $c ($r,$g,$b,$a)\n      {\n      # for the first value in HSL or HSV, use 360, otherwise 100. For RGB, use 255\n      my $factor = $factors->{$format}->[$i++];\n\n      if ($c =~ /^([0-9]+)%\\z/)\t\t\t\t# 10% => 25.5\n\t{\n        $c = $1 * $factor / 100; \n\t}\n      else\n\t{\n        $c = $1 * $factor if $c =~ /^([0-9]+\\.[0-9]+)\\z/;\t\t# 0.1, 1.0\n        }\n      }\n\n    ($r,$g,$b) = Graph::Easy::_hsv_to_rgb($r,$g,$b) if $format eq 'hsv';\n    ($r,$g,$b) = Graph::Easy::_hsl_to_rgb($r,$g,$b) if $format eq 'hsl';\n\n    $a = int($a); $a = 255 if $a > 255;\n\n    # #RRGGBB or #RRGGBBAA\n    $color = sprintf(\"#%02x%02x%02x%02x\", $r,$g,$b,$a);\n    }\n\n  # turn #ff0 into #ffff00\n  $color = \"#$1$1$2$2$3$3\" if $color =~ /^#([a-f0-9])([a-f0-9])([a-f[0-9])\\z/;\n\n  # #RRGGBBff => #RRGGBB (alpha value of 255 is the default)\n  $color =~ s/^(#......)ff\\z/$1/i;\n\n  # check final color value to be #RRGGBB or #RRGGBBAA\n  return undef unless $color =~ /^#([a-f0-9]{6}|[a-f0-9]{8})\\z/i;\n\n  $color;\n  }\n\nsub text_style\n  {\n  # check whether the given list of textstyle attributes is valid\n  my ($self, $style) = @_;\n\n  return $style if $style =~ /^(normal|none|)\\z/;\n\n  my @styles = split /\\s+/, $style;\n  \n  return undef if grep(!/^(underline|overline|line-through|italic|bold)\\z/, @styles);\n\n  $style;\n  }\n\nsub text_styles\n  {\n  # return a hash with the defined textstyles checked\n  my ($self) = @_;\n\n  my $style = $self->attribute('textstyle');\n\n  return { none => 1 } if $style =~ /^(normal|none)\\z/;\n  return { } if $style eq '';\n\n  my $styles = {};\n  for my $key ( split /\\s+/, $style )\n    {\n    $styles->{$key} = 1;\n    }\n  $styles;\n  }\n\nsub text_styles_as_css\n  {\n  my ($self, $align, $fontsize) = @_;\n\n  my $style = '';\n  my $ts = $self->text_styles();\n\n  $style .= \" font-style: italic;\" if $ts->{italic};\n  $style .= \" font-weight: bold;\" if $ts->{bold};\n\n  if ($ts->{underline} || $ts->{none} || $ts->{overline} || $ts->{'line-through'})\n    {\n    # XXX TODO: HTML does seem to allow only one of them\n    my @s;\n    foreach my $k (qw/underline overline line-through none/)\n      {\n      push @s, $k if $ts->{$k};\n      }\n    my $s = join(' ', @s);\n    $style .= \" text-decoration: $s;\" if $s;\n    }\n\n  my $fs = $self->raw_attribute('fontsize');\n\n  $style .= \" font-size: $fs;\" if $fs;\n\n  if (!$align)\n    {\n    # XXX TODO: raw_attribute()?\n    my $al = $self->attribute('align');\n    $style .= \" text-align: $al;\" if $al;\n    }\n\n  $style;\n  }\n\nsub _font_size_in_pixels\n  {\n  my ($self, $em, $val) = @_;\n  \n  my $fs = $val; $fs = $self->attribute('fontsize') || '' if !defined $val;\n  return $em if $fs eq '';\n\n  if ($fs =~ /^([\\d.]+)em\\z/)\n    {\n    $fs = $1 * $em;\n    }\n  elsif ($fs =~ /^([\\d.]+)%\\z/)\n    {\n    $fs = ($1 / 100) * $em;\n    }\n  # this is discouraged:\n  elsif ($fs =~ /^([\\d.]+)px\\z/)\n    {\n    $fs = int($1 || 5);\n    }\n  else\n    {\n    $self->error(\"Illegal fontsize '$fs'\");\n    }\n  $fs;\n  }\n\n# direction modifier in degrees\nmy $modifier = {\n  forward => 0, front => 0, left => -90, right => +90, back => +180,\n  };\n\n# map absolute direction to degrees\nmy $dirs = {\n  up => 0, north => 0, down => 180, south => 180, west => 270, east => 90,\n  0 => 0, 180 => 180, 90 => 90, 270 => 270,\n  };\n\n# map absolute direction to side (south etc)\nmy $sides = {\n  north => 'north', \n  south => 'south', \n  east => 'east', \n  west => 'west', \n  up => 'north', \n  down => 'south',\n  0 => 'north',\n  180 => 'south',\n  90 => 'east',\n  270 => 'west',\n  };\n\nsub _direction_as_number\n  {\n  my ($self,$dir) = @_;\n\n  my $d = $dirs->{$dir};\n  $self->_croak(\"$dir is not an absolut direction\") unless defined $d;\n\n  $d;\n  }\n\nsub _direction_as_side\n  {\n  my ($self,$dir) = @_;\n\n  return unless exists $sides->{$dir};\n  $sides->{$dir};\n  }\n\nsub _flow_as_direction\n  {\n  # Take a flow direction (0,90,180,270 etc), and a new direction (left|south etc)\n  # and return the new flow. south et al will stay, while left|right etc depend\n  # on the incoming flow.\n  my ($self, $inflow, $dir) = @_;\n\n  # in=south and dir=forward => south\n  # in=south and dir=back => north etc\n  # in=south and dir=east => east \n\n#  return 90 unless defined $dir;\n\n  if ($dir =~ /^(south|north|west|east|up|down|0|90|180|270)\\z/)\n    {\n    # new direction is absolut, so inflow doesn't play a role\n    # return 0,90,180 or 270\n    return $dirs->{$dir};\n    }\n\n  my $in = $dirs->{$inflow};\n  my $modifier = $modifier->{$dir};\n\n  $self->_croak(\"$inflow,$dir results in undefined inflow\") unless defined $in;\n  $self->_croak(\"$inflow,$dir results in undefined modifier\") unless defined $modifier;\n\n  my $out = $in + $modifier;\n  $out -= 360 while $out >= 360;\t# normalize to 0..359\n  $out += 360 while $out < 0;\t\t# normalize to 0..359\n  \n  $out;\n  }\n\nsub _flow_as_side\n  {\n  # Take a flow direction (0,90,180,270 etc), and a new direction (left|south etc)\n  # and return the new flow. south et al will stay, while left|right etc depend\n  # on the incoming flow.\n  my ($self, $inflow, $dir) = @_;\n\n  # in=south and dir=forward => south\n  # in=south and dir=back => north etc\n  # in=south and dir=east => east \n\n#  return 90 unless defined $dir;\n\n  if ($dir =~ /^(south|north|west|east|up|down|0|90|180|270)\\z/)\n    {\n    # new direction is absolut, so inflow doesn't play a role\n    # return east, west etc\n    return $sides->{$dir};\n    }\n\n  my $in = $dirs->{$inflow};\n  my $modifier = $modifier->{$dir};\n\n  $self->_croak(\"$inflow,$dir results in undefined inflow\") unless defined $in;\n  $self->_croak(\"$inflow,$dir results in undefined modifier\") unless defined $modifier;\n\n  my $out = $in + $modifier;\n  $out -= 360 if $out >= 360;\t# normalize to 0..359\n  \n  $sides->{$out};\n  }\n\nsub _direction\n  {\n  # check that a direction (south etc) is valid\n  my ($self, $dir) = @_;\n\n  $dir =~ /^(south|east|west|north|down|up|0|90|180|270|front|forward|back|left|right)\\z/ ? $dir : undef;\n  }\n\nsub _border_attribute_as_html\n  {\n  # Return \"solid 1px red\" from the individual border(style|color|width)\n  # attributes, mainly for HTML output.\n  my ($style, $width, $color, $scheme) = @_;\n\n  $style ||= '';\n  $width = '' unless defined $width;\n  $color = '' unless defined $color;\n\n  $color = Graph::Easy->color_as_hex($color,$scheme)||'' if $color !~ /^#/;\n\n  return $style if $style =~ /^(none|)\\z/;\n\n  # width: 2px for double would collapse to one line\n  $width = '' if $style =~ /^double/;\n\n  # convert the style and widths to something HTML can understand\n\n  $width = '0.5em' if $style eq 'broad';\n  $width = '4px' if $style =~ /^bold/;\n  $width = '1em' if $style eq 'wide';\n  $style = 'solid' if $style =~ /(broad|wide|bold)\\z/;\n  $style = 'dashed' if $style eq 'bold-dash';\n  $style = 'double' if $style eq 'double-dash';\n\n  $width = $width.'px' if $width =~ /^\\s*\\d+\\s*\\z/;\n\n  return '' if $width eq '' && $style ne 'double';\n\n  my $val = join(\" \", $style, $width, $color);\n  $val =~ s/^\\s+//;\n  $val =~ s/\\s+\\z//;\n\n  $val;\n  }\n\nsub _border_attribute\n  {\n  # Return \"solid 1px red\" from the individual border(style|color|width)\n  # attributes. Used by as_txt().\n  my ($style, $width, $color) = @_;\n\n  $style ||= '';\n  $width = '' unless defined $width;\n  $color = '' unless defined $color;\n\n  return $style if $style =~ /^(none|)\\z/;\n\n  $width = $width.'px' if $width =~ /^\\s*\\d+\\s*\\z/;\n\n  my $val = join(\" \", $style, $width, $color);\n  $val =~ s/^\\s+//;\n  $val =~ s/\\s+\\z//;\n\n  $val;\n  }\n\nsub _border_width_in_pixels\n  {\n  my ($self, $em) = @_;\n  \n  my $bw = $self->attribute('borderwidth') || '0';\n  return 0 if $bw eq '0';\n\n  my $bs = $self->attribute('borderstyle') || 'none';\n\n  return 0 if $bs eq 'none';\n  return 3 if $bs =~ /^bold/;\n  return $em / 2 if $bs =~ /^broad/;\n  return $em if $bs =~ /^wide/;\n\n  # width: 1 is 1px;\n  return $bw if $bw =~ /^([\\d.]+)\\z/;\n\n  if ($bw =~ /^([\\d.]+)em\\z/)\n    {\n    $bw = $1 * $em;\n    }\n  elsif ($bw =~ /^([\\d.]+)%\\z/)\n    {\n    $bw = ($1 / 100) * $em;\n    }\n  # this is discouraged:\n  elsif ($bw =~ /^([\\d.]+)px\\z/)\n    {\n    $bw = $1;\n    }\n  else\n    {\n    $self->error(\"Illegal borderwidth '$bw'\");\n    }\n  $bw;\n  }\n\nsub _angle\n  {\n  # check an angle for being valid\n  my ($self, $angle) = @_;\n\n  return undef unless $angle =~ /^([+-]?\\d{1,3}|south|west|east|north|up|down|left|right|front|back|forward)\\z/;\n\n  $angle;\n  }\n\nsub _uint\n  {\n  # check a small unsigned integer for being valid\n  my ($self, $val) = @_;\n\n  return undef unless $val =~ /^\\d+\\z/;\n\n  $val = abs(int($val));\n  $val = 4 * 1024 if $val > 4 * 1024;\n\n  $val;\n  }\n\nsub _font\n  {\n  # check a font-list for being valid\n  my ($self, $font) = @_;\n\n  $font;\n  }\n\nsub split_border_attributes\n  {\n  # split \"1px solid black\" or \"red dotted\" into style, width and color\n  my ($self,$border) = @_;\n\n  # special case\n  return ('none', undef, undef) if $border eq '0';\n\n  # extract style\n  my $style;\n  $border =~ \n   s/(solid|dotted|dot-dot-dash|dot-dash|dashed|double-dash|double|bold-dash|bold|broad|wide|wave|none)/$style=$1;''/eg;\n\n  $style ||= 'solid';\n\n  # extract width\n  $border =~ s/(\\d+(px|em|%))//g;\n\n  my $width = $1 || '';\n  $width =~ s/[^0-9]+//g;\t\t\t\t# leave only digits\n\n  $border =~ s/\\s+//g;\t\t\t\t\t# rem unnec. spaces\n\n  # The left-over part must be a valid color. \n  my $color = $border;\n  $color = Graph::Easy->_color($border) if $border ne '';\n\n  $self->error(\"$border is not a valid bordercolor\")\n    unless defined $color;\n\n  $width = undef if $width eq '';\n  $color = undef if $color eq '';\n  $style = undef if $style eq '';\n  ($style,$width,$color);\n  }\n\n#############################################################################\n# attribute checking\n\n# different types of attributes with pre-defined handling\nuse constant {\n  ATTR_STRING\t=> 0,\t\t# an arbitrary string\n  ATTR_COLOR\t=> 1,\t\t# color name or value like rgb(1,1,1)\n  ATTR_ANGLE\t=> 2,\t\t# 0 .. 359.99\n  ATTR_PORT\t=> 3,\t\t# east, etc.\n  ATTR_UINT\t=> 4,\t\t# a \"small\" unsigned integer\n  ATTR_URL\t=> 5,\n\n# these cannot have \"inherit\", see ATTR_INHERIT_MIN\n  ATTR_LIST\t=> 6,\t\t# a list of values\n  ATTR_LCTEXT\t=> 7,\t\t# lowercase text (classname)\n  ATTR_TEXT\t=> 8,\t\t# titles, links, labels etc\n\n  ATTR_NO_INHERIT\t=> 6,\n\n  ATTR_DESC_SLOT\t=> 0,\n  ATTR_MATCH_SLOT\t=> 1,\n  ATTR_DEFAULT_SLOT\t=> 2,\n  ATTR_EXAMPLE_SLOT\t=> 3,\n  ATTR_TYPE_SLOT\t=> 4,\n\n\n  };\n\n# Lists the attribute names along with\n#   * a short description, \n#   * regexp or sub name to match valid attributes\n#   * default value\n#   * an short example value\n#   * type\n#   * graph examples\n\nmy $attributes = {\n  all => {\n    align => [\n     \"The alignment of the label text.\",\n     [ qw/center left right/ ],\n     { default => 'center', group => 'left', edge => 'left' },\n     'right',\n     undef,\n     \"graph { align: left; label: My Graph; }\\nnode {align: left;}\\n ( Nodes:\\n [ Right\\\\nAligned ] { align: right; } -- label\\\\n text -->\\n { align: left; }\\n [ Left\\\\naligned ] )\",\n     ],\n\n    autolink => [\n     \"If set to something else than 'none', will use the appropriate attribute to automatically generate the L<link>, unless L<link> is already set. See the section about labels, titles, names and links for reference.\",\n     [ qw/label title name none inherit/ ],\n     { default => 'inherit', graph => 'none' },\n     'title',\n     ],\n\n    autotitle => [\n     \"If set to something else than 'none', will use the appropriate attribute to automatically generate the L<title>, unless L<title> is already set. See the section about labels, titles, names and links for reference.\",\n     [ qw/label name none link inherit/ ],\n     { default => 'inherit', graph => 'none' },\n     'label',\n     ],\n\n    autolabel => [\n     \"Will restrict the L<label> text to N characters. N must be greater than 10. See the section about labels, titles, names and links for reference.\",\n     # for compatibility with older versions (pre v0.49), also allow \"name,N\"\n     qr/^(name\\s*,\\s*)?[\\d]{2,5}\\z/,\n     { default => 'inherit', graph => '' },\n     '20',\n     undef,\n     \"graph { autolabel: 20; autotitle: name; }\\n\\n[ Bonn ]\\n -- Acme Travels Incorporated -->\\n  [ Frankfurt (Main) / Flughafen ]\",\n     ],\n\n    background => [\n     \"The background color, e.g. the color B<outside> the shape. Do not confuse with L<fill>. If set to inherit, the object will inherit the L<fill> color (B<not> the background color!) of the parent e.g. the enclosing group or graph. See the section about color names and values for reference.\",\n     undef,\n#     { default => 'inherit', graph => 'white', 'group.anon' => 'white', 'node.anon' => 'white' },\n     'inherit',\n     'rgb(255,0,0)',\n     ATTR_COLOR,\n     \"[ Crimson ] { shape: circle; background: crimson; }\\n -- Aqua Marine --> { background: #7fffd4; }\\n [ Misty Rose ]\\n  { background: white; fill: rgb(255,228,221); shape: ellipse; }\",\n     ],\n\n    class => [\n     'The subclass of the object. See the section about class names for reference.',\n      qr/^(|[a-zA-Z][a-zA-Z0-9_]*)\\z/,\n     '',\n     'mynodeclass',\n     ATTR_LCTEXT,\n     ],\n\n    color => [\n     'The foreground/text/label color. See the section about color names and values for reference.',\n     undef,\n     'black',\n     'rgb(255,255,0)',\n     ATTR_COLOR,\n     \"[ Lime ] { color: limegreen; }\\n -- label --> { color: blue; labelcolor: red; }\\n [ Dark Orange ] { color: rgb(255,50%,0.01); }\",\n     ],\n\n    colorscheme => [\n     \"The colorscheme to use for all color values. See the section about color names and values for reference and a list of possible values.\",\n     '_color_scheme',\n     { default => 'inherit', graph => 'w3c', },\n     'x11',\n     ATTR_STRING,\n     \"graph { colorscheme: accent8; } [ 1 ] { fill: 1; }\\n\"\n        . \" -> \\n [ 3 ] { fill: 3; }\\n\" \n        . \" -> \\n [ 4 ] { fill: 4; }\\n\" \n        . \" -> \\n [ 5 ] { fill: 5; }\\n\" \n        . \" -> \\n [ 6 ] { fill: 6; }\\n\" \n        . \" -> \\n [ 7 ] { fill: 7; }\\n\" \n        . \" -> \\n [ 8 ] { fill: 8; }\\n\" ,\n     ],\n\n    comment => [\n\t\"A free-form text field containing a comment on this object. This will be embedded into output formats if possible, e.g. in HTML, SVG and Graphviz, but not ASCII or Boxart.\",\n\tundef,\n\t'',\n\t'(C) by Tels 2007. All rights reserved.',\n\tATTR_STRING,\n\t\"graph { comment: German capitals; }\\n [ Bonn ] --> [ Berlin ]\",\n    ],\n\n    fill => [\n     \"The fill color, e.g. the color inside the shape. For the graph, this is the background color for the label. For edges, defines the color inside the arrow shape. See also L<background>. See the section about color names and values for reference.\",\n     undef,\n     { default => 'white', graph => 'inherit', edge => 'inherit', group => '#a0d0ff', \n\t'group.anon' => 'white', 'node.anon' => 'inherit' },\n     'rgb(255,0,0)',\n     ATTR_COLOR,\n     \"[ Crimson ]\\n  {\\n  shape: circle;\\n  background: yellow;\\n  fill: red;\\n  border: 3px solid blue;\\n  }\\n-- Aqua Marine -->\\n  {\\n  arrowstyle: filled;\\n  fill: red;\\n  }\\n[ Two ]\",\n     ],\n\n    'fontsize' => [\n     \"The size of the label text, best expressed in I<em> (1.0em, 0.5em etc) or percent (100%, 50% etc)\",\n     qr/^\\d+(\\.\\d+)?(em|px|%)?\\z/,\n     { default => '0.8em', graph => '1em', node => '1em', },\n     '50%',\n     undef,\n     \"graph { fontsize: 200%; label: Sample; }\\n\\n ( Nodes:\\n [ Big ] { fontsize: 1.5em; color: white; fill: darkred; }\\n  -- Small -->\\n { fontsize: 0.2em; }\\n  [ Normal ] )\",\n     ],\n\n    flow => [\n     \"The general direction in which edges will leave nodes first. On edges, influeces where the target node is place. Please see the section about <a href='hinting.html#flow'>flow control</a> for reference.\",\n     '_direction',\n     { graph => 'east', default => 'inherit' },\n     'south',\n      undef,\n      \"graph { flow: up; }\\n [ Enschede ] { flow: left; } -> [ Bielefeld ] -> [ Wolfsburg ]\",\n     ],\n\n    font => [\n     'A prioritized list of lower-case, unquoted values, separated by a comma. Values are either font family names (like \"times\", \"arial\" etc) or generic family names (like \"serif\", \"cursive\", \"monospace\"), the first recognized value will be used. Always offer a generic name as the last possibility.',\n     '_font',\n     { default => 'serif', edge => 'sans-serif' },\n     'arial, helvetica, sans-serif',\n     undef,\n     \"graph { font: vinque, georgia, utopia, serif; label: Sample; }\" .\n     \"\\n\\n ( Nodes:\\n [ Webdings ] { font: Dingbats, webdings; }\\n\".\n     \" -- FlatLine -->\\n { font: flatline; }\\n  [ Normal ] )\",\n     ],\n\n    id => [\n     \"A unique identifier for this object, consisting only of letters, digits, or underscores.\",\n     qr/^[a-zA-Z0-9_]+\\z/,\n     '',\n     'Bonn123',\n     undef,\n     \"[ Bonn ] --> { id: 123; } [ Berlin ]\",\n     ],\n\n    label => [\n     \"The text displayed as label. If not set, equals the name (for nodes) or no label (for edges, groups and the graph itself).\",\n     undef,\n     undef,\n     'My label',\n     ATTR_TEXT,\n     ],\n\n    linkbase => [\n     'The base URL prepended to all generated links. See the section about links for reference.',\n     undef,\n     { default => 'inherit', graph => '/wiki/index.php/', },\n     'http://en.wikipedia.org/wiki/',\n     ATTR_URL,\n     ],\n\n    link => [\n     'The link part, appended onto L<linkbase>. See the section about links for reference.',\n     undef,\n     '',\n     'Graph',\n     ATTR_TEXT,\n     <<LINK_EOF\nnode {\n  autolink: name;\n  textstyle: none;\n  fontsize: 1.1em;\n  }\ngraph {\n  linkbase: http://de.wikipedia.org/wiki/;\n  }\nedge {\n  textstyle: overline;\n  }\n\n[] --> [ Friedrichshafen ]\n -- Schiff --> { autolink: label; color: orange; title: Vrooom!; }\n[ Immenstaad ] { color: green; } --> [ Hagnau ]\nLINK_EOF\n     ],\n\n    title => [\n     \"The text displayed as mouse-over for nodes/edges, or as the title for the graph. If empty, no title will be generated unless L<autotitle> is set.\",\n     undef,\n     '',\n     'My title',\n     ATTR_TEXT,\n     ],\n\n    format => [\n     \"The formatting language of the label. The default, C<none> means nothing special will be done. When set to C<pod>, formatting codes like <code>B&lt;bold&gt;</code> will change the formatting of the label. See the section about label text formatting for reference.\",\n     [ 'none', 'pod' ],\n     'none',\n     'pod',\n     undef,\n     <<EOF\ngraph {\n  format: pod;\n  label: I am B<bold> and I<italic>;\n  }\nnode { format: pod; }\nedge { format: pod; }\n\n[ U<B<bold and underlined>> ]\n--> { label: \"S<Fähre>\"; }\n [ O<Konstanz> ]\nEOF\n     ],\n\n    textstyle => [\n     \"The style of the label text. Either 'none', or any combination (separated with spaces) of 'underline', 'overline', 'bold', 'italic', 'line-through'. 'none' disables underlines on links.\",\n     'text_style',\n     '',\n     'underline italic bold',\n     undef,\n     <<EOF\ngraph {\n  fontsize: 150%;\n  label: Verbindung;\n  textstyle: bold italic;\n  }\nnode {\n  textstyle: underline bold;\n  fill: #ffd080;\n  }\nedge {\n  textstyle: italic bold overline;\n  }\n\n[ Meersburg ] { fontsize: 2em; }\n -- F\\x{e4}hre --> { fontsize: 1.2em; color: red; }\n [ Konstanz ]\nEOF\n     ],\n\n    textwrap => [\n     \"The default C<none> makes the label text appear exactly as it was written, with <a href='syntax.html'>manual line breaks</a> applied. When set to a positive number, the label text will be wrapped after this number of characters. When set to C<auto>, the label text will be wrapped to make the node size as small as possible, depending on output format this may even be dynamic. When not C<none>, manual line breaks and alignments on them are ignored.\",\n     qr/^(auto|none|\\d{1,4})/,\n     { default => 'inherit', graph => 'none' },\n     'auto',\n     undef,\n     \"node { textwrap: auto; }\\n ( Nodes:\\n [ Frankfurt (Oder) liegt an der\\n   ostdeutschen Grenze und an der Oder ] -->\\n [ Städte innerhalb der\\n   Ost-Westfahlen Region mit sehr langen Namen] )\",\n     ],\n   },\n\n  node => {\n    bordercolor => [\n     'The color of the L<border>. See the section about color names and values for reference.',\n     undef,\n     { default => '#000000' },\n     'rgb(255,255,0)',\n     ATTR_COLOR,\n     \"node { border: black bold; }\\n[ Black ]\\n --> [ Red ]      { bordercolor: red; }\\n --> [ Green ]    { bordercolor: green; }\",\n     ],\n\n    borderstyle => [\n     'The style of the L<border>. The special styles \"bold\", \"broad\", \"wide\", \"double-dash\" and \"bold-dash\" will set and override the L<borderwidth>.',\n     [ qw/none solid dotted dashed dot-dash dot-dot-dash double wave bold bold-dash broad double-dash wide/ ],\n     { default => 'none', 'node.anon' => 'none', 'group.anon' => 'none', node => 'solid', group => 'dashed' },\n     'dotted',\n     undef,\n     \"node { border: dotted; }\\n[ Dotted ]\\n --> [ Dashed ]      { borderstyle: dashed; }\\n --> [ broad ]    { borderstyle: broad; }\",\n     ],\n\n    borderwidth => [\n     'The width of the L<border>. Certain L<border>-styles will override the width.',\n     qr/^\\d+(px|em)?\\z/,\n     '1',\n     '2px',\n     ],\n\n    border => [\n     'The border. Can be any combination of L<borderstyle>, L<bordercolor> and L<borderwidth>.',\n     undef,\n     { default => 'none', 'node.anon' => 'none', 'group.anon' => 'none', node => 'solid 1px #000000', group => 'dashed 1px #000000' },\n     'dotted red',\n     undef,\n     \"[ Normal ]\\n --> [ Bold ]      { border: bold; }\\n --> [ Broad ]     { border: broad; }\\n --> [ Wide ]      { border: wide; }\\n --> [ Bold-Dash ] { border: bold-dash; }\",\n     ],\n\n    basename => [\n     \"Controls the base name of an autosplit node. Ignored for all other nodes. Unless set, it is generated automatically from the node parts. Please see the section about <a href='hinting.html#autosplit'>autosplit</a> for reference.\",\n     undef,\n      '',\n      '123',\n       undef,\n     \"[ A|B|C ] { basename: A } [ 1 ] -> [ A.2 ]\\n [ A|B|C ] [ 2 ] -> [ ABC.2 ]\",\n     ], \n\n    group => [\n     \"Puts the node into this group.\",\n     undef,\n      '',\n      'Cities',\n       undef,\n     \"[ A ] { group: Cities:; } ( Cities: [ B ] ) [ A ] --> [ B ]\",\n     ], \n\n    size => [\n     'The size of the node in columns and rows. Must be greater than 1 in each direction.',\n     qr/^\\d+\\s*,\\s*\\d+\\z/,\n     '1,1',\n     '3,2',\n     ],\n    rows => [\n     'The size of the node in rows. See also L<size>.',\n     qr/^\\d+\\z/,\n     '1',\n     '3',\n     ],\n    columns => [\n     'The size of the node in columns. See also L<size>.',\n     qr/^\\d+\\z/,\n     '1',\n     '2',\n     ],\n\n    offset => [\n     'The offset of this node from the L<origin> node, in columns and rows. Only used if you also set the L<origin> node.',\n     qr/^[+-]?\\d+\\s*,\\s*[+-]?\\d+\\z/,\n     '0,0',\n     '3,2',\n     undef,\n     \"[ A ] -> [ B ] { origin: A; offset: 2,2; }\",\n     ],\n\n    origin => [\n     'The name of the node, that this node is relativ to. See also L<offset>.',\n     undef,\n     '',\n     'Cluster A',\n     ],\n\n    pointshape => [\n     \"Controls the style of a node that has a L<shape> of 'point'.\",\n     [ qw/star square dot circle cross diamond invisible x/ ],\n      'star',\n      'square',\n      undef,\n     \"node { shape: point; }\\n\\n [ A ]\".\n     \"\\n -> [ B ] { pointshape: circle; }\" .\n     \"\\n -> [ C ] { pointshape: cross; }\" . \n     \"\\n -> [ D ] { pointshape: diamond; }\" . \n     \"\\n -> [ E ] { pointshape: dot; }\" . \n     \"\\n -> [ F ] { pointshape: invisible; }\" . \n     \"\\n -> [ G ] { pointshape: square; }\" . \n     \"\\n -> [ H ] { pointshape: star; }\" .\n     \"\\n -> [ I ] { pointshape: x; }\" .\n     \"\\n -> [ ☯ ] { shape: none; }\"\n     ], \n\n    pointstyle => [\n     \"Controls the style of the L<pointshape> of a node that has a L<shape> of 'point'. \" .\n     \"Note for backwards compatibility reasons, the shape names 'star', 'square', 'dot', 'circle', 'cross', 'diamond' and 'invisible' \".\n     \"are also supported, but should not be used here, instead set them via L<pointshape>.\",\n     [ qw/closed filled star square dot circle cross diamond invisible x/ ],\n      'filled',\n      'open',\n      undef,\n     \"node { shape: point; pointstyle: closed; pointshape: diamond; }\\n\\n [ A ] --> [ B ] { pointstyle: filled; }\",\n     ], \n\n    rank => [\n     \"The rank of the node, used by the layouter to find the order and placement of nodes. \" .\n     \"Set to C<auto> (the default), C<same> (usefull for node lists) or a positive number. \" .\n     \"See the section about ranks for reference and more examples.\",\n       qr/^(auto|same|\\d{1,6})\\z/,\n       'auto',\n       'same',\n       undef,\n     \"[ Bonn ], [ Berlin ] { rank: same; }\\n [ Bonn ] -> [ Cottbus ] -> [ Berlin ]\",\n     ],\n\n    rotate => [\n     \"The rotation of the node shape, either an absolute value (like C<south>, C<up>, C<down> or C<123>), or a relative value (like C<+12>, C<-90>, C<left>, C<right>). For relative angles, the rotation will be based on the node's L<flow>. Rotation is clockwise.\",\n       undef,\n       '0',\n       '180',\n       ATTR_ANGLE,\n     \"[ Bonn ] { rotate: 45; } -- ICE --> \\n [ Berlin ] { shape: triangle; rotate: -90; }\",\n     ],\n\n    shape => [\n     \"The shape of the node. Nodes with shape 'point' (see L<pointshape>) have a fixed size and do not display their label. The border of such a node is the outline of the C<pointshape>, and the fill is the inside of the C<pointshape>. When the C<shape> is set to the value 'img', the L<label> will be interpreted as an external image resource to display. In this case attributes like L<color>, L<fontsize> etc. are ignored.\",\n       [ qw/ circle diamond edge ellipse hexagon house invisible invhouse invtrapezium invtriangle octagon parallelogram pentagon\n             point triangle trapezium septagon rect rounded none img/ ],\n      'rect',\n      'circle',\n      undef,\n      \"[ Bonn ] -> \\n [ Berlin ] { shape: circle; }\\n -> [ Regensburg ] { shape: rounded; }\\n -> [ Ulm ] { shape: point; }\\n -> [ Wasserburg ] { shape: invisible; }\\n -> [ Augsburg ] { shape: triangle; }\\n -> [ House ] { shape: img; label: img/house.png;\\n          border: none; title: My House; fill: inherit; }\",\n     ],\n\n  }, # node\n\n  graph => {\n\n    bordercolor => [\n     'The color of the L<border>. See the section about color names and values for reference.',\n     undef,\n     { default => '#000000' },\n     'rgb(255,255,0)',\n     ATTR_COLOR,\n     \"node { border: black bold; }\\n[ Black ]\\n --> [ Red ]      { bordercolor: red; }\\n --> [ Green ]    { bordercolor: green; }\",\n     ],\n\n    borderstyle => [\n     'The style of the L<border>. The special styles \"bold\", \"broad\", \"wide\", \"double-dash\" and \"bold-dash\" will set and override the L<borderwidth>.',\n     [ qw/none solid dotted dashed dot-dash dot-dot-dash double wave bold bold-dash broad double-dash wide/ ],\n     { default => 'none', 'node.anon' => 'none', 'group.anon' => 'none', node => 'solid', group => 'dashed' },\n     'dotted',\n     undef,\n     \"node { border: dotted; }\\n[ Dotted ]\\n --> [ Dashed ]      { borderstyle: dashed; }\\n --> [ broad ]    { borderstyle: broad; }\",\n     ],\n\n    borderwidth => [\n     'The width of the L<border>. Certain L<border>-styles will override the width.',\n     qr/^\\d+(px|em)?\\z/,\n     '1',\n     '2px',\n     ],\n\n    border => [\n     'The border. Can be any combination of L<borderstyle>, L<bordercolor> and L<borderwidth>.',\n     undef,\n     { default => 'none', 'node.anon' => 'none', 'group.anon' => 'none', node => 'solid 1px #000000', group => 'dashed 1px #000000' },\n     'dotted red',\n     undef,\n     \"[ Normal ]\\n --> [ Bold ]      { border: bold; }\\n --> [ Broad ]     { border: broad; }\\n --> [ Wide ]      { border: wide; }\\n --> [ Bold-Dash ] { border: bold-dash; }\",\n     ],\n\n    gid => [\n\t\"A unique ID for the graph. Usefull if you want to include two graphs into one HTML page.\",\n\tqr/^\\d+\\z/,\n\t'',\n\t'123',\n     ],\n\n    labelpos => [\n\t\"The position of the graph label.\",\n\t[ qw/top bottom/ ],\n\t'top',\n\t'bottom',\n\tATTR_LIST,\n        \"graph { labelpos: bottom; label: My Graph; }\\n\\n [ Buxtehude ] -> [ Fuchsberg ]\\n\"\n     ],\n\n    output => [\n\t\"The desired output format. Only used when calling Graph::Easy::output(), or by mediawiki-graph.\",\n\t[ qw/ascii html svg graphviz boxart debug/ ],\n\t'',\n\t'ascii',\n\tATTR_LIST,\n        \"graph { output: debug; }\"\n     ],\n\n    root => [\n\t\"The name of the root node, given as hint to the layouter to start the layout there. When not set, the layouter will pick a node at semi-random.\",\n\tundef,\n\t'',\n\t'My Node',\n\tATTR_TEXT,\n\t\"graph { root: B; }\\n # B will be at the left-most place\\n [ A ] --> [ B ] --> [ C ] --> [ D ] --> [ A ]\",\n     ],\n\n    type => [\n\t\"The type of the graph, either undirected or directed.\",\n\t[ qw/directed undirected/ ],\n\t'directed',\n\t'undirected',\n\tATTR_LIST,\n\t\"graph { type: undirected; }\\n [ A ] --> [ B ]\",\n     ],\n\n  }, # graph\n\n  edge => {\n\n    style => [\n      'The line style of the edge. When set on the general edge class, this attribute changes only the style of all solid edges to the specified one.',\n      [ qw/solid dotted dashed dot-dash dot-dot-dash bold bold-dash double-dash double wave broad wide invisible/], # broad-dash wide-dash/ ],\n      'solid',\n      'dotted',\n      undef,\n      \"[ A ] -- solid --> [ B ]\\n .. dotted ..> [ C ]\\n -  dashed - > [ D ]\\n -- bold --> { style: bold; } [ E ]\\n -- broad --> { style: broad; } [ F ]\\n -- wide --> { style: wide; } [ G ]\",\n     ],\n\n    arrowstyle => [\n      'The style of the arrow. Open arrows are vee-shaped and the bit inside the arrow has the color of the L<background>. Closed arrows are triangle shaped, with a background-color fill. Filled arrows are closed, too, but use the L<fill> color for the inside. If the fill color is not set, the L<color> attribute will be used instead. An C<arrowstyle> of none creates undirected edges just like \"[A] -- [B]\" would do.',\n      [ qw/none open closed filled/ ],\n      'open',\n      'closed',\n      undef,\n      \"[ A ] -- open --> [ B ]\\n -- closed --> { arrowstyle: closed; } [ C ]\\n -- filled --> { arrowstyle: filled; } [ D ]\\n -- filled --> { arrowstyle: filled; fill: lime; } [ E ]\\n -- none --> { arrowstyle: none; } [ F ]\",\n     ],\n\n    arrowshape => [\n      'The basic shape of the arrow. Can be combined with each of L<arrowstyle>.',\n      [ qw/triangle box dot inv line diamond cross x/ ],\n      'triangle',\n      'box',\n      undef,\n      \"[ A ] -- triangle --> [ B ]\\n -- box --> { arrowshape: box; } [ C ]\\n\" .\n      \" -- inv --> { arrowshape: inv; } [ D ]\\n -- diamond --> { arrowshape: diamond; } [ E ]\\n\" .\n      \" -- dot --> { arrowshape: dot; } [ F ]\\n\" .\n      \" -- line --> { arrowshape: line; } [ G ] \\n\" .\n      \" -- plus --> { arrowshape: cross; } [ H ] \\n\" .\n      \" -- x --> { arrowshape: x; } [ I ] \\n\\n\" .\n      \"[ a ] -- triangle --> { arrowstyle: filled; } [ b ]\\n\".\n      \" -- box --> { arrowshape: box; arrowstyle: filled; } [ c ]\\n\" .\n      \" -- inv --> { arrowshape: inv; arrowstyle: filled; } [ d ]\\n\" .\n      \" -- diamond --> { arrowshape: diamond; arrowstyle: filled; } [ e ]\\n\" .\n      \" -- dot --> { arrowshape: dot; arrowstyle: filled; } [ f ]\\n\" .\n      \" -- line --> { arrowshape: line; arrowstyle: filled; } [ g ] \\n\" .\n      \" -- plus --> { arrowshape: cross; arrowstyle: filled; } [ h ] \\n\" .\n      \" -- x --> { arrowshape: x; arrowstyle: filled; } [ i ] \\n\",\n     ],\n\n    labelcolor => [\n     'The text color for the label. If unspecified, will fall back to L<color>. See the section about color names and values for reference.',\n     undef,\n     'black',\n     'rgb(255,255,0)',\n     ATTR_COLOR,\n     \"[ Bonn ] -- ICE --> { labelcolor: blue; }\\n [ Berlin ]\",\n     ],\n\n    start => [\n     'The starting port of this edge. See <a href=\"hinting.html#joints\">the section about joints</a> for reference.',\n     qr/^(south|north|east|west|left|right|front|back)(\\s*,\\s*-?\\d{1,4})?\\z/,\n     '',\n     'front, 0',\n     ATTR_PORT,\n     \"[ Bonn ] -- NORTH --> { start: north; end: north; } [ Berlin ]\",\n     ],\n\n    end => [\n     'The ending port of this edge. See <a href=\"hinting.html#joints\">the section about joints</a> for reference.',\n     qr/^(south|north|east|west|right|left|front|back)(\\s*,\\s*-?\\d{1,4})?\\z/,\n     '',\n     'back, 0',\n     ATTR_PORT,\n     \"[ Bonn ] -- NORTH --> { start: south; end: east; } [ Berlin ]\",\n     ],\n\n    minlen => [\n     'The minimum length of the edge, in cells. Defaults to 1. The minimum length is ' .\n     'automatically increased for edges with joints.',\n     undef,\n     '1',\n     '4',\n     ATTR_UINT,\n     \"[ Bonn ] -- longer --> { minlen: 3; } [ Berlin ]\\n[ Bonn ] --> [ Potsdam ] { origin: Bonn; offset: 2,2; }\",\n     ],\n\n    autojoin => [\n     'Controls whether the layouter can join this edge automatically with other edges leading to the same node. C<never> means this edge will never joined with another edge automatically, C<always> means always (if possible), even if the attributes on the edges do not match. C<equals> means only edges with the same set of attributes will be automatically joined together. See also C<autosplit>.',\n     [qw/never always equals/],\n     'never',\n     'always',\n     undef,\n     \"[ Bonn ], [ Aachen ]\\n -- 1 --> { autojoin: equals; } [ Berlin ]\",\n     ],\n\n    autosplit => [\n     'Controls whether the layouter replace multiple edges leading from one node to other nodes with one edge splitting up. C<never> means this edge will never be part of such a split, C<always> means always (if possible), even if the attributes on the edges do not match. C<equals> means only edges with the same set of attributes will be automatically split up. See also C<autojoin>.',\n     [qw/never always equals/],\n     'never',\n     'always',\n     undef,\n     \"[ Bonn ]\\n -- 1 --> { autosplit: equals; } [ Berlin ], [ Aachen ]\",\n     ],\n\n   }, # edge\n\n  group => {\n    bordercolor => [\n     'The color of the L<border>. See the section about color names and values for reference.',\n     undef,\n     { default => '#000000' },\n     'rgb(255,255,0)',\n     ATTR_COLOR,\n     \"node { border: black bold; }\\n[ Black ]\\n --> [ Red ]      { bordercolor: red; }\\n --> [ Green ]    { bordercolor: green; }\",\n     ],\n\n    borderstyle => [\n     'The style of the L<border>. The special styles \"bold\", \"broad\", \"wide\", \"double-dash\" and \"bold-dash\" will set and override the L<borderwidth>.',\n     [ qw/none solid dotted dashed dot-dash dot-dot-dash double wave bold bold-dash broad double-dash wide/ ],\n     { default => 'none', 'node.anon' => 'none', 'group.anon' => 'none', node => 'solid', group => 'dashed' },\n     'dotted',\n     undef,\n     \"node { border: dotted; }\\n[ Dotted ]\\n --> [ Dashed ]      { borderstyle: dashed; }\\n --> [ broad ]    { borderstyle: broad; }\",\n     ],\n\n    borderwidth => [\n     'The width of the L<border>. Certain L<border>-styles will override the width.',\n     qr/^\\d+(px|em)?\\z/,\n     '1',\n     '2px',\n     ],\n\n    border => [\n     'The border. Can be any combination of L<borderstyle>, L<bordercolor> and L<borderwidth>.',\n     undef,\n     { default => 'none', 'node.anon' => 'none', 'group.anon' => 'none', node => 'solid 1px #000000', group => 'dashed 1px #000000' },\n     'dotted red',\n     undef,\n     \"[ Normal ]\\n --> [ Bold ]      { border: bold; }\\n --> [ Broad ]     { border: broad; }\\n --> [ Wide ]      { border: wide; }\\n --> [ Bold-Dash ] { border: bold-dash; }\",\n     ],\n\n    nodeclass => [\n      'The class into which all nodes of this group are put.',\n      qr/^(|[a-zA-Z][a-zA-Z0-9_]*)\\z/,\n      '',\n      'cities',\n     ],\n\n    edgeclass => [\n      'The class into which all edges defined in this group are put. This includes edges that run between two nodes belonging to the same group.',\n      qr/^(|[a-zA-Z][a-zA-Z0-9_]*)\\z/,\n      '',\n      'connections',\n     ],\n\n    rank => [\n     \"The rank of the group, used by the layouter to find the order and placement of group. \" .\n     \"Set to C<auto> (the default), C<same> or a positive number. \" .\n     \"See the section about ranks for reference and more examples.\",\n       qr/^(auto|same|\\d{1,6})\\z/,\n       'auto',\n       'same',\n       undef,\n     \"( Cities: [ Bonn ], [ Berlin ] ) { rank: 0; } ( Rivers: [ Rhein ], [ Sieg ] ) { rank: 0; }\",\n     ],\n\n    root => [\n\t\"The name of the root node, given as hint to the layouter to start the layout there. When not set, the layouter will pick a node at semi-random.\",\n\tundef,\n\t'',\n\t'My Node',\n\tATTR_TEXT,\n\t\"( Cities: [ A ] --> [ B ] --> [ C ] --> [ D ] --> [ A ] ) { root: B; }\",\n     ],\n\n    group => [\n     \"Puts the group inside this group, nesting the two groups inside each other.\",\n     undef,\n      '',\n      'Cities',\n       undef,\n     \"( Cities: [ Bonn ] ) ( Rivers: [ Rhein ] ) { group: Cities:; }\",\n     ], \n\n    labelpos => [\n\t\"The position of the group label.\",\n\t[ qw/top bottom/ ],\n\t'top',\n\t'bottom',\n\tATTR_LIST,\n        \"group { labelpos: bottom; }\\n\\n ( My Group: [ Buxtehude ] -> [ Fuchsberg ] )\\n\"\n     ],\n\n   }, # group\n\n  # These entries will be allowed temporarily during Graphviz parsing for\n  # intermidiate values, like \"shape=record\".\n  special => { },\n  }; # end of attribute definitions\n\nsub _allow_special_attributes\n  {\n  # store a hash with special temp. attributes\n  my ($self, $att) = @_;\n  $attributes->{special} = $att;\n  }\n\nsub _drop_special_attributes\n  {\n  # drop the hash with special temp. attributes\n  my ($self) = @_;\n\n  $attributes->{special} = {};\n  }\n\nsub _attribute_entries\n  {\n  # for building the manual page\n  $attributes;\n  }\n\nsub border_attribute\n  {\n  # Return \"1px solid red\" from the border-(style|color|width) attributes,\n  # mainly used by as_txt() output. Does not use colorscheme!\n  my ($self, $class) = @_;\n\n  my ($style,$width,$color);\n\n  my $g = $self; $g = $self->{graph} if ref($self->{graph});\n\n  my ($def_style, $def_color, $def_width);\n\n  # XXX TODO need no_default_attribute()\n  if (defined $class)\n    {\n    $style = $g->attribute($class, 'borderstyle');\n    return $style if $style eq 'none';\n\n    $def_style = $g->default_attribute('borderstyle');\n\n    $width = $g->attribute($class,'borderwidth');\n    $def_width = $g->default_attribute($class,'borderwidth');\n    $width = '' if $def_width eq $width;\n\n    $color = $g->attribute($class,'bordercolor');\n    $def_color = $g->default_attribute($class,'bordercolor');\n    $color = '' if $def_color eq $color;\n    }\n  else \n    {\n    $style = $self->attribute('borderstyle');\n    return $style if $style eq 'none';\n\n    $def_style = $self->default_attribute('borderstyle');\n\n    $width = $self->attribute('borderwidth');\n    $def_width = $self->default_attribute('borderwidth');\n    $width = '' if $def_width eq $width;\n\n    $color = $self->attribute('bordercolor');\n    $def_color = $self->default_attribute('bordercolor');\n    $color = '' if $def_color eq $color;\n    }\n\n  return '' if $def_style eq $style and $color eq '' && $width eq '';\n\n  Graph::Easy::_border_attribute($style, $width, $color);\n  }\n\nsub _unknown_attribute\n  {\n  # either just warn, or raise an error for unknown attributes\n  my ($self, $name, $class) = @_;\n\n  if ($self->{_warn_on_unknown_attributes})\n    {\n    $self->warn(\"Ignoring unknown attribute '$name' for class $class\") \n    }\n  else\n    {\n    $self->error(\"Error in attribute: '$name' is not a valid attribute name for a $class\");\n    }\n  return;\n  }\n\nsub default_attribute\n  {\n  # Return the default value for the attribute.\n  my ($self, $class, $name) = @_;\n\n  # allow $self->default_attribute('fill');\n  if (scalar @_ == 2)\n    {\n    $name = $class;\n    $class = $self->{class} || 'graph';\n    }\n\n  # get the base class: node.foo => node\n  my $base_class = $class; $base_class =~ s/\\..*//;\n\n  # Remap alias names without \"-\" to their hyphenated version:\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  # \"x-foo-bar\" is a custom attribute, so allow it always. The name must\n  # consist only of letters and hyphens, and end in a letter or number.\n  # Hyphens must be separated by letters. Custom attributes do not have a default.\n  return '' if $name =~ $qr_custom_attribute;\n\n  # prevent ->{special}->{node} from springing into existance\n  my $s = $attributes->{special}; $s = $s->{$class} if exists $s->{$class};\n\n  my $entry =\t$s->{$name} ||\n\t\t$attributes->{all}->{$name} ||\n\t\t$attributes->{$base_class}->{$name};\n\n  # Didn't found an entry:\n  return $self->_unknown_attribute($name,$class) unless ref($entry);\n\n  # get the default attribute from the entry\n  my $def = $entry->[ ATTR_DEFAULT_SLOT ]; my $val = $def;\n\n  # \"node.subclass\" gets the default from \"node\", 'edge' from 'default':\n  # \" { default => 'foo', 'node.anon' => 'none', node => 'solid' }\":\n  if (ref $def)\n    {\n    $val = $def->{$class};\n    $val = $def->{$base_class} unless defined $val;\n    $val = $def->{default} unless defined $val;\n    }\n\n  $val;\n  }\n\nsub raw_attribute\n  {\n  # Return either the raw attribute set on an object (honoring inheritance),\n  # or undef for when that specific attribute is not set. Does *not*\n  # inspect class attributes.\n  my ($self, $name) = @_;\n\n  # Remap alias names without \"-\" to their hyphenated version:\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  my $class = $self->{class} || 'graph';\n  my $base_class = $class; $base_class =~ s/\\..*//;\n\n  # prevent ->{special}->{node} from springing into existance\n  my $s = $attributes->{special}; $s = $s->{$class} if exists $s->{$class};\n\n  my $entry =\t$s->{$name} ||\n\t\t$attributes->{all}->{$name} ||\n\t\t$attributes->{$base_class}->{$name};\n\n  # create a fake entry for custom attributes\n  $entry = [ '', undef, '', '', ATTR_STRING, '' ]\n    if $name =~ $qr_custom_attribute;\n\n  # Didn't found an entry:\n  return $self->_unknown_attribute($name,$class) unless ref($entry);\n\n  my $type = $entry->[ ATTR_TYPE_SLOT ] || ATTR_STRING;\n\n  my $val;\n\n  ###########################################################################\n  # Check the object directly first\n  my $a = $self->{att};\n  if (exists $a->{graph})\n    {\n    # for graphs, look directly in the class to save time:\n    $val = $a->{graph}->{$name} \n\tif exists $a->{graph}->{$name};\n    }\n  else\n    {\n    $val = $a->{$name} if exists $a->{$name};\n    }\n\n  # For \"background\", and objects that are in a group, we inherit \"fill\":\n  $val = $self->{group}->color_attribute('fill')\n    if $name eq 'background' && ref $self->{group};\n\n  return $val if !defined $val || $val ne 'inherit' ||\n    $name =~ /^x-([a-z_]+-)*[a-z_]+([0-9]*)\\z/;\n\n  # $val is defined, and \"inherit\" (and it is not a special attribute)\n\n  # for graphs, there is nothing to inherit from\n  return $val if $class eq 'graph';\n\n  # we try classes in this order:\n  # \"node\", \"graph\"\n\n  my @tries = ();\n  # if the class is already \"node\", skip it:\n  if ($class =~ /\\./)\n    {\n    my $parent_class = $class; $parent_class =~ s/\\..*//;\n    push @tries, $parent_class;\n    }\n\n  # If not part of a graph, we cannot have class attributes, but\n  # we still can find default attributes. So fake a \"graph\":\n  my $g = $self->{graph}; \t\t\t# for objects in a graph\n  $g = { att => {} } unless ref($g);\t\t# for objects not in a graph\n\n  $val = undef;\n  for my $try (@tries)\n    {\n#    print STDERR \"# Trying class $try for attribute $name\\n\";\n\n    my $att = $g->{att}->{$try};\n\n    $val = $att->{$name} if exists $att->{$name};\n\n    # value was not defined, so get the default value\n    if (!defined $val)\n      {\n      my $def = $entry->[ ATTR_DEFAULT_SLOT ]; $val = $def;\n\n      # \"node.subclass\" gets the default from \"node\", 'edge' from 'default':\n      # \" { default => 'foo', 'node.anon' => 'none', node => 'solid' }\":\n      if (ref $def)\n\t{\n\t$val = $def->{$try};\n        if (!defined $val && $try =~ /\\./)\n\t  {\n\t  my $base = $try; $base =~ s/\\..*//;\n\t  $val = $def->{$base};\n\t  }\n\t$val = $def->{default} unless defined $val;\n\t}\n      }\n    # $val must now be defined, because default value must exist.\n\n#    print STDERR \"# Found '$val' for $try\\n\";\n\n    if ($name ne 'label')\n      {\n      $self->warn(\"Uninitialized default for attribute '$name' on class '$try'\\n\")\n        unless defined $val;\n      }\n\n    return $val if $type >= ATTR_NO_INHERIT;\n\n    # got some value other than inherit or already at top of tree:\n    return $val if defined $val && $val ne 'inherit';\n  \n    # try next class in inheritance tree\n    $val = undef;\n    }\n\n  $val;\n  }\n\nsub color_attribute\n  {\n  # Just like get_attribute(), but for colors, and returns them as hex,\n  # using the current colorscheme.\n  my $self = shift;\n\n  my $color = $self->attribute(@_);\n\n  if ($color !~ /^#/ && $color ne '')\n    {\n    my $scheme = $self->attribute('colorscheme');\n    $color = Graph::Easy->color_as_hex($color, $scheme);\n    }\n\n  $color;\n  }\n\nsub raw_color_attribute\n  {\n  # Just like raw_attribute(), but for colors, and returns them as hex,\n  # using the current colorscheme.\n  my $self = shift;\n\n  my $color = $self->raw_attribute(@_);\n  return undef unless defined $color;\t\t# default to undef\n\n  if ($color !~ /^#/ && $color ne '')\n    {\n    my $scheme = $self->attribute('colorscheme');\n    $color = Graph::Easy->color_as_hex($color, $scheme);\n    }\n\n  $color;\n  }\n\nsub _attribute_entry\n  {\n  # return the entry defining an attribute, based on the attribute name\n  my ($self, $class, $name) = @_;\n\n  # font-size => fontsize\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  my $base_class = $class; $base_class =~ s/\\.(.*)//;\n\n  # prevent ->{special}->{node} from springing into existance\n  my $s = $attributes->{special}; $s = $s->{$class} if exists $s->{$class};\n  my $entry =\t$s->{$name} ||\n\t\t$attributes->{all}->{$name} ||\n\t\t$attributes->{$base_class}->{$name};\n\n  $entry;\n  }\n\nsub attribute\n  {\n  my ($self, $class, $name) = @_;\n\n  my $three_arg = 0;\n  if (scalar @_ == 3)\n    {\n    # $self->attribute($class,$name) if only allowed on graphs\n    return $self->error(\"Calling $self->attribute($class,$name) only allowed for graphs\") \n      if exists $self->{graph};\n  \n   if ($class !~ /^(node|group|edge|graph\\z)/)\n      {\n      return $self->error (\"Illegal class '$class' when trying to get attribute '$name'\");\n      }\n    $three_arg = 1;\n    return $self->border_attribute($class) if $name eq 'border'; # virtual attribute\n    }\n  else\n    {\n    # allow calls of the style get_attribute('background');\n    $name = $class;\n    $class = $self->{class} || 'graph' if $name eq 'class';\t# avoid deep recursion\n    if ($name ne 'class')\n      {\n      $class = $self->{cache}->{class};\n      $class = $self->class() unless defined $class;\n      }\n\n    return $self->border_attribute() if $name eq 'border'; # virtual attribute\n    return join (\",\",$self->size()) if $name eq 'size'; # virtual attribute\n    }\n\n#  print STDERR \"# called attribute($class,$name)\\n\";\n\n  # font-size => fontsize\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n    \n  my $base_class = $class; $base_class =~ s/\\.(.*)//;\n  my $sub_class = $1; $sub_class = '' unless defined $sub_class;\n  if ($name eq 'class')\n    {\n    # \"[A] { class: red; }\" => \"red\"\n    return $sub_class if $sub_class ne '';\n    # \"node { class: green; } [A]\" => \"green\": fall through and let the code\n    # below look up the attribute or fall back to the default '':\n    }\n\n  # prevent ->{special}->{node} from springing into existance\n  my $s = $attributes->{special}; $s = $s->{$class} if exists $s->{$class};\n  my $entry =\t$s->{$name} ||\n\t\t$attributes->{all}->{$name} ||\n\t\t$attributes->{$base_class}->{$name};\n\n  # create a fake entry for custom attributes\n  $entry = [ '', undef, '', '', ATTR_STRING, '' ]\n    if $name =~ $qr_custom_attribute;\n\n  # Didn't found an entry:\n  return $self->_unknown_attribute($name,$class) unless ref($entry);\n\n  my $type = $entry->[ ATTR_TYPE_SLOT ] || ATTR_STRING;\n\n  my $val;\n\n  if ($three_arg == 0)\n    {\n    ###########################################################################\n    # Check the object directly first\n    my $a = $self->{att};\n    if (exists $a->{graph})\n      {\n      # for graphs, look directly in the class to save time:\n      $val = $a->{graph}->{$name} \n\tif exists $a->{graph}->{$name};\n      }\n    else\n      {\n      $val = $a->{$name} if exists $a->{$name};\n      }\n\n    # For \"background\", and objects that are in a group, we inherit \"fill\":\n    if ($name eq 'background' && $val && $val eq 'inherit')\n      {\n      my $parent = $self->parent();\n      $val = $parent->color_attribute('fill') if $parent && $parent != $self;\n      }\n\n    # XXX BENCHMARK THIS\n    return $val if defined $val && \n\t# no inheritance (\"inherit\" is just a normal string value)\n\t($type >= ATTR_NO_INHERIT ||\n\t# no inheritance since value is something else like \"red\"\n\t $val ne 'inherit' ||\n\t# for graphs, there is nothing to inherit from\n\t $class eq 'graph'); \n    }\n\n  # $val not defined, or 'inherit'\n\n  ###########################################################################\n  # Check the classes now\n\n#  print STDERR \"# Called self->attribute($class,$name) (#2)\\n\";\n\n  # we try them in this order:\n  # node.subclass, node, graph\n\n#  print STDERR \"# $self->{name} class=$class \", join(\" \", caller),\"\\n\" if $name eq 'align';\n\n  my @tries = ();\n  # skip \"node.foo\" if value is 'inherit'\n  push @tries, $class unless defined $val;\n  push @tries, $base_class if $class =~ /\\./;\n  push @tries, 'graph' unless @tries && $tries[-1] eq 'graph';\n\n  # If not part of a graph, we cannot have class attributes, but\n  # we still can find default attributes. So fake a \"graph\":\n  my $g = $self->{graph}; \t\t\t# for objects in a graph\n  $g = { att => {} } unless ref($g);\t\t# for objects not in a graph\n\n  # XXX TODO should not happen\n  $g = $self if $self->{class} eq 'graph';\t# for the graph itself\n\n  $val = undef;\n  TRY:\n   for my $try (@tries)\n    {\n#    print STDERR \"# Trying class $try for attribute $name\\n\" if $name eq 'align';\n\n    my $att = $g->{att}->{$try};\n\n    $val = $att->{$name} if exists $att->{$name};\n\n    # value was not defined, so get the default value (but not for subclasses!)\n    if (!defined $val)\n      {\n      my $def = $entry->[ ATTR_DEFAULT_SLOT ]; $val = $def;\n\n      # \"node.subclass\" gets the default from \"node\", 'edge' from 'default':\n      # \" { default => 'foo', 'node.anon' => 'none', node => 'solid' }\":\n      if (ref $def)\n\t{\n\t$val = $def->{$try};\n        if (!defined $val && $try =~ /\\./)\n\t  {\n\t  my $base = $try; $base =~ s/\\..*//;\n\t  $val = $def->{$base};\n\t  }\n        # if this is not a subclass, get the default value\n        next TRY if !defined $val && $try =~ /\\./;\n        \n\t$val = $def->{default} unless defined $val;\n\t}\n      }\n    # $val must now be defined, because default value must exist.\n\n#    print STDERR \"# Found '$val' for $try ($class)\\n\" if $name eq 'color';\n\n    if ($name ne 'label')\n      {\n      $self->warn(\"Uninitialized default for attribute '$name' on class '$try'\\n\")\n        unless defined $val;\n      }\n\n    return $val if $type >= ATTR_NO_INHERIT;\n\n    # got some value other than inherit or already at top of tree:\n    last if defined $val && ($val ne 'inherit' || $try eq 'graph');\n\n    # try next class in inheritance tree\n    $val = undef;\n    }\n\n  # For \"background\", and objects that are in a group, we inherit \"fill\":\n  if ($name eq 'background' && $val && $val eq 'inherit')\n    {\n    my $parent = $self->parent();\n    $val = $parent->color_attribute('fill') if $parent && $parent != $self;\n    }\n\n  # If we fell through here, $val is 'inherit' for graph. That happens\n  # for instance for 'background':\n  $val;\n  }\n\nsub unquote_attribute\n  {\n  # The parser leaves quotes and escapes in the attribute, these things\n  # are only removed upon storing the attribute at the object/class.\n  # Return the attribute unquoted (remove quotes on labels, links etc).\n  my ($self,$class,$name,$val) = @_;\n\n  # clean quoted strings\n  # XXX TODO\n  # $val =~ s/^[\"'](.*[^\\\\])[\"']\\z/$1/;\n  $val =~ s/^[\"'](.*)[\"']\\z/$1/;\n\n  $val =~ s/\\\\([#\"';\\\\])/$1/g;\t\t# reverse backslashed chars\n\n  # remove any %00-%1f, %7f and high-bit chars to avoid exploits and problems\n  $val =~ s/%[^2-7][a-fA-F0-9]|%7f//g;\n\n  # decode %XX entities\n  $val =~ s/%([2-7][a-fA-F0-9])/sprintf(\"%c\",hex($1))/eg;\n\n  $val;\n  }\n\nsub valid_attribute\n  {\n  # Only for compatibility, use validate_attribute()!\n\n  # Check that an name/value pair is an valid attribute, returns:\n  # scalar value:\tvalid, new attribute\n  # undef:\t \tnot valid\n  # []:\t\t\tunknown attribute (might also warn)\n  my ($self, $name, $value, $class) = @_;\n\n  my ($error,$newname,$v) = $self->validate_attribute($name,$value,$class);\n\n  return [] if defined $error && $error == 1;\n  return undef if defined $error && $error == 2;\n  $v;\n  }\n\nsub validate_attribute\n  {\n  # Check that an name/value pair is an valid attribute, returns:\n  # $error, $newname, @values\n\n  # A possible new name is in $newname, this is f.i. used to convert\n  # \"font-size\" # to \"fontsize\".\n\n  # Upon errors, $error contains the error code:\n  # undef:\t \tall went well\n  # 1\t\t\tunknown attribute name\n  # 2\t\t\tinvalid attribute value \n  # 4\t\t\tfound multiple attributes, but these aren't\n  #\t\t\tallowed at this place\n\n  my ($self, $name, $value, $class, $no_multiples) = @_;\n\n  $self->error(\"Got reference $value as value, but expected scalar\") if ref($value);\n  $self->error(\"Got reference $name as name, but expected scalar\") if ref($name);\n\n  # \"x-foo-bar\" is a custom attribute, so allow it always. The name must\n  # consist only of letters and hyphens, and end in a letter. Hyphens\n  # must be separated by letters.\n  return (undef, $name, $value) if $name =~ $qr_custom_attribute;\n\n  $class = 'all' unless defined $class;\n  $class =~ s/\\..*\\z//;\t\t# remove subclasses\n\n  # Remap alias names without \"-\" to their hyphenated version:\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  # prevent ->{special}->{node} from springing into existance\n  my $s = $attributes->{special}; $s = $s->{$class} if exists $s->{$class};\n\n  my $entry = $s->{$name} ||\n\t      $attributes->{all}->{$name} || $attributes->{$class}->{$name};\n\n  # Didn't found an entry:\n  return (1,undef,$self->_unknown_attribute($name,$class)) unless ref($entry);\n\n  my $check = $entry->[ATTR_MATCH_SLOT];\n  my $type = $entry->[ATTR_TYPE_SLOT] || ATTR_STRING;\n\n  $check = '_color' if $type == ATTR_COLOR;\n  $check = '_angle' if $type == ATTR_ANGLE;\n  $check = '_uint' if $type == ATTR_UINT;\n\n  my @values = ($value);\n\n  # split on \"|\", but not on \"\\|\"\n  # XXX TODO:\n  # This will not work in case of mixed \" $i \\|\\| 0| $a = 1;\"\n\n  # When special attributes are set, we are parsing Graphviz, and do\n  # not allow/use multiple attributes. So skip the split.\n  if (keys %{$attributes->{special}} == 0)\n     {\n     @values = split (/\\s*\\|\\s*/, $value, -1) if $value =~ /(^|[^\\\\])\\|/;\n     }\n\n  my $multiples = 0; $multiples = 1 if @values > 1;\n  return (4) if $no_multiples && $multiples; \t\t# | and no multiples => error\n\n  # check each part on it's own\n  my @rc;\n  for my $v (@values)\n    {\n    # don't check empty parts for being valid\n    push @rc, undef and next if $multiples && $v eq '';\n\n    if (defined $check && !ref($check))\n      {\n      no strict 'refs';\n      my $checked = $self->$check($v, $name);\n      if (!defined $checked)\n\t{\n        $self->error(\"Error in attribute: '$v' is not a valid $name for a $class\");\n        return (2);\n        }\n      push @rc, $checked;\n      }\n    elsif ($check)\n      {\n      if (ref($check) eq 'ARRAY')\n        {\n        # build a regexp from the list of words\n        my $list = 'qr/^(' . join ('|', @$check) . ')\\z/;';\n        $entry->[1] = eval($list);\n        $check = $entry->[1];\n        }\n      if ($v !~ $check)\t\t\t\t# invalid?\n\t{\n        $self->error(\"Error in attribute: '$v' is not a valid $name for a $class\");\n\treturn (2);\n\t}\n\n      push @rc, $v;\t\t\t\t# valid\n      }\n    # entry found, but no specific check => anything goes as value\n    else { push @rc, $v; }\n\n    # \"ClAss\" => \"class\" for LCTEXT entries\n    $rc[-1] = lc($rc[-1]) if $type == ATTR_LCTEXT;\n    }\n\n  # only one value ('green')\n  return (undef, $name, $rc[0]) unless $multiples;\n\n  # multiple values ('green|red')\n  (undef, $name, \\@rc);\n  }\n\n###########################################################################\n###########################################################################\n\nsub _remap_attributes\n  {\n  # Take a hash with:\n  # {\n  #   class => {\n  #     color => 'red'\n  #   }\n  # }\n  # and remap it according to the given remap hash (similiar structured).\n  # Also encode/quote the value. Suppresses default attributes.\n  my ($self, $object, $att, $remap, $noquote, $encode, $color_remap ) = @_;\n\n  my $out = {};\n\n  my $class = $object || 'node';\n  $class = $object->{class} || 'graph' if ref($object);\n  $class =~ s/\\..*//;\t\t\t\t# remove subclass\n\n  my $r = $remap->{$class};\n  my $ra = $remap->{all};\n  my $ral = $remap->{always};\n  my $x = $remap->{x};\n\n  # This loop does also handle the individual \"bordercolor\" attributes.\n  # If the output should contain only \"border\", but not \"bordercolor\", then\n  # the caller must filter them out.\n\n  # do these attributes\n  my @keys = keys %$att;\n\n  my $color_scheme = 'w3c';\n  $color_scheme = $object->attribute('colorscheme') if ref($object);\n  $color_scheme = $self->get_attribute($object,'colorscheme')\n    if defined $object && !ref($object);\n\n  $color_scheme = $self->get_attribute('graph','colorscheme')\n    if defined $color_scheme && $color_scheme eq 'inherit';\n\n  for my $atr (@keys)\n    {\n    my $val = $att->{$atr};\n\n    # Only for objects (not for classes like \"node\"), and not if\n    # always says we need to always call the CODE handler:\n\n    if (!ref($object) && !exists $ral->{$atr})\n      {\n      # attribute not defined\n      next if !defined $val || $val eq '' ||\n      # or $remap says we should suppress it\n         (exists $r->{$atr} && !defined $r->{$atr}) ||\n         (exists $ra->{$atr} && !defined $ra->{$atr});\n      }\n\n    my $entry = $attributes->{all}->{$atr} || $attributes->{$class}->{$atr};\n\n    if ($color_remap && defined $entry && defined $val)\n      {\n      # look up whether attribute is a color\n      # if yes, convert to hex\n      $val = $self->color_as_hex($val,$color_scheme)\n        if ($entry->[ ATTR_TYPE_SLOT ]||ATTR_STRING) == ATTR_COLOR;\n      }\n\n    my $temp = { $atr => $val };\n\n    # see if there is a handler for custom attributes\n    if (exists $r->{$atr} || exists $ra->{$atr} || (defined $x && $atr =~ /^x-/))\n      {\n      my $rc = $r->{$atr}; $rc = $ra->{$atr} unless defined $rc;\n      $rc = $x unless defined $rc;\n\n      # if given a code ref, call it to remap name and/or value\n      if (ref($rc) eq 'CODE')\n        {\n        my @rc = &{$rc}($self,$atr,$val,$object);\n        $temp = {};\n        while (@rc)\n          {\n          my $a = shift @rc; my $v = shift @rc;\n          $temp->{ $a } = $v if defined $a && defined $v;\n          }\n        }\n      else\n        {\n        # otherwise, rename the attribute name if nec.\n        $temp = { };\n        $temp = { $rc => $val } if defined $val && defined $rc;\n        }\n      }\n\n    for my $at (keys %$temp)\n      {\n      my $v = $temp->{$at};\n\n      next if !defined $at || !defined $v || $v eq '';\n\n      # encode critical characters (including \"), but only if the value actually\n      # contains anything else than '%' (so rgb(10%,0,0) stays as it is)\n\n      $v =~ s/([;\"%\\x00-\\x1f])/sprintf(\"%%%02x\",ord($1))/eg \n        if $encode && $v =~ /[;\"\\x00-\\x1f]/;\n      # quote if nec.\n      $v = '\"' . $v . '\"' unless $noquote;\n\n      $out->{$at} = $v;\n      }\n    }\n\n  $out;\n  }\n\nsub raw_attributes\n  {\n  # return all set attributes on this object (graph/node/group/edge) as\n  # an anonymous hash ref\n  my $self = shift;\n\n  my $class = $self->{class} || 'graph';\n\n  my $att = $self->{att};\n  $att = $self->{att}->{graph} if $class eq 'graph';\n\n  my $g = $self->{graph} || $self;\n\n  my $out = {};\n  if (!$g->{strict})\n    {\n    for my $name (keys %$att)\n      {\n      my $val = $att->{$name};\n      next unless defined $val;\t\t\t# set to undef?\n\n      $out->{$name} = $val;\n      }\n    return $out;\n    }\n\n  my $base_class = $class; $base_class =~ s/\\..*//;\n  for my $name (keys %$att)\n    {\n    my $val = $att->{$name};\n    next unless defined $val;\t\t\t# set to undef?\n\n    $out->{$name} = $val;\n \n    next unless $val eq 'inherit';\n \n    # prevent ->{special}->{node} from springing into existance\n    my $s = $attributes->{special}; $s = $s->{$class} if exists $s->{$class};\n    my $entry =\t$s->{$name} ||\n\t\t$attributes->{all}->{$name} ||\n\t\t$attributes->{$base_class}->{$name};\n\n    # Didn't found an entry:\n    return $self->_unknown_attribute($name,$class) unless ref($entry);\n  \n    my $type = $entry->[ ATTR_TYPE_SLOT ] || ATTR_STRING;\n\n    # need to inherit value?\n    $out->{$name} = $self->attribute($name) if $type < ATTR_NO_INHERIT;\n    }\n\n  $out;\n  }\n\nsub get_attributes\n  {\n  # Return all effective attributes on this object (graph/node/group/edge) as\n  # an anonymous hash ref. This respects inheritance and default values.\n  # Does not return custom attributes, see get_custom_attributes().\n  my $self = shift;\n\n  $self->error(\"get_attributes() doesn't take arguments\") if @_ > 0;\n\n  my $att = {};\n  my $class = $self->main_class();\n\n  # f.i. \"all\", \"node\"\n  for my $type ('all', $class)\n    {\n    for my $a (keys %{$attributes->{$type}})\n      {\n      my $val = $self->attribute($a);\t\t# respect inheritance\t\n      $att->{$a} = $val if defined $val;\n      }\n    }\n\n  $att;\n  }\n\npackage Graph::Easy::Node;\n\nBEGIN\n  {\n  *custom_attributes = \\&get_custom_attributes;\n  }\n\nsub get_custom_attributes\n  {\n  # Return all custom attributes on this object (graph/node/group/edge) as\n  # an anonymous hash ref.\n  my $self = shift;\n\n  $self->error(\"get_custom_attributes() doesn't take arguments\") if @_ > 0;\n\n  my $att = {};\n\n  for my $key (keys %{$self->{att}})\n    {\n    $att->{$key} = $self->{att}->{$key};\n    }\n\n  $att;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Attributes - Define and check attributes for Graph::Easy\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\n\tmy $graph = Graph::Easy->new();\n\n\tmy $hexred = Graph::Easy->color_as_hex( 'red' );\n\tmy ($name, $value) = $graph->valid_attribute( 'color', 'red', 'graph' );\n\tprint \"$name => $value\\n\" if !ref($value);\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Attributes> contains the definitions of valid attribute names\nand values for L<Graph::Easy|Graph::Easy>. It is used by both the parser\nand by Graph::Easy to check attributes for being valid and well-formed. \n\nThere should be no need to use this module directly.\n\nFor a complete list of attributes and their possible values, please see\nL<Graph::Easy::Manual>.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Base.pm": "#############################################################################\n# A baseclass for Graph::Easy objects like nodes, edges etc.\n#\n#############################################################################\n\npackage Graph::Easy::Base;\n\n$VERSION = '0.12';\n\nuse strict;\n\n#############################################################################\n\n{\n  # protected vars\n  my $id = 0;\n  sub _new_id { $id++; }\n  sub _reset_id { $id = 0; }\n}\n\n#############################################################################\n\nsub new\n  {\n  # Create a new object. This is a generic routine that is inherited\n  # by many other things like Edge, Cell etc.\n  my $self = bless { id => _new_id() }, shift;\n\n  my $args = $_[0];\n  $args = { name => $_[0] } if ref($args) ne 'HASH' && @_ == 1;\n  $args = { @_ } if ref($args) ne 'HASH' && @_ > 1;\n \n  $self->_init($args);\n  }\n\nsub _init\n  {\n  # Generic init routine, to be overriden in subclasses.\n  my ($self,$args) = @_;\n  \n  $self;\n  }\n\nsub self\n  {\n  my $self = shift;\n  \n  $self;\n  }  \n\n#############################################################################\n\nsub no_fatal_errors\n  {\n  my $self = shift;\n\n  $self->{fatal_errors} = ($_[1] ? 1 : 0) if @_ > 0;\n\n  ~ ($self->{fatal_errors} || 0);\n  }\n\nsub fatal_errors\n  {\n  my $self = shift;\n\n  $self->{fatal_errors} = ($_[1] ? 0 : 1) if @_ > 0;\n\n  $self->{fatal_errors} || 0;\n  }\n\nsub error\n  {\n  my $self = shift;\n\n  # If we switched to a temp. Graphviz parser, then set the error on the\n  # original parser object, too:\n  $self->{_old_self}->error(@_) if ref($self->{_old_self});\n\n  # if called on a member on a graph, call error() on the graph itself:\n  return $self->{graph}->error(@_) if ref($self->{graph});\n\n  if (defined $_[0])\n    {\n    $self->{error} = $_[0];\n    if ($self->{_catch_errors})\n      {\n      push @{$self->{_errors}}, $self->{error};\n      }\n    else\n      {\n      $self->_croak($self->{error}, 2)\n        if ($self->{fatal_errors}) && $self->{error} ne '';\n      }\n    }\n  $self->{error} || '';\n  }\n\nsub error_as_html\n  {\n  # return error() properly escaped\n  my $self = shift;\n\n  my $msg = $self->{error};\n\n  $msg =~ s/&/&amp;/g;\n  $msg =~ s/</&lt;/g;\n  $msg =~ s/>/&gt;/g;\n  $msg =~ s/\"/&quot;/g;\n\n  $msg; \n  }\n\nsub catch_messages\n  {\n  # Catch all warnings (and errors if no_fatal_errors() was used)\n  # these can later be retrieved with warnings() and errors():\n  my $self = shift;\n\n  if (@_ > 0)\n    {\n    if ($_[0])\n      {\n      $self->{_catch_warnings} = 1;\n      $self->{_catch_errors} = 1;\n      $self->{_warnings} = [];\n      $self->{_errors} = [];\n      }\n    else\n      {\n      $self->{_catch_warnings} = 0;\n      $self->{_catch_errors} = 0;\n      }\n    }\n  $self;\n  }\n\nsub catch_warnings\n  {\n  # Catch all warnings\n  # these can later be retrieved with warnings():\n  my $self = shift;\n\n  if (@_ > 0)\n    {\n    if ($_[0])\n      {\n      $self->{_catch_warnings} = 1;\n      $self->{_warnings} = [];\n      }\n    else\n      {\n      $self->{_catch_warnings} = 0;\n      }\n    }\n  $self->{_catch_warnings};\n  }\n\nsub catch_errors\n  {\n  # Catch all errors\n  # these can later be retrieved with errors():\n  my $self = shift;\n\n  if (@_ > 0)\n    {\n    if ($_[0])\n      {\n      $self->{_catch_errors} = 1;\n      $self->{_errors} = [];\n      }\n    else\n      {\n      $self->{_catch_errors} = 0;\n      }\n    }\n  $self->{_catch_errors};\n  }\n\nsub warnings\n  {\n  # return all warnings that occured after catch_messages(1)\n  my $self = shift;\n\n  @{$self->{_warnings}};\n  }\n\nsub errors\n  {\n  # return all errors that occured after catch_messages(1)\n  my $self = shift;\n\n  @{$self->{_errors}};\n  }\n\nsub warn\n  {\n  my ($self, $msg) = @_;\n\n  if ($self->{_catch_warnings})\n    {\n    push @{$self->{_warnings}}, $msg;\n    }\n  else\n    {\n    require Carp;\n    Carp::carp('Warning: ' . $msg);\n    }\n  }\n\nsub _croak\n  {\n  my ($self, $msg, $level) = @_;\n  $level = 1 unless defined $level;\n\n  require Carp;\n  if (ref($self) && $self->{debug})\n    {\n    $Carp::CarpLevel = $level;\t\t\t# don't report Base itself\n    Carp::confess($msg);\n    }\n  else\n    {\n    Carp::croak($msg);\n    }\n  }\n \n#############################################################################\n# class management\n\nsub sub_class\n  {\n  # get/set the subclass\n  my $self = shift;\n\n  if (defined $_[0])\n    {\n    $self->{class} =~ s/\\..*//;\t\t# nix subclass\n    $self->{class} .= '.' . $_[0];\t# append new one\n    delete $self->{cache};\n    $self->{cache}->{subclass} = $_[0];\n    $self->{cache}->{class} = $self->{class};\n    return;\n    }\n  $self->{class} =~ /\\.(.*)/;\n\n  return $1 if defined $1;\n\n  return $self->{cache}->{subclass} if defined $self->{cache}->{subclass}; \n\n  # Subclass not defined, so check our base class for a possible set class\n  # attribute and return this:\n\n  # take a shortcut\n  my $g = $self->{graph};\n  if (defined $g)\n    {\n    my $subclass = $g->{att}->{$self->{class}}->{class};\n    $subclass = '' unless defined $subclass;\n    $self->{cache}->{subclass} = $subclass;\n    $self->{cache}->{class} = $self->{class};\n    return $subclass;\n    }\n\n  # not part of a graph?\n  $self->{cache}->{subclass} = $self->attribute('class');\n  }\n\nsub class\n  {\n  # return our full class name like \"node.subclass\" or \"node\"\n  my $self = shift;\n\n  $self->error(\"class() method does not take arguments\") if @_ > 0;\n\n  $self->{class} =~ /\\.(.*)/;\n\n  return $self->{class} if defined $1;\n\n  return $self->{cache}->{class} if defined $self->{cache}->{class};\n\n  # Subclass not defined, so check our base class for a possible set class\n  # attribute and return this:\n\n  my $subclass;\n  # take a shortcut:\n  my $g = $self->{graph};\n  if (defined $g)\n    {\n    $subclass = $g->{att}->{$self->{class}}->{class};\n    $subclass = '' unless defined $subclass;\n    }\n\n  $subclass = $self->{att}->{class} unless defined $subclass;\n  $subclass = '' unless defined $subclass;\n  $self->{cache}->{subclass} = $subclass;\n  $subclass = '.' . $subclass if $subclass ne '';\n\n  $self->{cache}->{class} = $self->{class} . $subclass;\n  }\n\nsub main_class\n  {\n  my $self = shift;\n\n  $self->{class} =~ /^(.+?)(\\.|\\z)/;\t# extract first part\n\n  $1;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Base - base class for Graph::Easy objects like nodes, edges etc\n\n=head1 SYNOPSIS\n\n\tpackage Graph::Easy::My::Node;\n\tuse Graph::Easy::Base;\n\t@ISA = qw/Graph::Easy::Base/;\n\n=head1 DESCRIPTION\n\nUsed automatically and internally by L<Graph::Easy> - should not be used\ndirectly.\n\n=head1 METHODS\n\n=head2 new()\n\n\tmy $object = Graph::Easy::Base->new();\n\nCreate a new object, and call C<_init()> on it.\n\n=head2 error()\n\n\t$last_error = $object->error();\n\n\t$object->error($error);\t\t\t# set new messags\n\t$object->error('');\t\t\t# clear the error\n\nReturns the last error message, or '' for no error.\n\nWhen setting a new error message, C<< $self->_croak($error) >> will be called\nunless C<< $object->no_fatal_errors() >> is true.\n\n=head2 error_as_html()\n\n\tmy $error = $object->error_as_html();\n\nReturns the same error message as L<error()>, but properly escaped\nas HTML so it is safe to output to the client.\n\n=head2 warn()\n\n\t$object->warn('Warning!');\n\nWarn on STDERR with the given message.\n\n=head2 no_fatal_errors()\n\n\t$object->no_fatal_errors(1);\n\nSet the flag that determines whether setting an error message\nvia C<error()> is fatal, e.g. results in a call to C<_croak()>.\n\nA true value will make errors non-fatal. See also L<fatal_errors>.\n\n=head2 fatal_errors()\n\n\t$fatal = $object->fatal_errors();\n\t$object->fatal_errors(0);\t\t# turn off\n\t$object->fatal_errors(1);\t\t# turn on\n\nSet/get the flag that determines whether setting an error message\nvia C<error()> is fatal, e.g. results in a call to C<_croak()>.\n\nA true value makes errors fatal.\n\n=head2 catch_errors()\n\n\tmy $catch_errors = $object->catch_errors();\t# query\n\t$object->catch_errors(1);\t\t\t# enable\n\n\t$object->...();\t\t\t\t\t# some error\n\tif ($object->error())\n\t  {\n\t  my @errors = $object->errors();\t\t# retrieve\n\t  }\n\nEnable/disable catching of all error messages. When enabled,\nall previously caught error messages are thrown away, and from this\npoin on new errors are non-fatal and stored internally. You can\nretrieve these errors later with the errors() method.\n\n=head2 catch_warnings()\n\n\tmy $catch_warns = $object->catch_warnings();\t# query\n\t$object->catch_warnings(1);\t\t\t# enable\n\n\t$object->...();\t\t\t\t\t# some error\n\tif ($object->warning())\n\t  {\n\t  my @warnings = $object->warnings();\t\t# retrieve\n\t  }\n\nEnable/disable catching of all warnings. When enabled, all previously\ncaught warning messages are thrown away, and from this poin on new\nwarnings are stored internally. You can retrieve these errors later\nwith the errors() method.\n\n=head2 catch_messages()\n\n\t# catch errors and warnings\n\t$object->catch_messages(1);\n\t# stop catching errors and warnings\n\t$object->catch_messages(0);\n\nA true parameter is equivalent to:\n\n\t$object->catch_warnings(1);\n\t$object->catch_errors(1);\n\t\nSee also: L<catch_warnings()> and L<catch_errors()> as well as\nL<errors()> and L<warnings()>.\n\n=head2 errors()\n\n\tmy @errors = $object->errors();\n\nReturn all error messages that occured after L<catch_messages()> was\ncalled.\n\n=head2 warnings()\n\n\tmy @warnings = $object->warnings();\n\nReturn all warning messages that occured after L<catch_messages()>\nor L<catch_errors()> was called.\n\n=head2 self()\n\n\tmy $self = $object->self();\n\nReturns the object itself.\n\n=head2 class()\n\n\tmy $class = $object->class();\n\nReturns the full class name like C<node.cities>. See also C<sub_class>.\n\n=head2 sub_class()\n\n\tmy $sub_class = $object->sub_class();\n\nReturns the sub class name like C<cities>. See also C<class>.\n\n=head2 main_class()\n\n\tmy $main_class = $object->main_class();\n\nReturns the main class name like C<node>. See also C<sub_class>.\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\nX<tels>\nX<bloodgate>\nX<license>\nX<gpl>\n\n=cut\n",
  "Graph/Easy/Edge/Cell.pm": "#############################################################################\n# Part of Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Edge::Cell;\n\nuse strict;\nuse Graph::Easy::Edge;\nuse Graph::Easy::Attributes;\nrequire Exporter;\n\nuse vars qw/$VERSION @EXPORT_OK @ISA/;\n@ISA = qw/Exporter Graph::Easy::Edge/;\n\n$VERSION = '0.29';\n\nuse Scalar::Util qw/weaken/;\n\n#############################################################################\n\n# The different cell types:\nuse constant {\n  EDGE_CROSS\t=> 0,\t\t# +\tcrossing lines\n  EDGE_HOR\t=> 1,\t \t# --\thorizontal line\n  EDGE_VER\t=> 2,\t \t# |\tvertical line\n\n  EDGE_N_E\t=> 3,\t\t# |_\tcorner (N to E)\n  EDGE_N_W\t=> 4,\t\t# _|\tcorner (N to W)\n  EDGE_S_E\t=> 5,\t\t# ,-\tcorner (S to E)\n  EDGE_S_W\t=> 6,\t\t# -,\tcorner (S to W)\n\n# Joints:\n  EDGE_S_E_W\t=> 7,\t\t# -,-\tthree-sided corner (S to W/E)\n  EDGE_N_E_W\t=> 8,\t\t# -'-\tthree-sided corner (N to W/E)\n  EDGE_E_N_S\t=> 9,\t\t#  |-   three-sided corner (E to S/N)\n  EDGE_W_N_S\t=> 10,\t\t# -|\tthree-sided corner (W to S/N)\n\n  EDGE_HOLE\t=> 11,\t\t# \ta hole (placeholder for the \"other\"\n\t\t\t\t#\tedge in a crossing section\n\t\t\t\t#\tHoles are inserted in the layout stage\n\t\t\t\t#\tand removed in the optimize stage, before\n\t\t\t\t#\trendering occurs.\n\n# these loop types must come last\n  EDGE_N_W_S\t=> 12,\t\t# v--+  loop, northwards\n  EDGE_S_W_N\t=> 13,\t\t# ^--+  loop, southwards\n  EDGE_E_S_W\t=> 14,\t\t# [_    loop, westwards\n  EDGE_W_S_E\t=> 15,\t\t# _]    loop, eastwards\n\n  EDGE_MAX_TYPE\t\t=> 15, \t# last valid type\n  EDGE_LOOP_TYPE\t=> 12, \t# first LOOP type\n\n# Flags:\n  EDGE_START_E\t\t=> 0x0100,\t# start from East\t(sorted ESWN)\n  EDGE_START_S\t\t=> 0x0200,\t# start from South\n  EDGE_START_W\t\t=> 0x0400,\t# start from West\n  EDGE_START_N\t\t=> 0x0800,\t# start from North\n\n  EDGE_END_W\t\t=> 0x0010,\t# end points to West\t(sorted WNES)\n  EDGE_END_N\t\t=> 0x0020,\t# end points to North\n  EDGE_END_E\t\t=> 0x0040,\t# end points to East\n  EDGE_END_S\t\t=> 0x0080,\t# end points to South\n\n  EDGE_LABEL_CELL\t=> 0x1000,\t# this cell carries the label\n  EDGE_SHORT_CELL\t=> 0x2000,\t# a short edge pice (for filling)\n\n  EDGE_ARROW_MASK\t=> 0x0FF0,\t# mask out the end/start type\n  EDGE_START_MASK\t=> 0x0F00,\t# mask out the start type\n  EDGE_END_MASK\t\t=> 0x00F0,\t# mask out the end type\n  EDGE_TYPE_MASK\t=> 0x000F,\t# mask out the basic cell type\n  EDGE_FLAG_MASK\t=> 0xFFF0,\t# mask out the flags\n  EDGE_MISC_MASK\t=> 0xF000,\t# mask out the misc. flags\n  EDGE_NO_M_MASK\t=> 0x0FFF,\t# anything except the misc. flags\n\n  ARROW_RIGHT\t=> 0,\n  ARROW_LEFT\t=> 1,\n  ARROW_UP\t=> 2,\n  ARROW_DOWN\t=> 3,\n  };\n\nuse constant {\n  EDGE_ARROW_HOR\t=> EDGE_END_E() + EDGE_END_W(),\n  EDGE_ARROW_VER\t=> EDGE_END_N() + EDGE_END_S(),\n\n# shortcuts to not need to write EDGE_HOR + EDGE_START_W + EDGE_END_E\n  EDGE_SHORT_E => EDGE_HOR + EDGE_END_E + EDGE_START_W,\t\t# |-> start/end at this cell\n  EDGE_SHORT_S => EDGE_VER + EDGE_END_S + EDGE_START_N,\t\t# v   start/end at this cell\n  EDGE_SHORT_W => EDGE_HOR + EDGE_END_W + EDGE_START_E,\t\t# <-| start/end at this cell\n  EDGE_SHORT_N => EDGE_VER + EDGE_END_N + EDGE_START_S,\t\t# ^   start/end at this cell\n\n  EDGE_SHORT_BD_EW => EDGE_HOR + EDGE_END_E + EDGE_END_W,\t# <-> start/end at this cell\n  EDGE_SHORT_BD_NS => EDGE_VER + EDGE_END_S + EDGE_END_N,\t# ^\n\t\t\t\t\t\t\t\t# | start/end at this cell\n\t\t\t\t\t\t\t\t# v\n  EDGE_SHORT_UN_EW => EDGE_HOR + EDGE_START_E + EDGE_START_W,\t# --\n  EDGE_SHORT_UN_NS => EDGE_VER + EDGE_START_S + EDGE_START_N,   # |\n\n  EDGE_LOOP_NORTH  => EDGE_N_W_S + EDGE_END_S + EDGE_START_N + EDGE_LABEL_CELL,\n  EDGE_LOOP_SOUTH  => EDGE_S_W_N + EDGE_END_N + EDGE_START_S + EDGE_LABEL_CELL,\n  EDGE_LOOP_WEST   => EDGE_W_S_E + EDGE_END_E + EDGE_START_W + EDGE_LABEL_CELL,\n  EDGE_LOOP_EAST   => EDGE_E_S_W + EDGE_END_W + EDGE_START_E + EDGE_LABEL_CELL,\n  };\n\n#############################################################################\n\n@EXPORT_OK = qw/\n  EDGE_START_E\n  EDGE_START_W\n  EDGE_START_N\n  EDGE_START_S\n\n  EDGE_END_E\n  EDGE_END_W\t\n  EDGE_END_N\n  EDGE_END_S\n\n  EDGE_SHORT_E\n  EDGE_SHORT_W\t\n  EDGE_SHORT_N\n  EDGE_SHORT_S\n\n  EDGE_SHORT_BD_EW\n  EDGE_SHORT_BD_NS\n\n  EDGE_SHORT_UN_EW\n  EDGE_SHORT_UN_NS\n\n  EDGE_HOR\n  EDGE_VER\n  EDGE_CROSS\n  EDGE_HOLE\n\n  EDGE_N_E\n  EDGE_N_W\n  EDGE_S_E\n  EDGE_S_W\n\n  EDGE_S_E_W\n  EDGE_N_E_W\n  EDGE_E_N_S\n  EDGE_W_N_S\t\n\n  EDGE_LOOP_NORTH\n  EDGE_LOOP_SOUTH\n  EDGE_LOOP_EAST\n  EDGE_LOOP_WEST\n\n  EDGE_N_W_S\n  EDGE_S_W_N\n  EDGE_E_S_W\n  EDGE_W_S_E\n\n  EDGE_TYPE_MASK\n  EDGE_FLAG_MASK\n  EDGE_ARROW_MASK\n  \n  EDGE_START_MASK\n  EDGE_END_MASK\n  EDGE_MISC_MASK\n\n  EDGE_LABEL_CELL\n  EDGE_SHORT_CELL\n\n  EDGE_NO_M_MASK\n\n  ARROW_RIGHT\n  ARROW_LEFT\n  ARROW_UP\n  ARROW_DOWN\n  /;\n\nmy $edge_types = {\n  EDGE_HOR() => 'horizontal',\n  EDGE_VER() => 'vertical',\n\n  EDGE_CROSS() => 'crossing',\n\n  EDGE_N_E() => 'north/east corner',\n  EDGE_N_W() => 'north/west corner',\n  EDGE_S_E() => 'south/east corner',\n  EDGE_S_W() => 'south/west corner',\n\n  EDGE_S_E_W() => 'joint south to east/west',\n  EDGE_N_E_W() => 'joint north to east/west',\n  EDGE_E_N_S() => 'joint east to north/south',\n  EDGE_W_N_S() => 'joint west to north/south',\n\n  EDGE_N_W_S() => 'selfloop, northwards',\n  EDGE_S_W_N() => 'selfloop, southwards',\n  EDGE_E_S_W() => 'selfloop, eastwards',\n  EDGE_W_S_E() => 'selfloop, westwards',\n  };\n\nmy $flag_types = {\n  EDGE_LABEL_CELL() => 'labeled',\n  EDGE_SHORT_CELL() => 'short',\n\n  EDGE_START_E() => 'starting east',\n  EDGE_START_W() => 'starting west',\n  EDGE_START_N() => 'starting north',\n  EDGE_START_S() => 'starting south',\n\n  EDGE_END_E() => 'ending east',\n  EDGE_END_W() => 'ending west',\n  EDGE_END_N() => 'ending north',\n  EDGE_END_S() => 'ending south',\n  };\n\nuse constant isa_cell => 1;\n\nsub edge_type\n  {\n  # convert edge type number to some descriptive text\n  my $type = shift;\n\n  my $flags = $type & EDGE_FLAG_MASK;\n  $type &= EDGE_TYPE_MASK;\n\n  my $t = $edge_types->{$type} || ('unknown edge type #' . $type);\n\n  $flags &= EDGE_FLAG_MASK;\n\n  my $mask = 0x0010;\n  while ($mask < 0xFFFF)\n    {\n    my $tf = $flags & $mask; $mask <<= 1;\n    $t .= \", $flag_types->{$tf}\" if $tf != 0;\n    }\n\n  $t;\n  }\n\n#############################################################################\n\nsub _init\n  {\n  # generic init, override in subclasses\n  my ($self,$args) = @_;\n  \n  $self->{type} = EDGE_SHORT_E();\t# -->\n  $self->{style} = 'solid';\n  \n  $self->{x} = 0;\n  $self->{y} = 0;\n  $self->{w} = undef;\n  $self->{h} = 3;\n\n  foreach my $k (keys %$args)\n    {\n    # don't store \"after\" and \"before\"\n    next unless $k =~ /^(graph|edge|x|y|type)\\z/;\n    $self->{$k} = $args->{$k};\n    }\n\n  $self->_croak(\"Creating edge cell without a parent edge object\")\n    unless defined $self->{edge};\n  $self->_croak(\"Creating edge cell without a type\")\n    unless defined $self->{type};\n\n  # take over settings from edge\n  $self->{style} = $self->{edge}->style();\n  $self->{class} = $self->{edge}->class();\n  $self->{graph} = $self->{edge}->{graph};\n  $self->{group} = $self->{edge}->{group};\n  weaken($self->{graph});\n  weaken($self->{group});\n  $self->{att} = $self->{edge}->{att};\n\n  # register ourselves at this edge\n  $self->{edge}->_add_cell ($self, $args->{after}, $args->{before});\n\n  $self;\n  }\n\nsub arrow_count\n  {\n  # return 0, 1 or 2, depending on the number of end points\n  my $self = shift;\n\n  return 0 if $self->{edge}->{undirected};\n\n  my $count = 0;\n  my $type = $self->{type};\n  $count ++ if ($type & EDGE_END_N) != 0;\n  $count ++ if ($type & EDGE_END_S) != 0;\n  $count ++ if ($type & EDGE_END_W) != 0;\n  $count ++ if ($type & EDGE_END_E) != 0;\n  if ($self->{edge}->{bidirectional})\n    {\n    $count ++ if ($type & EDGE_START_N) != 0;\n    $count ++ if ($type & EDGE_START_S) != 0;\n    $count ++ if ($type & EDGE_START_W) != 0;\n    $count ++ if ($type & EDGE_START_E) != 0;\n    }\n  $count;\n  }\n\nsub _make_cross\n  {\n  # Upgrade us to a cross-section.\n  my ($self, $edge, $flags) = @_;\n  \n  my $type = $self->{type} & EDGE_TYPE_MASK;\n    \n  $self->_croak(\"Trying to cross non hor/ver piece at $self->{x},$self->{y}\")\n    if (($type != EDGE_HOR) && ($type != EDGE_VER));\n\n  $self->{color} = $self->get_color_attribute('color');\n  $self->{style_ver} = $edge->style();\n  $self->{color_ver} = $edge->get_color_attribute('color');\n\n  # if we are the VER piece, switch styles around\n  if ($type == EDGE_VER)\n    {\n    ($self->{style_ver}, $self->{style}) = ($self->{style},$self->{style_ver});\n    ($self->{color_ver}, $self->{color}) = ($self->{color},$self->{color});\n    }\n\n  $self->{type} = EDGE_CROSS + ($flags || 0);\n\n  $self;\n  }\n\nsub _make_joint\n  {\n  # Upgrade us to a joint\n  my ($self, $edge, $new_type) = @_;\n  \n  my $type = $self->{type} & EDGE_TYPE_MASK;\n\n  $self->_croak(\"Trying to join non hor/ver piece (type: $type) at $self->{x},$self->{y}\")\n     if $type >= EDGE_S_E_W;\n\n  $self->{color} = $self->get_color_attribute('color');\n  $self->{style_ver} = $edge->style();\n  $self->{color_ver} = $edge->get_color_attribute('color');\n\n  # if we are the VER piece, switch styles around\n  if ($type == EDGE_VER)\n    {\n    ($self->{style_ver}, $self->{style}) = ($self->{style},$self->{style_ver});\n    ($self->{color_ver}, $self->{color}) = ($self->{color},$self->{color});\n    }\n\n  print STDERR \"# creating joint at $self->{x}, $self->{y} with new type $new_type (old $type)\\n\"\n    if $self->{graph}->{debug};\n\n  $self->{type} = $new_type;\n\n  $self;\n  }\n\n#############################################################################\n# conversion to HTML\n\nmy $edge_end_north = \n   ' <td colspan=2 class=\"##class## eb\" style=\"##bg####ec##\">&nbsp;</td>' . \"\\n\" .\n   ' <td colspan=2 class=\"##class## eb\" style=\"##bg####ec##\"><span class=\"su\">^</span></td>' . \"\\n\";\nmy $edge_end_south = \n   ' <td colspan=2 class=\"##class## eb\" style=\"##bg####ec##\">&nbsp;</td>' . \"\\n\" .\n   ' <td colspan=2 class=\"##class## eb\" style=\"##bg####ec##\"><span class=\"sv\">v</span></td>' . \"\\n\";\n\nmy $edge_empty_row =\n   ' <td colspan=4 class=\"##class## eb\"></td>';\n\nmy $edge_arrow_west_upper = \n   '<td rowspan=2 class=\"##class## eb\" style=\"##ec####bg##\"><span class=\"shl\">&lt;</span></td>' . \"\\n\";\nmy $edge_arrow_west_lower = \n   '<td rowspan=2 class=\"##class## eb\">&nbsp;</td>' . \"\\n\";\n\nmy $edge_arrow_east_upper = \n   '<td rowspan=2 class=\"##class## eb\" style=\"##ec####bg##\"><span class=\"sh\">&gt;</span></td>' . \"\\n\";\nmy $edge_arrow_east_lower =\n   '<td rowspan=2 class=\"##class## eb\"></td>' . \"\\n\";\n\nmy $edge_html = {\n\n  # The \"&nbsp;\" in empty table cells with borders are here to make IE display\n  # the border. I so hate browser bugs :-(\n\n  EDGE_S_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_E() + EDGE_START_E() + EDGE_END_S() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## el\"></td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    $edge_end_south,\n   ],\n\n  EDGE_S_E() + EDGE_START_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## el\"></td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_E() + EDGE_END_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class##\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_E() + EDGE_START_S() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>' . \"\\n\",\n    $edge_empty_row,\n   ],\n\n  EDGE_S_E() + EDGE_START_S() + EDGE_END_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>'.\n    ' <td rowspan=4 class=\"##class##\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>' . \"\\n\",\n    ' <td class=\"##class## eb\"></td>',\n   ],\n\n  EDGE_S_E() + EDGE_END_S() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>' . \"\\n\",\n    $edge_end_south,\n   ],\n\n  EDGE_S_E() + EDGE_END_S() + EDGE_END_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## ha\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>' . \"\\n\",\n    ' <td colspan=3 class=\"##class## v\"##edgecolor##>v</td>',\n   ],\n\n  ###########################################################################\n  ###########################################################################\n  # S_W\n\n  EDGE_S_W() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_W() + EDGE_START_W() => [\n    ' <td rowspan=2 class=\"##class## el\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_W() + EDGE_END_W() => [\n    ' <td rowspan=2 class=\"##class## va\"##edgecolor##><span class=\"shl\">&lt;</span></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_W() + EDGE_START_S() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    $edge_empty_row,\n   ],\n\n  EDGE_S_W() + EDGE_END_S() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    $edge_end_south,\n   ],\n\n  EDGE_S_W() + EDGE_START_W() + EDGE_END_S() => [\n    ' <td rowspan=2 class=\"##class## el\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    $edge_end_south,\n   ],\n\n  EDGE_S_W() + EDGE_START_S() + EDGE_END_W() => [\n    ' <td rowspan=3 class=\"##class## sh\"##edgecolor##>&lt;</td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n    ' <td class=\"##class## eb\"></td>'. \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    $edge_empty_row,\n   ],\n\n  ###########################################################################\n  ###########################################################################\n  # N_W\n\n  EDGE_N_W() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=4 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_W() + EDGE_START_N() => [\n    $edge_empty_row,\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=4 rowspan=2 class=\"##class## eb\"></td>',\n   ],\n\n  EDGE_N_W() + EDGE_END_N() => [\n    $edge_end_north,\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    ' <td colspan=4 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_W() + EDGE_END_N() + EDGE_START_W() => [\n    $edge_end_north,\n    ' <td rowspan=3 class=\"##class## eb\"></td>'.\n    ' <td class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>',\n    ' <td colspan=4 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_W() + EDGE_START_W() => [\n    ' <td rowspan=2 class=\"##class## el\"></td>' . \"\\n\" . \n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>' . \"\\n\",\n    '',\n    ' <td colspan=4 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_W() + EDGE_END_W() => [\n    ' <td rowspan=4 class=\"##class## sh\"##edgecolor##>&lt;</td>' . \"\\n\" . \n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##border##;\">&nbsp;</td>' . \"\\n\",\n    '',\n    ' <td colspan=3 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  ###########################################################################\n  ###########################################################################\n  # N_E\n\n  EDGE_N_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=4 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_E() + EDGE_START_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## el\"></td>',\n    '',\n    ' <td colspan=3 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_E() + EDGE_END_E() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## va\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    '',\n    ' <td colspan=3 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_E() + EDGE_END_E() + EDGE_START_N() => [\n    $edge_empty_row,\n    ' <td colspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=3 class=\"##class## va\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    ' <td colspan=3 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_E() + EDGE_START_E() + EDGE_END_N() => [\n    $edge_end_north,\n    ' <td colspan=2 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=3 class=\"##class## eb\">&nbsp;</td>',\n    ' <td colspan=3 rowspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_E() + EDGE_START_N() => [\n    $edge_empty_row,\n    ' <td colspan=2 rowspan=3 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>',\n    ' <td colspan=2 class=\"##class## eb\"></td>',\n    '',\n   ],\n\n  EDGE_N_E() + EDGE_END_N() => [\n    $edge_end_north,\n    ' <td colspan=2 rowspan=3 class=\"##class## eb\"></td>' . \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##; border-left: ##border##;\">&nbsp;</td>',\n    '',\n    ' <td colspan=2 class=\"##class## eb\"></td>',\n   ],\n\n  ###########################################################################\n  ###########################################################################\n  # self loops\n\n  EDGE_LOOP_NORTH() - EDGE_LABEL_CELL() => [\n    '<td rowspan=2 class=\"##class## eb\">&nbsp;</td>' . \"\\n\".\n    ' <td colspan=2 rowspan=2 class=\"##class## lh\" style=\"border-bottom: ##border##;##lc####bg##\">##label##</td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n    '',\n    '<td class=\"##class## eb\">&nbsp;</td>' . \"\\n\".\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##;##bg##\">&nbsp;</td>'.\"\\n\".\n    ' <td class=\"##class## eb\" style=\"border-left: ##border##;##bg##\">&nbsp;</td>',\n\n    '<td colspan=2 class=\"##class## v\" style=\"##bg##\"##edgecolor##>v</td>' . \"\\n\" .\n    ' <td colspan=2 class=\"##class## eb\">&nbsp;</td>',\n\n   ],\n\n  EDGE_LOOP_SOUTH() - EDGE_LABEL_CELL() => [\n    '<td colspan=2 class=\"##class## v\" style=\"##bg##\"##edgecolor##>^</td>' . \"\\n\" . \n    ' <td colspan=2 class=\"##class## eb\">&nbsp;</td>',\n\n    '<td rowspan=2 class=\"##class## eb\">&nbsp;</td>' . \"\\n\".\n    ' <td colspan=2 rowspan=2 class=\"##class## lh\" style=\"border-left:##border##;border-bottom:##border##;##lc####bg##\">##label##</td>'.\"\\n\".\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-left:##border##;##bg##\">&nbsp;</td>',\n\n    '',\n\n    '<td colspan=4 class=\"##class## eb\">&nbsp;</td>',\n\n   ],\n\n  EDGE_LOOP_WEST() - EDGE_LABEL_CELL() => [\n    $edge_empty_row.\n    ' <td colspan=2 rowspan=2 class=\"##class## lh\" style=\"border-bottom: ##border##;##lc####bg##\">##label##</td>'.\"\\n\".\n    ' <td rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n\n    '',\n\n    '<td colspan=2 class=\"##class## eb\" style=\"border-left: ##border##; border-bottom: ##border##;##bg##\">&nbsp;</td>' . \"\\n\".\n    ' <td rowspan=2 class=\"##class## va\" style=\"##bg##\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    \n    '<td colspan=2 class=\"##class## eb\">&nbsp;</td>',\n   ],\n\n  EDGE_LOOP_EAST() - EDGE_LABEL_CELL() => [\n\n    '<td rowspan=2 class=\"##class## eb\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## lh\" style=\"border-bottom: ##border##;##lc####bg##\">##label##</td>' .\"\\n\".\n    ' <td rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n\n    '',\n\n    '<td rowspan=2 class=\"##class## va\" style=\"##bg##\"##edgecolor##><span class=\"sh\">&lt;</span></td>' .\"\\n\".\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>'.\"\\n\".\n    ' <td class=\"##class## eb\" style=\"border-left: ##border##;##bg##\">&nbsp;</td>',\n   \n    '<td colspan=3 class=\"##class## eb\">&nbsp;</td>',\n   ],\n\n  ###########################################################################\n  ###########################################################################\n  # joints\n\n  ###########################################################################\n  # E_N_S\n\n  EDGE_E_N_S() => [\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left:##borderv##;border-bottom:##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_E_N_S() + EDGE_END_E() => [\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##; border-bottom: ##border##;##bg##\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## va\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    '',\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    '',\n   ],\n\n  ###########################################################################\n  # W_N_S\n\n  EDGE_W_N_S() => [\n    '<td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=4 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n    '',\n   ],\n\n  ###########################################################################\n  # S_E_W\n\n  EDGE_S_E_W() => [\n    '<td colspan=4 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_E_W() + EDGE_END_S() => [\n    '<td colspan=4 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    $edge_end_south,\n   ],\n\n  EDGE_S_E_W() + EDGE_START_S() => [\n    '<td colspan=4 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    ' <td colspan=4 class=\"##class## eb\"></td>',\n   ],\n\n  EDGE_S_E_W() + EDGE_START_W() => [\n    '<td rowspan=4 class=\"##class## el\"></td>' . \"\\n\" .\n    '<td colspan=3 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td rowspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    '',\n\n   ],\n\n  EDGE_S_E_W() + EDGE_END_E() => [\n    '<td colspan=3 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>' . \"\\n\" .\n    ' <td rowspan=4 class=\"##class## va\"##edgecolor##><span class=\"sa\">&gt;</span></td>',\n    '',\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\".\n    ' <td rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_S_E_W() + EDGE_END_W() => [\n    $edge_arrow_west_upper .\n    '<td colspan=3 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##border##;##bg##\">&nbsp;</td>' . \"\\n\" ,\n    '',\n    '<td colspan=2 rowspan=2 class=\"##class## eb\">&nbsp;</td>' .\"\\n\" .\n    '<td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##;##bg##\">&nbsp;</td>',\n   ],\n\n  ###########################################################################\n  # N_E_W\n\n  EDGE_N_E_W() => [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-bottom: ##borderv##;##bg##\">&nbsp;</td>' .\"\\n\".\n    '<td colspan=2 rowspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##; border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=4 rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_N_E_W() + EDGE_END_N() => [\n    $edge_end_north,\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##borderv##;##bg##\">&nbsp;</td>' .\"\\n\".\n    '<td colspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##; border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=4 rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n    '',\n   ],\n\n  EDGE_N_E_W() + EDGE_START_N() => [\n    $edge_empty_row,\n    ' <td colspan=2 class=\"##class## eb\" style=\"border-bottom: ##borderv##;##bg##\">&nbsp;</td>' .\"\\n\".\n    '<td colspan=2 class=\"##class## eb\" style=\"border-left: ##borderv##; border-bottom: ##border##;##bg##\">&nbsp;</td>',\n    '',\n    '<td colspan=4 rowspan=2 class=\"##class## eb\">&nbsp;</td>',\n    '',\n   ],\n\n  };\n\nsub _html_edge_hor\n  {\n  # Return HTML code for a horizontal edge (with all start/end combinations)\n  # as [], with code for each table row.\n  my ($self, $as) = @_;\n\n  my $s_flags = $self->{type} & EDGE_START_MASK;\n  my $e_flags = $self->{type} & EDGE_END_MASK;\n\n  $e_flags = 0 if $as eq 'none';\n\n  # XXX TODO: we could skip the output of \"eb\" parts when this edge doesn't belong\n  # to a group.\n\n  my $rc = [\n    ' <td colspan=##mod## rowspan=2 class=\"##class## lh\" style=\"border-bottom: ##border##;##lc####bg##\">##label##</td>',\n    '',\n    '<td colspan=##mod## rowspan=2 class=\"##class## eb\">&nbsp;</td>', \n    '',\n    ];\n\n  # This assumes that only 2 end/start flags are set at the same time:\n\n  my $mod = 4;\t\t\t\t\t\t\t# modifier\n  if ($s_flags & EDGE_START_W)\n    {\n    $mod--;\n    $rc->[0] = '<td rowspan=4 class=\"##class## el\"></td>' . \"\\n\" . $rc->[0];\n    };\n  if ($s_flags & EDGE_START_E)\n    {\n    $mod--;\n    $rc->[0] .= \"\\n \" . '<td rowspan=4 class=\"##class## el\"></td>';\n    };\n  if ($e_flags & EDGE_END_W)\n    {\n    $mod--;\n    $rc->[0] = $edge_arrow_west_upper . $rc->[0]; \n    $rc->[2] = $edge_arrow_west_lower . $rc->[2]; \n    }\n  if ($e_flags & EDGE_END_E)\n    { \n    $mod--;\n    $rc->[0] .= \"\\n \" . $edge_arrow_east_upper;\n    $rc->[2] .= \"\\n \" . $edge_arrow_east_lower;\n    };\n\n  # cx == 1: mod = 2..4, cx == 2: mod = 6..8, etc.\n  $self->{cx} ||= 1;\n  $mod = $self->{cx} * 4 - 4 + $mod;\n\n  for my $e (@$rc)\n    {\n    $e =~ s/##mod##/$mod/g;\n    }\n\n  $rc;\n  }\n\nsub _html_edge_ver\n  {\n  # Return HTML code for a vertical edge (with all start/end combinations)\n  # as [], with code for each table row.\n  my ($self, $as) = @_;\n\n  my $s_flags = $self->{type} & EDGE_START_MASK;\n  my $e_flags = $self->{type} & EDGE_END_MASK;\n\n  $e_flags = 0 if $as eq 'none';\n\n  my $mod = 4; \t\t\t\t\t\t\t# modifier\n\n  # normal vertical edge with no start/end flags\n  my $rc = [\n    '<td colspan=2 rowspan=##mod## class=\"##class## el\">&nbsp;</td>' . \"\\n \" . \n    '<td colspan=2 rowspan=##mod## class=\"##class## lv\" style=\"border-left: ##border##;##lc####bg##\">##label##</td>' . \"\\n\",\n    '',\n    '',\n    '',\n    ];\n\n  # flag north\n  if ($s_flags & EDGE_START_N)\n    {\n    $mod--;\n    unshift @$rc, '<td colspan=4 class=\"##class## eb\"></td>' . \"\\n\";\n    delete $rc->[-1];\n    }\n  elsif ($e_flags & EDGE_END_N)\n    {\n    $mod--;\n    unshift @$rc, $edge_end_north;\n    delete $rc->[-1];\n    }\n\n  # flag south\n  if ($s_flags & EDGE_START_S)\n    {\n    $mod--;\n    $rc->[3] = '<td colspan=4 class=\"##class## eb\"></td>' . \"\\n\"\n    }\n\n  if ($e_flags & EDGE_END_S)\n    {\n    $mod--;\n    $rc->[3] = $edge_end_south;\n    }\n\n  $self->{cy} ||= 1;\n  $mod = $self->{cy} * 4 - 4 + $mod;\n\n  for my $e (@$rc)\n    {\n    $e =~ s/##mod##/$mod/g;\n    }\n\n  $rc;\n  }\n\nsub _html_edge_cross\n  {\n  # Return HTML code for a crossingedge (with all start/end combinations)\n  # as [], with code for each table row.\n  my ($self, $N, $S, $E, $W) = @_;\n\n#  my $s_flags = $self->{type} & EDGE_START_MASK;\n#  my $e_flags = $self->{type} & EDGE_END_MASK;\n\n  my $rc = [\n    ' <td colspan=2 rowspan=2 class=\"##class## eb el\" style=\"border-bottom: ##border##\">&nbsp;</td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb el\" style=\"border-left: ##borderv##; border-bottom: ##border##\">&nbsp;</td>' . \"\\n\",\n    '',\n    ' <td colspan=2 rowspan=2 class=\"##class## eb el\"></td>' . \"\\n\" .\n    ' <td colspan=2 rowspan=2 class=\"##class## eb el\" style=\"border-left: ##borderv##\">&nbsp;</td>' . \"\\n\",\n    '',\n    ];\n\n  $rc;\n  }\n\nsub as_html\n  {\n  my ($self) = shift;\n\n  my $type = $self->{type} & EDGE_NO_M_MASK;\n  my $style = $self->{style};\n\n  # none, open, filled, closed\n  my $as; $as = 'none' if $self->{edge}->{undirected};\n  $as = $self->attribute('arrowstyle') unless $as;\n  \n  # triangle, box, dot, inv, diamond, line etc.\n  my $ashape; $ashape = 'triangle' if $self->{edge}->{undirected};\n  $ashape = $self->attribute('arrowshape') unless $ashape;\n\n  my $code = $edge_html->{$type};\n\n  if (!defined $code)\n    {\n    my $t = $self->{type} & EDGE_TYPE_MASK;\n\n    if ($style ne 'invisible')\n      {\n      $code = $self->_html_edge_hor($as) if $t == EDGE_HOR;\n      $code = $self->_html_edge_ver($as) if $t == EDGE_VER;\n      $code = $self->_html_edge_cross($as) if $t == EDGE_CROSS;\n      }\n    else\n      {\n      $code = [ ' <td colspan=4 rowspan=4 class=\"##class##\">&nbsp;</td>' ];\n      }\n\n    if (!defined $code)\n      {\n      $code = [ ' <td colspan=4 rowspan=4 class=\"##class##\">???</td>' ];\n      warn (\"as_html: Unimplemented edge type $self->{type} ($type) at $self->{x},$self->{y} \"\n\t. edge_type($self->{type}));\n      }\n    }\n\n  my $id = $self->{graph}->{id};\n\n  my $color = $self->get_color_attribute('color');\n  my $label = '';\n  my $label_style = '';\n\n  # only include the label if we are the label cell\n  if ($style ne 'invisible' && ($self->{type} & EDGE_LABEL_CELL))\n    {\n    my $switch_to_center;\n    ($label,$switch_to_center) = $self->_label_as_html();\n\n    # replace linebreaks by <br>, but remove extra spaces \n    $label =~ s/\\s*\\\\n\\s*/<br \\/>/g;\n\n    my $label_color = $self->raw_color_attribute('labelcolor') || $color;\n    $label_color = '' if $label_color eq '#000000';\n    $label_style = \"color: $label_color;\" if $label_color;\n\n    my $font = $self->attribute('font') || '';\n    $font = '' if $font eq ($self->default_attribute('font') || '');\n    $label_style = \"font-family: $font;\" if $font;\n  \n    $label_style .= $self->text_styles_as_css(1,1) unless $label eq '';\n\n    $label_style =~ s/^\\s*//;\n\n    my $link = $self->link();\n    if ($link ne '')\n      {\n      # encode critical entities\n      $link =~ s/\\s/\\+/g;\t\t\t# space\n      $link =~ s/'/%27/g;\t\t\t# single-quote\n\n      # put the style on the link\n      $label_style = \" style='$label_style'\" if $label_style;\n      $label = \"<a href='$link'$label_style>$label</a>\";\n      $label_style = '';\n      }\n\n    }\n  # without &nbsp;, IE doesn't draw the cell-border nec. for edges\n  $label = '&nbsp;' unless $label ne '';\n\n  ###########################################################################\n  # get the border styles/colors:\n\n  # width for the edge is \"2px\"\n  my $bow = '2';\n  my $border = Graph::Easy::_border_attribute_as_html( $self->{style}, $bow, $color);\n  my $border_v = $border;\n\n  if (($self->{type} & EDGE_TYPE_MASK) == EDGE_CROSS)\n   {\n   $border_v = Graph::Easy::_border_attribute_as_html( $self->{style_ver}, $bow, $self->{color_ver});\n   }\n\n  ###########################################################################\n  my $edge_color = ''; $edge_color = \" color: $color;\" if $color;\n\n  # If the group doesn't have a fill attribute, then it is defined in the CSS\n  # of the group, and since we get the same class, we can skip the background.\n  # But if the group has a fill, we need to use this as override.\n  # The idea behind is to omit the \"background: #daffff;\" as much as possible.\n\n  my $bg = $self->attribute('background') || '';\n  my $group = $self->{edge}->{group};\n  $bg = '' if $bg eq 'inherit';\n  $bg = $group->{att}->{fill} if $group->{att}->{fill} && $bg eq '';\n  $bg = '' if $bg eq 'inherit';\n  $bg = \" background: $bg;\" if $bg;\n\n  my $title = $self->title();\n  $title =~ s/\"/&#22;/g;\t\t\t# replace quotation marks\n  $title = \" title=\\\"$title\\\"\" if $title ne '';\t# add mouse-over title\n\n  ###########################################################################\n  # replace templates\n      \n  require Graph::Easy::As_ascii if $as ne 'none';\t# for _unicode_arrow()\n\n  # replace borderv with the border for the vertical edge on CROSS sections\n  $border =~ s/\\s+/ /g;\t\t\t# collapse multiple spaces\n  $border_v =~ s/\\s+/ /g;\n  my $cl = $self->class(); $cl =~ s/\\./_/g;\t# group.cities => group_cities\n\n  my $rc;\n  for my $a (@$code)\n    {\n    if (ref($a))\n      {\n      for my $c (@$a)\n        {\n        push @$rc, $self->_format_td($c, \n\t  $border, $border_v, $label_style, $edge_color, $bg, $as, $ashape, $title, $label, $cl);\n\t}\n      }\n    else\n      {\n      push @$rc, $self->_format_td($a, \n\t$border, $border_v, $label_style, $edge_color, $bg, $as, $ashape, $title, $label, $cl);\n      }\n    }\n\n  $rc;\n  }\n\nsub _format_td\n  {\n  my ($self, $c,\n\t$border, $border_v, $label_style, $edge_color, $bg, $as, $ashape, $title, $label, $cl) = @_;\n\n  # insert 'style=\"##bg##\"' unless there is already a style \n  $c =~ s/( e[bl]\")(>(&nbsp;)?<\\/td>)/$1 style=\"##bg##\"$2/g;\n  # insert missing \"##bg##\"\n  $c =~ s/style=\"border/style=\"##bg##border/g;\n\n  $c =~ s/##class##/$cl/g;\n  $c =~ s/##border##/$border/g;\n  $c =~ s/##borderv##/$border_v/g;\n  $c =~ s/##lc##/$label_style/g;\n  $c =~ s/##edgecolor##/ style=\"$edge_color\"/g;\n  $c =~ s/##ec##/$edge_color/g;\n  $c =~ s/##bg##/$bg/g;\n  $c =~ s/ style=\"\"//g;\t\t# remove empty styles\n\n  # remove arrows if edge is undirected\n  $c =~ s/>(v|\\^|&lt;|&gt;)/>/g if $as eq 'none';\n\n  # insert \"nice\" looking Unicode arrows\n  $c =~ s/>(v|\\^|&lt;|&gt;)/'>' . $self->_unicode_arrow($ashape, $as, $1); /eg;\n\n  # insert the label last, other \"v\" as label might get replaced above\n  $c =~ s/>##label##/$title>$label/;\n  # for empty labels use a different class\n  $c =~ s/ lh\"/ eb\"/ if $label eq '';\n\n  $c .= \"\\n\" unless $c =~ /\\n\\z/;\n\n  $self->quoted_comment() . $c;\n  }\n\nsub class\n  {\n  my $self = shift;\n\n  my $c = $self->{class} . ($self->{cell_class} || '');\n  $c = $self->{edge}->{group}->class() . ' ' . $c if ref($self->{edge}->{group});\n\n  $c;\n  }\n\nsub group\n  {\n  # return the group we belong to as the group of our parent-edge\n  my $self = shift;\n\n  $self->{edge}->{group};\n  }\n\n#############################################################################\n# accessor methods\n\nsub type\n  {\n  # get/set type of this path element\n  # type - EDGE_START, EDGE_END, EDGE_HOR, EDGE_VER, etc\n  my ($self,$type) = @_;\n\n  if (defined $type)\n    {\n    if (defined $type && $type < 0 || $type > EDGE_MAX_TYPE)\n      {\n      require Carp;\n      Carp::confess (\"Cell type $type for cell $self->{x},$self->{y} is not valid.\");\n      }\n    $self->{type} = $type;\n    }\n\n  $self->{type};\n  }\n\n#############################################################################\n\n# For rendering this path element as ASCII, we need to correct our width based\n# on whether we have a border or not. But this is only known after parsing is\n# complete.\n\nsub _correct_size\n  {\n  my ($self,$format) = @_;\n\n  return if defined $self->{w};\n\n  # min-size is this \n  $self->{w} = 5; $self->{h} = 3;\n  # make short cell pieces very small\n  if (($self->{type} & EDGE_SHORT_CELL) != 0)\n    {\n    $self->{w} = 1; $self->{h} = 1;\n    return;\n    }\n    \n  my $arrows = ($self->{type} & EDGE_ARROW_MASK);\n  my $type = ($self->{type} & EDGE_TYPE_MASK);\n\n  if ($self->{edge}->{bidirectional} && $arrows != 0)\n    {\n    $self->{w}++ if $type == EDGE_HOR;\n    $self->{h}++ if $type == EDGE_VER;\n    }\n\n  # make joints bigger if they got arrows\n  my $ah = $self->{type} & EDGE_ARROW_HOR;\n  my $av = $self->{type} & EDGE_ARROW_VER;\n  $self->{w}++ if $ah && ($type == EDGE_S_E_W || $type == EDGE_N_E_W);\n  $self->{h}++ if $av && ($type == EDGE_E_N_S || $type == EDGE_W_N_S);\n\n  my $style = $self->{edge}->attribute('style') || 'solid';\n\n  # make the edge to display ' ..-> ' instead of ' ..> ':\n  $self->{w}++ if $style eq 'dot-dot-dash';\n\n  if ($type >= EDGE_LOOP_TYPE)\n    {\n    #  +---+ \n    #  |   V\n\n    #       +\n    #  +--> |\n    #  |    |\n    #  +--- |\n    #       +\n    $self->{w} = 7;\n    $self->{w} = 8 if $type == EDGE_N_W_S || $type == EDGE_S_W_N;\n    $self->{h} = 3;\n    $self->{h} = 5 if $type != EDGE_N_W_S && $type != EDGE_S_W_N;\n    }\n\n  if ($self->{type} == EDGE_HOR)\n    {\n    $self->{w} = 0;\n    }\n  elsif ($self->{type} == EDGE_VER)\n    {\n    $self->{h} = 0;\n    }\n  elsif ($self->{type} & EDGE_LABEL_CELL)\n    {\n    # edges do not have borders\n    my ($w,$h) = $self->dimensions(); $h-- unless $h == 0;\n\n    $h += $self->{h};\n    $w += $self->{w};\n    $self->{w} = $w;\n    $self->{h} = $h;\n    }\n  }\n\n#############################################################################\n# attribute handling\n\nsub attribute\n  {\n  my ($self, $name) = @_;\n\n  my $edge = $self->{edge};\n\n#  my $native = $edge->{att}->{$name};\n#  return $native if defined $native && $native ne 'inherit';\n\n  # shortcut, look up the attribute directly\n  return $edge->{att}->{$name}\n    if defined $edge->{att}->{$name} && $edge->{att}->{$name} ne 'inherit';\n\n  return $edge->attribute($name);\n\n  # XXX TODO This does not work, since caching the attribute doesn't get invalidated\n  # upon set_attribute().\n\n#  $edge->{cache} = {} unless exists $edge->{cache};\n#  $edge->{cache}->{att} = {} unless exists $edge->{cache}->{att};\n#\n#  my $cache = $edge->{cache}->{att};\n#  return $cache->{$name} if exists $cache->{$name};\n#\n#  my $rc = $edge->attribute($name);\n#  # only cache values that weren't inherited to avoid cache problems\n#  $cache->{$name} = $rc unless defined $native && $native eq 'inherit';\n#\n#  $rc;\n  }\n\n1;\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy::Edge::Cell::Empty;\n\nrequire Graph::Easy::Node::Cell;\nour @ISA = qw/Graph::Easy::Node::Cell/;\n\n#use vars qw/$VERSION/;\n\nour $VERSION = '0.02';\n\nuse constant isa_cell => 1;\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Edge::Cell - A cell in an edge in Graph::Easy\n\n=head1 SYNOPSIS\n\n        use Graph::Easy;\n\n\tmy $ssl = Graph::Easy::Edge->new(\n\t\tlabel => 'encrypted connection',\n\t\tstyle => 'solid',\n\t\tcolor => 'red',\n\t);\n\tmy $src = Graph::Easy::Node->new( 'source' );\n\tmy $dst = Graph::Easy::Node->new( 'destination' );\n\n\t$graph = Graph::Easy->new();\n\n\t$graph->add_edge($src, $dst, $ssl);\n\n\tprint $graph->as_ascii();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Edge::Cell> represents an edge between two (or more) nodes\nin a simple graph.\n\nEach edge has a direction (from source to destination, or back and forth),\nplus a style (line width and style), colors etc. It can also have a name,\ne.g. a text label associated with it.\n\nThere should be no need to use this package directly.\n\n=head1 METHODS\n\n=head2 error()\n\n\t$last_error = $edge->error();\n\n\t$cvt->error($error);\t\t\t# set new messags\n\t$cvt->error('');\t\t\t# clear error\n\nReturns the last error message, or '' for no error.\n\n=head2 as_ascii()\n\n\tmy $ascii = $path->as_ascii();\n\nReturns the path-cell as a little ascii representation.\n\n=head2 as_html()\n\n\tmy $html = $path->as_html($tag,$id);\n\neturns the path-cell as HTML code.\n\n=head2 label()\n\n\tmy $label = $path->label();\n\nReturns the name (also known as 'label') of the path-cell.\n\n=head2 style()\n\n\tmy $style = $edge->style();\n\nReturns the style of the edge.\n\n=head1 EXPORT\n\nNone by default. Can export the following on request:\n\n  EDGE_START_E\n  EDGE_START_W\n  EDGE_START_N\n  EDGE_START_S\n\n  EDGE_END_E\n  EDGE_END_W\t\n  EDGE_END_N\n  EDGE_END_S\n\n  EDGE_SHORT_E\n  EDGE_SHORT_W\t\n  EDGE_SHORT_N\n  EDGE_SHORT_S\n\n  EDGE_SHORT_BD_EW\n  EDGE_SHORT_BD_NS\n\n  EDGE_SHORT_UN_EW\n  EDGE_SHORT_UN_NS\n\n  EDGE_HOR\n  EDGE_VER\n  EDGE_CROSS\n\n  EDGE_N_E\n  EDGE_N_W\n  EDGE_S_E\n  EDGE_S_W\n\n  EDGE_S_E_W\n  EDGE_N_E_W\n  EDGE_E_N_S\n  EDGE_W_N_S\t\n\n  EDGE_LOOP_NORTH\n  EDGE_LOOP_SOUTH\n  EDGE_LOOP_EAST\n  EDGE_LOOP_WEST\n\n  EDGE_N_W_S\n  EDGE_S_W_N\n  EDGE_E_S_W\n  EDGE_W_S_E\n\n  EDGE_TYPE_MASK\n  EDGE_FLAG_MASK\n  EDGE_ARROW_MASK\n  \n  EDGE_START_MASK\n  EDGE_END_MASK\n  EDGE_MISC_MASK\n\n  ARROW_RIGHT\n  ARROW_LEFT\n  ARROW_UP\n  ARROW_DOWN\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Edge.pm": "#############################################################################\n# An edge connecting two nodes in Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Edge;\n\nuse Graph::Easy::Node;\n@ISA = qw/Graph::Easy::Node/;\t\t# an edge is just a special node\n$VERSION = '0.31';\n\nuse strict;\n\nuse constant isa_cell => 1;\n\n#############################################################################\n\nsub _init\n  {\n  # generic init, override in subclasses\n  my ($self,$args) = @_;\n  \n  $self->{class} = 'edge';\n\n  # leave this unitialized until we need it\n  # $self->{cells} = [ ];\n\n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(label|name|style)\\z/)\n      {\n      require Carp;\n      Carp::confess (\"Invalid argument '$k' passed to Graph::Easy::Node->new()\");\n      }\n    my $n = $k; $n = 'label' if $k eq 'name';\n\n    $self->{att}->{$n} = $args->{$k};\n    }\n\n  $self;\n  }\n\n#############################################################################\n# accessor methods\n\nsub bidirectional\n  {\n  my $self = shift;\n \n  if (@_ > 0)\n    {\n    my $old = $self->{bidirectional} || 0;\n    $self->{bidirectional} = $_[0] ? 1 : 0; \n\n    # invalidate layout?\n    $self->{graph}->{score} = undef if $old != $self->{bidirectional} && ref($self->{graph});\n    }\n\n  $self->{bidirectional};\n  }\n\nsub undirected\n  {\n  my $self = shift;\n\n  if (@_ > 0)\n    {\n    my $old = $self->{undirected} || 0;\n    $self->{undirected} = $_[0] ? 1 : 0; \n\n    # invalidate layout?\n    $self->{graph}->{score} = undef if $old != $self->{undirected} && ref($self->{graph});\n    }\n\n  $self->{undirected};\n  }\n\nsub has_ports\n  {\n  my $self = shift;\n\n  my $s_port = $self->{att}->{start} || $self->attribute('start');\n\n  return 1 if $s_port ne '';\n\n  my $e_port = $self->{att}->{end} || $self->attribute('end');\n\n  return 1 if $e_port ne '';\n\n  0;\n  }\n\nsub start_port\n  {\n  # return the side and portnumber if the edge has a shared source port\n  # undef for none\n  my $self = shift;\n\n  my $s = $self->{att}->{start} || $self->attribute('start');\n  return undef if !defined $s || $s !~ /,/;\t# \"south, 0\" => ok, \"south\" => no\n\n  return (split /\\s*,\\s*/, $s) if wantarray;\n\n  $s =~ s/\\s+//g;\t\t# remove spaces to normalize \"south, 0\" to \"south,0\"\n  $s;\n  }\n\nsub end_port\n  {\n  # return the side and portnumber if the edge has a shared source port\n  # undef for none\n  my $self = shift;\n\n  my $s = $self->{att}->{end} || $self->attribute('end');\n  return undef if !defined $s || $s !~ /,/;\t# \"south, 0\" => ok, \"south\" => no\n\n  return split /\\s*,\\s*/, $s if wantarray;\n\n  $s =~ s/\\s+//g;\t\t# remove spaces to normalize \"south, 0\" to \"south,0\"\n  $s;\n  }\n\nsub style\n  {\n  my $self = shift;\n\n  $self->{att}->{style} || $self->attribute('style');\n  }\n\nsub name\n  {\n  # returns actually the label\n  my $self = shift;\n\n  $self->{att}->{label} || '';\n  }\n\n#############################################################################\n# cell management - used by the cell-based layouter\n\nsub _cells\n  {\n  # return all the cells this edge currently occupies\n  my $self = shift;\n\n  $self->{cells} = [] unless defined $self->{cells};\n\n  @{$self->{cells}};\n  }\n\nsub _clear_cells\n  { \n  # remove all belonging cells\n  my $self = shift;\n\n  $self->{cells} = [];\n\n  $self;\n  }\n\nsub _unplace\n  {\n  # Take an edge, and remove all the cells it covers from the cells area\n  my ($self, $cells) = @_;\n\n  print STDERR \"# clearing path from $self->{from}->{name} to $self->{to}->{name}\\n\" if $self->{debug};\n\n  for my $key (@{$self->{cells}})\n    {\n    # XXX TODO: handle crossed edges differently (from CROSS => HOR or VER)\n    # free in our cells area\n    delete $cells->{$key};\n    }\n\n  $self->clear_cells();\n\n  $self;\n  }\n\nsub _distance\n  {\n  # estimate the distance from SRC to DST node\n  my ($self) = @_;\n\n  my $src = $self->{from};\n  my $dst = $self->{to};\n\n  # one of them not yet placed?\n  return 100000 unless defined $src->{x} && defined $dst->{x};\n\n  my $cells = $self->{graph}->{cells};\n\n  # get all the starting positions\n  # distance = 1: slots, generate starting types, the direction is shifted\n  # by 90° counter-clockwise\n\n  my @start = $src->_near_places($cells, 1, undef, undef, $src->_shift(-90) );\n\n  # potential stop positions\n  my @stop = $dst->_near_places($cells, 1);\t\t# distance = 1: slots\n\n  my ($s_p,@ss_p) = $self->port('start');\n  my ($e_p,@ee_p) = $self->port('end');\n\n  # the edge has a port description, limiting the start places\n  @start = $src->_allowed_places( \\@start, $src->_allow( $s_p, @ss_p ), 3)\n    if defined $s_p;\n\n  # the edge has a port description, limiting the stop places\n  @stop = $dst->_allowed_places( \\@stop, $dst->_allow( $e_p, @ee_p ), 3)\n    if defined $e_p;\n\n  my $stop = scalar @stop;\n\n  return 0 unless @stop > 0 && @start > 0;\t# no free slots on one node?\n\n  my $lowest;\n\n  my $i = 0;\n  while ($i < scalar @start)\n    {\n    my $sx = $start[$i]; my $sy = $start[$i+1]; $i += 2;\n\n    # for each start point, calculate the distance to each stop point, then use\n    # the smallest as value\n\n    for (my $u = 0; $u < $stop; $u += 2)\n      {\n      my $dist = Graph::Easy::_astar_distance($sx,$sy, $stop[$u], $stop[$u+1]);\n      $lowest = $dist if !defined $lowest || $dist < $lowest;\n      }\n    }\n\n  $lowest;\n  }\n\nsub _add_cell\n  {\n  # add a cell to the list of cells this edge covers. If $after is a ref\n  # to a cell, then the new cell will be inserted right after this cell.\n  # if after is defined, but not a ref, the new cell will be inserted\n  # at the specified position.\n  my ($self, $cell, $after, $before) = @_;\n \n  $self->{cells} = [] unless defined $self->{cells};\n  my $cells = $self->{cells};\n\n  # if both are defined, but belong to different edges, just ignore $before:\n  $before = undef if ref($before) && $before->{edge} != $self;\n  $after = undef if ref($after) && $after->{edge} != $self;\n  if (!defined $after && ref($before))\n    {\n    $after = $before; $before = undef;\n    }\n\n  if (defined $after)\n    {\n    # insert the new cell right after $after\n    my $ofs = $after;\n    if (ref($after) && !ref($before))\n      {\n      # insert after $after\n      $ofs = 1;\n      for my $cell (@$cells)\n        {\n        last if $cell == $after;\n        $ofs++; \n        }\n      }\n    elsif (ref($after) && ref($before))\n      {\n      # insert between after and before (or before/after for \"reversed edges)\n      $ofs = 0;\n      my $found = 0;\n      while ($ofs < scalar @$cells - 1)\t\t# 0,1,2,3 => 0 .. 2\n        {\n        my $c1 = $cells->[$ofs];\n        my $c2 = $cells->[$ofs+1];\n\t$ofs++;\n        $found++, last if (($c1 == $after && $c2 == $before) ||\n                 ($c1 == $before && $c2 == $after));\n        }\n      if (!$found)\n\t{\n        # XXX TODO: last effort\n\n        # insert after $after\n        $ofs = 1;\n        for my $cell (@$cells)\n          {\n          last if $cell == $after;\n          $ofs++; \n          }\n        $found++;\n\t}\n      $self->_croak(\"Could not find $after and $before\") unless $found;\n      }\n    splice (@$cells, $ofs, 0, $cell);\n    } \n  else\n    {\n    # insert new cell at the end\n    push @$cells, $cell;\n    }\n\n  $cell->_update_boundaries();\n\n  $self;\n  }\n\n#############################################################################\n\nsub from\n  {\n  my $self = shift;\n\n  $self->{from};\n  }\n\nsub to\n  {\n  my $self = shift;\n\n  $self->{to};\n  }\n\nsub nodes\n  {\n  my $self = shift;\n\n  ($self->{from}, $self->{to});\n  }\n\nsub start_at\n  {\n  # move the edge's start point from the current node to the given node\n  my ($self, $node) = @_;\n\n  # if not a node yet, or not part of this graph, make into one proper node\n  $node = $self->{graph}->add_node($node);\n\n  $self->_croak(\"start_at() needs a node object, but got $node\")\n    unless ref($node) && $node->isa('Graph::Easy::Node');\n\n  # A => A => nothing to do\n  return $node if $self->{from} == $node;\n\n  # delete self at A\n  delete $self->{from}->{edges}->{ $self->{id} };\n\n  # set \"from\" to B\n  $self->{from} = $node;\n\n  # add to B\n  $self->{from}->{edges}->{ $self->{id} } = $self;\n\n  # invalidate layout\n  $self->{graph}->{score} = undef if ref($self->{graph});\n\n  # return new start point\n  $node;\n  }\n\nsub end_at\n  {\n  # move the edge's end point from the current node to the given node\n  my ($self, $node) = @_;\n\n  # if not a node yet, or not part of this graph, make into one proper node\n  $node = $self->{graph}->add_node($node);\n\n  $self->_croak(\"start_at() needs a node object, but got $node\")\n    unless ref($node) && $node->isa('Graph::Easy::Node');\n\n  # A => A => nothing to do\n  return $node if $self->{to} == $node;\n\n  # delete self at A\n  delete $self->{to}->{edges}->{ $self->{id} };\n\n  # set \"to\" to B\n  $self->{to} = $node;\n\n  # add to node B\n  $self->{to}->{edges}->{ $self->{id} } = $self;\n\n  # invalidate layout\n  $self->{graph}->{score} = undef if ref($self->{graph});\n\n  # return new end point\n  $node;\n  }\n\nsub edge_flow\n  {\n  # return the flow at this edge  or '' if the edge itself doesn't have a flow\n  my $self = shift;\n\n  # our flow comes from ourselves\n  my $flow = $self->{att}->{flow};\n  $flow = $self->raw_attribute('flow') unless defined $flow;\n\n  $flow;\n  }\n\nsub flow\n  {\n  # return the flow at this edge (including inheriting flow from node)\n  my ($self) = @_;\n\n  # print STDERR \"# flow from $self->{from}->{name} to $self->{to}->{name}\\n\";\n\n  # our flow comes from ourselves\n  my $flow = $self->{att}->{flow};\n  # or maybe our class\n  $flow = $self->raw_attribute('flow') unless defined $flow;\n\n  # if the edge doesn't have a flow, maybe the node has a default out flow\n  $flow = $self->{from}->{att}->{flow} if !defined $flow;\n\n  # if that didn't work out either, use the parents flows\n  $flow = $self->parent()->attribute('flow') if !defined $flow; \n  # or finally, the default \"east\":\n  $flow = 90 if !defined $flow;\n\n  # absolute flow does not depend on the in-flow, so can return early\n  return $flow if $flow =~ /^(0|90|180|270)\\z/;\n\n  # in-flow comes from our \"from\" node\n  my $in = $self->{from}->flow();\n\n# print STDERR \"# in: $self->{from}->{name} = $in\\n\";\n\n  my $out = $self->{graph}->_flow_as_direction($in,$flow);\n  $out;\n  }\n\nsub port\n  {\n  my ($self, $which) = @_;\n\n  $self->_croak(\"'$which' must be one of 'start' or 'end' in port()\") unless $which =~ /^(start|end)/;\n\n  # our flow comes from ourselves\n  my $sp = $self->attribute($which); \n\n  return (undef,undef) unless defined $sp && $sp ne '';\n\n  my ($side, $port) = split /\\s*,\\s*/, $sp;\n\n  # if absolut direction, return as is\n  my $s = Graph::Easy->_direction_as_side($side);\n\n  if (defined $s)\n    {\n    my @rc = ($s); push @rc, $port if defined $port;\n    return @rc;\n    }\n\n  # in_flow comes from our \"from\" node\n  my $in = 90; $in = $self->{from}->flow() if ref($self->{from});\n\n  # turn left in \"south\" etc:\n  $s = Graph::Easy->_flow_as_side($in,$side);\n\n  my @rc = ($s); push @rc, $port if defined $port;\n  @rc;\n  }\n\nsub flip\n  {\n  # swap from and to for this edge\n  my ($self) = @_;\n\n  ($self->{from}, $self->{to}) = ($self->{to}, $self->{from});\n\n  # invalidate layout\n  $self->{graph}->{score} = undef if ref($self->{graph});\n\n  $self;\n  }\n\nsub as_ascii\n  {\n  my ($self, $x,$y) = @_;\n\n  # invisible nodes, or very small ones\n  return '' if $self->{w} == 0 || $self->{h} == 0;\n\n  my $fb = $self->_framebuffer($self->{w}, $self->{h});\n\n  ###########################################################################\n  # \"draw\" the label into the framebuffer (e.g. the edge and the text)\n  $self->_draw_label($fb, $x, $y, '');\n\n  join (\"\\n\", @$fb);\n  }\n\nsub as_txt\n  {\n  require Graph::Easy::As_ascii;\n\n  _as_txt(@_);\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Edge - An edge (a path connecting one ore more nodes)\n\n=head1 SYNOPSIS\n\n        use Graph::Easy;\n\n\tmy $ssl = Graph::Easy::Edge->new(\n\t\tlabel => 'encrypted connection',\n\t\tstyle => 'solid',\n\t);\n\t$ssl->set_attribute('color', 'red');\n\n\tmy $src = Graph::Easy::Node->new('source');\n\n\tmy $dst = Graph::Easy::Node->new('destination');\n\n\t$graph = Graph::Easy->new();\n\n\t$graph->add_edge($src, $dst, $ssl);\n\n\tprint $graph->as_ascii();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Edge> represents an edge between two (or more) nodes in a\nsimple graph.\n\nEach edge has a direction (from source to destination, or back and forth),\nplus a style (line width and style), colors etc. It can also have a label,\ne.g. a text associated with it.\n\nDuring the layout phase, each edge also contains a list of path-elements\n(also called cells), which make up the path from source to destination.\n\n=head1 METHODS\n\n=head2 error()\n\n\t$last_error = $edge->error();\n\n\t$cvt->error($error);\t\t\t# set new messags\n\t$cvt->error('');\t\t\t# clear error\n\nReturns the last error message, or '' for no error.\n\n=head2 as_ascii()\n\n\tmy $ascii = $edge->as_ascii();\n\nReturns the edge as a little ascii representation.\n\n=head2 as_txt()\n\n\tmy $txt = $edge->as_txt();\n\nReturns the edge as a little Graph::Easy textual representation.\n\n=head2 label()\n\n\tmy $label = $edge->label();\n\nReturns the label (also known as 'name') of the edge.\n\n=head2 name()\n\n\tmy $label = $edge->name();\n\nTo make the interface more consistent, the C<name()> method of\nan edge can also be called, and it will returned either the edge\nlabel, or the empty string if the edge doesn't have a label.\n\n=head2 style()\n\n\tmy $style = $edge->style();\n\nReturns the style of the edge, like 'solid', 'dotted', 'double', etc.\n\n=head2 nodes()\n\n\tmy @nodes = $edge->nodes();\n\nReturns the source and target node that this edges connects as objects.\n\n=head2 bidirectional()\n\n\t$edge->bidirectional(1);\n\tif ($edge->bidirectional())\n\t  {\n\t  }\n\nReturns true if the edge is bidirectional, aka has arrow heads on both ends.\nAn optional parameter will set the bidirectional status of the edge.\n\n=head2 undirected()\n\n\t$edge->undirected(1);\n\tif ($edge->undirected())\n\t  {\n\t  }\n\nReturns true if the edge is undirected, aka has now arrow at all.\nAn optional parameter will set the undirected status of the edge.\n\n=head2 has_ports()\n\n\tif ($edge->has_ports())\n\t  {\n\t  ...\n\t  }\n\nReturn true if the edge has restriction on the starting or ending\nport, e.g. either the C<start> or C<end> attribute is set on\nthis edge. \n\n=head2 start_port()\n\n\tmy $port = $edge->start_port();\n\nReturn undef if the edge does not have a fixed start port, otherwise\nreturns the port as \"side, number\", for example \"south, 0\".\n\n=head2 end_port()\n\n\tmy $port = $edge->end_port();\n\nReturn undef if the edge does not have a fixed end port, otherwise\nreturns the port as \"side, number\", for example \"south, 0\".\n\n=head2 from()\n\n\tmy $from = $edge->from();\n\nReturns the node that this edge starts at. See also C<to()>.\n\n=head2 to()\n\n\tmy $to = $edge->to();\n\nReturns the node that this edge leads to. See also C<from()>.\n\n=head2 start_at()\n\n\t$edge->start_at($other);\n\tmy $other = $edge->start_at('some node');\n\nSet the edge's start point to the given node. If given a node name,\nwill add that node to the graph first.\n\nReturns the new edge start point node.\n\n=head2 end_at()\n\n\t$edge->end_at($other);\n\tmy $other = $edge->end_at('some other node');\n\nSet the edge's end point to the given node. If given a node name,\nwill add that node to the graph first.\n\nReturns the new edge end point node.\n\n=head2 flip()\n\n\t$edge->flip();\n\nSwaps the C<start> and C<end> nodes on this edge, e.g. reverses the direction\nof the edge.\n\nX<transpose>\n\n=head2 flow()\n\n\tmy $flow = $edge->flow();\n\nReturns the flow for this edge, honoring inheritance. An edge without\na specific flow set will inherit the flow from the node it comes from.\n\n=head2 edge_flow()\n\n\tmy $flow = $edge->edge_flow();\n\nReturns the flow for this edge, or undef if it has none set on either\nthe object itself or its class.\n\n=head2 port()\n\n\tmy ($side, $number) = $edge->port('start');\n\tmy ($side, $number) = $edge->port('end');\n\nReturn the side and port number where this edge starts or ends.\n\nReturns undef for $side if the edge has no port restriction. The\nreturned side will be one absolute direction of C<east>, C<west>,\nC<north> or C<south>, depending on the port restriction and\nflow at that edge.\n\n=head2 get_attributes()\n\n        my $att = $object->get_attributes();\n\nReturn all effective attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance and default values.\n\nSee also L<raw_attributes()>.\n\n=head2 raw_attributes()\n\n        my $att = $object->get_attributes();\n\nReturn all set attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance, but does not include\ndefault values for unset attributes.\n\nSee also L<get_attributes()>.\n\n=head2 attribute related methods\n\nYou can call all the various attribute related methods like C<set_attribute()>,\nC<get_attribute()>, etc. on an edge, too. For example:\n\n\t$edge->set_attribute('label', 'by train');\n\tmy $attr = $edge->get_attributes();\n\tmy $raw_attr = $edge->raw_attributes();\n\nYou can find more documentation in L<Graph::Easy>.\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Group/Anon.pm": "#############################################################################\n# (c) by Tels 2004. Part of Graph::Easy. An anonymous group.\n#\n#############################################################################\n\npackage Graph::Easy::Group::Anon;\n\nuse Graph::Easy::Group;\n\n@ISA = qw/Graph::Easy::Group/;\n$VERSION = '0.02';\n\nuse strict;\n\nsub _init\n  {\n  my $self = shift;\n\n  $self->SUPER::_init(@_);\n\n  $self->{name} = 'Group #' . $self->{id};\n  $self->{class} = 'group.anon';\n\n  $self->{att}->{label} = '';\n\n  $self;\n  }\n\nsub _correct_size\n  {\n  my $self = shift;\n\n  $self->{w} = 3;\n  $self->{h} = 3;\n\n  $self;\n  }\n\nsub attributes_as_txt\n  {\n  my $self = shift;\n\n  $self->SUPER::attributes_as_txt( {\n     node => {\n       label => undef,\n       shape => undef,\n       class => undef,\n       } } );\n  }\n\nsub as_pure_txt\n  {\n  '( )';\n  }\n\nsub _as_part_txt\n  {\n  '( )';\n  }\n\nsub as_graphviz_txt\n  {\n  my $self = shift;\n  \n  my $name = $self->{name};\n\n  # quote special chars in name\n  $name =~ s/([\\[\\]\\(\\)\\{\\}\\#])/\\\\$1/g;\n\n  '\"' .  $name . '\"';\n  }\n\nsub text_styles_as_css\n  {\n  '';\n  }\n\nsub is_anon\n  {\n  # is an anon group\n  1;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Group::Anon - An anonymous group of nodes in Graph::Easy\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy::Group::Anon;\n\n\tmy $anon = Graph::Easy::Group::Anon->new();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Group::Anon> represents an anonymous group of nodes,\ne.g. a group without a name.\n\nThe syntax in the Graph::Easy textual description language looks like this:\n\n\t( [ Bonn ] -> [ Berlin ] )\n\nThis module is loaded and used automatically by Graph::Easy, so there is\nno need to use it manually.\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy::Group>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2006 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Group/Cell.pm": "#############################################################################\n# A cell of a group during layout. Part of Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Group::Cell;\n\nuse Graph::Easy::Node;\n\n@ISA = qw/Graph::Easy::Node/;\n$VERSION = '0.14';\n\nuse strict;\n\nBEGIN\n  {\n  *get_attribute = \\&attribute;\n  }\n\n#############################################################################\n\n# The different types for a group-cell:\nuse constant {\n  GROUP_INNER\t\t=> 0,\t# completely sourounded by group cells\n  GROUP_RIGHT\t\t=> 1,\t# right border only\n  GROUP_LEFT\t\t=> 2, \t# left border only\n  GROUP_TOP\t \t=> 3,\t# top border only\n  GROUP_BOTTOM \t\t=> 4, \t# bottom border only\n  GROUP_ALL\t \t=> 5,\t# completely sourounded by non-group cells\n\n  GROUP_BOTTOM_RIGHT\t=> 6,\t# bottom and right border\n  GROUP_BOTTOM_LEFT\t=> 7,\t# bottom and left border\n  GROUP_TOP_RIGHT\t=> 8, \t# top and right border\n  GROUP_TOP_LEFT\t=> 9,\t# top and left order\n\n  GROUP_MAX\t\t=> 5, \t# max number\n  };\n\nmy $border_styles = \n  {\n  # type\t\t    top,\tbottom, left,   right,\tclass\n  GROUP_INNER()\t\t=> [ 0,\t\t0,\t0,\t0,\t['gi'] ],\n  GROUP_RIGHT()\t\t=> [ 0,\t\t0,\t0,\t1,\t['gr'] ],\n  GROUP_LEFT()\t\t=> [ 0,\t\t0,\t1,\t0,\t['gl'] ],\n  GROUP_TOP()\t\t=> [ 1,\t\t0,\t0,\t0,\t['gt'] ],\n  GROUP_BOTTOM()\t=> [ 0,\t\t1,\t0,\t0,\t['gb'] ],\n  GROUP_ALL()\t\t=> [ 0,\t\t0,\t0,\t0,\t['ga'] ],\n  GROUP_BOTTOM_RIGHT()\t=> [ 0,\t\t1,\t0,\t1,\t['gb','gr'] ],\n  GROUP_BOTTOM_LEFT()\t=> [ 0,\t\t1,\t1,\t0,\t['gb','gl'] ],\n  GROUP_TOP_RIGHT()\t=> [ 1,\t\t0,\t0,\t1,\t['gt','gr'] ],\n  GROUP_TOP_LEFT()\t=> [ 1,\t\t0,\t1,\t0,\t['gt','gl'] ],\n  };\n\nmy $border_name = [ 'top', 'bottom', 'left', 'right' ];\n\nsub _css\n  {\n  my ($c, $id, $group, $border) = @_;\n\n  my $css = '';\n\n  for my $type (0 .. 5)\n    {\n    my $b = $border_styles->{$type};\n  \n    # If border eq 'none', this would needlessly repeat the \"border: none\"\n    # from the general group class.\n    next if $border eq 'none';\n\n    my $cl = '.' . $b->[4]->[0]; # $cl .= \"-$group\" unless $group eq '';\n\n    $css .= \"table.graph$id $cl {\";\n    if ($type == GROUP_INNER)\n      {\n      $css .= \" border: none;\";\t\t\t# shorter CSS\n      }\n    elsif ($type == GROUP_ALL)\n      {\n      $css .= \" border-style: $border;\";\t# shorter CSS\n      }\n    else\n      {\n      for (my $i = 0; $i < 4; $i++)\n        {\n        $css .= ' border-' . $border_name->[$i] . \"-style: $border;\" if $b->[$i];\n        }\n      }\n    $css .= \"}\\n\";\n    }\n\n  $css;\n  }\n\n#############################################################################\n\nsub _init\n  {\n  # generic init, override in subclasses\n  my ($self,$args) = @_;\n  \n  $self->{class} = 'group';\n  $self->{cell_class} = ' gi';\n  $self->{name} = '';\n  \n  $self->{x} = 0;\n  $self->{y} = 0;\n\n  # XXX TODO check arguments\n  foreach my $k (keys %$args)\n    {\n    $self->{$k} = $args->{$k};\n    }\n \n  if (defined $self->{group})\n    {\n    # register ourselves at this group\n    $self->{group}->_add_cell ($self);\n    # XXX CHECK also implement sub_class()\n    $self->{class} = $self->{group}->{class};\n    $self->{class} = 'group' unless defined $self->{class};\n    }\n \n  $self;\n  }\n\nsub _set_type\n  {\n  # set the proper type of this cell based on the sourrounding cells\n  my ($self, $cells) = @_;\n\n  # +------+--------+-------+\n  # | LT     TOP      RU    |\n  # +      +        +       +\n  # | LEFT   INNER    Right |\n  # +      +        +       +\n  # | LB     BOTTOM   RB    |\n  # +------+--------+-------+\n\n  my @coord = (\n    [  0, -1, ' gt' ],\n    [ +1,  0, ' gr' ],\n    [  0, +1, ' gb' ],\n    [ -1,  0, ' gl' ],\n    );\n\n  my ($sx,$sy) = ($self->{x},$self->{y});\n\n  my $class = '';\n  my $gr = $self->{group};\n  foreach my $co (@coord)\n    {\n    my ($x,$y,$c) = @$co; $x += $sx; $y += $sy;\n    my $cell = $cells->{\"$x,$y\"};\n\n    # belongs to the same group?\n    my $go = 0; $go = $cell->group() if UNIVERSAL::can($cell, 'group');\n\n    $class .= $c unless defined $go && $gr == $go;\n    }\n\n  $class = ' ga' if $class eq ' gt gr gb gl';\n\n  $self->{cell_class} = $class;\n\n  $self;\n  }\n\nsub _set_label\n  {\n  my $self = shift;\n\n  $self->{has_label} = 1;\n \n  $self->{name} = $self->{group}->label();\n  }\n\nsub shape\n  {\n  'rect';\n  }\n\nsub attribute\n  {\n  my ($self, $name) = @_;\n\n#  print STDERR \"called attribute($name)\\n\";\n#  return $self->{group}->attribute($name);\n\n  my $group = $self->{group};\n\n  return $group->{att}->{$name} if exists $group->{att}->{$name};\n\n  $group->{cache} = {} unless exists $group->{cache};\n  $group->{cache}->{att} = {} unless exists $group->{cache}->{att};\n\n  my $cache = $group->{cache}->{att};\n  return $cache->{$name} if exists $cache->{$name};\n\n  $cache->{$name} = $group->attribute($name);\n  }\n\nuse constant isa_cell => 1;\n\n#############################################################################\n# conversion to ASCII or HTML\n\nsub as_ascii\n  {\n  my ($self, $x,$y) = @_;\n\n  my $fb = $self->_framebuffer($self->{w}, $self->{h});\n\n  my $border_style = $self->attribute('borderstyle');\n  my $EM = 14;\n  # use $self here and not $self->{group} to engage attribute cache:\n  my $border_width = Graph::Easy::_border_width_in_pixels($self,$EM);\n\n  # convert overly broad borders to the correct style\n  $border_style = 'bold' if $border_width > 2;\n  $border_style = 'broad' if $border_width > $EM * 0.2 && $border_width < $EM * 0.75;\n  $border_style = 'wide' if $border_width >= $EM * 0.75;\n\n  if ($border_style ne 'none')\n    {\n\n    #########################################################################\n    # draw our border into the framebuffer\n\n    my $c = $self->{cell_class};\n  \n    my $b_top = $border_style;\n    my $b_left = $border_style;\n    my $b_right = $border_style; \n    my $b_bottom = $border_style;\n    if ($c !~ 'ga')\n      {\n      $b_top = 'none' unless $c =~ /gt/;\n      $b_left = 'none' unless $c =~ /gl/;\n      $b_right = 'none' unless $c =~ /gr/;\n      $b_bottom = 'none' unless $c =~ /gb/;\n      }\n\n    $self->_draw_border($fb, $b_right, $b_bottom, $b_left, $b_top, $x, $y);\n    }\n\n  if ($self->{has_label})\n    {\n    # include our label\n\n    my $align = $self->attribute('align');\n    # the default label cell as a top border, but no left/right border\n    my $ys = 0.5;\n    $ys = 0 if $border_style eq 'none';\n    my $h = $self->{h} - 1; $h ++ if $border_style eq 'none';\n\n    $self->_printfb_aligned ($fb, 0, $ys, $self->{w}, $h, \n\t$self->_aligned_label($align), 'middle');\n    }\n\n  join (\"\\n\", @$fb);\n  }\n\nsub class\n  {\n  my $self = shift;\n\n  $self->{class} . $self->{cell_class};\n  }\n\n#############################################################################\n\n# for rendering this cell as ASCII/Boxart, we need to correct our width based\n# on whether we have a border or not. But this is only known after parsing is\n# complete.\n\nsub _correct_size\n  {\n  my ($self,$format) = @_;\n\n  if (!defined $self->{w})\n    {\n    my $border = $self->attribute('borderstyle');\n    $self->{w} = 0;\n    $self->{h} = 0;\n    # label needs space\n    $self->{h} = 1 if $self->{has_label};\n    if ($border ne 'none')\n      {\n      # class \"gt\", \"gb\", \"gr\" or \"gr\" will be compressed away\n      # (e.g. only edge cells will be existant)\n      if ($self->{has_label} || ($self->{cell_class} =~ /g[rltb] /))\n\t{\n\t$self->{w} = 2;\n\t$self->{h} = 2;\n\t}\n      elsif ($self->{cell_class} =~ /^ g[rl]\\z/)\n\t{\n\t$self->{w} = 2;\n\t}\n      elsif ($self->{cell_class} =~ /^ g[bt]\\z/)\n\t{\n\t$self->{h} = 2;\n\t}\n      }\n    }\n  if ($self->{has_label})\n    {\n    my ($w,$h) = $self->dimensions();\n    $self->{h} += $h;\n    $self->{w} += $w;\n    }\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Group::Cell - A cell in a group\n\n=head1 SYNOPSIS\n\n        use Graph::Easy;\n\n\tmy $ssl = Graph::Easy::Edge->new( );\n\n\t$ssl->set_attributes(\n\t\tlabel => 'encrypted connection',\n\t\tstyle => '-->',\n\t\tcolor => 'red',\n\t);\n\n\t$graph = Graph::Easy->new();\n\n\t$graph->add_edge('source', 'destination', $ssl);\n\n\tprint $graph->as_ascii();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Group::Cell> represents a cell of a group.\n\nGroup cells can have a background and, if they are on the outside, a border.\n\nThere should be no need to use this package directly.\n\n=head1 METHODS\n\n=head2 error()\n\n\t$last_error = $group->error();\n\n\t$group->error($error);\t\t\t# set new messags\n\t$group->error('');\t\t\t# clear error\n\nReturns the last error message, or '' for no error.\n\n=head2 as_ascii()\n\n\tmy $ascii = $cell->as_ascii();\n\nReturns the cell as a little ascii representation.\n\n=head2 as_html()\n\n\tmy $html = $cell->as_html($tag,$id);\n\nReturns the cell as HTML code.\n\n=head2 label()\n\n\tmy $label = $cell->label();\n\nReturns the name (also known as 'label') of the cell.\n\n=head2 class()\n\n\tmy $class = $cell->class();\n\nReturns the classname(s) of this cell, like:\n\n\tgroup_cities gr gb\n\nfor a cell with a bottom (gb) and right (gr) border in the class C<cities>.\n\n=head1 EXPORT\n\nNone.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Group.pm": "#############################################################################\n# A group of nodes. Part of Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Group;\n\nuse Graph::Easy::Group::Cell;\nuse Graph::Easy;\nuse Scalar::Util qw/weaken/;\n\n@ISA = qw/Graph::Easy::Node Graph::Easy/;\n$VERSION = '0.22';\n\nuse strict;\n\n#############################################################################\n\nsub _init\n  {\n  # generic init, override in subclasses\n  my ($self,$args) = @_;\n  \n  $self->{name} = 'Group #'. $self->{id};\n  $self->{class} = 'group';\n  $self->{_cells} = {};\t\t\t\t# the Group::Cell objects\n#  $self->{cx} = 1;\n#  $self->{cy} = 1;\n\n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(graph|name)\\z/)\n      {\n      require Carp;\n      Carp::confess (\"Invalid argument '$k' passed to Graph::Easy::Group->new()\");\n      }\n    $self->{$k} = $args->{$k};\n    }\n  \n  $self->{nodes} = {};\n  $self->{groups} = {};\n  $self->{att} = {};\n\n  $self;\n  }\n\n#############################################################################\n# accessor methods\n\nsub nodes\n  {\n  my $self = shift;\n\n  wantarray ? ( values %{$self->{nodes}} ) : scalar keys %{$self->{nodes}};\n  }\n\nsub edges\n  {\n  # edges leading from/to this group\n  my $self = shift;\n\n  wantarray ? ( values %{$self->{edges}} ) : scalar keys %{$self->{edges}};\n  }\n\nsub edges_within\n  {\n  # edges between nodes inside this group\n  my $self = shift;\n\n  wantarray ? ( values %{$self->{edges_within}} ) : \n\t\tscalar keys %{$self->{edges_within}};\n  }\n\nsub _groups_within\n  {\n  my ($self, $level, $max_level, $cur) = @_;\n\n  no warnings 'recursion';\n\n  push @$cur, values %{$self->{groups}};\n\n  return if $level >= $max_level;\n\n  for my $g (values %{$self->{groups}})\n    {\n    $g->_groups_within($level+1,$max_level, $cur) if scalar keys %{$g->{groups}} > 0;\n    }\n  }\n\n#############################################################################\n\nsub set_attribute\n  {\n  my ($self, $name, $val, $class) = @_;\n\n  $self->SUPER::set_attribute($name, $val, $class);\n\n  # if defined attribute \"nodeclass\", put our nodes into that class\n  if ($name eq 'nodeclass')\n    {\n    my $class = $self->{att}->{nodeclass};\n    for my $node (values %{ $self->{nodes} } )\n      {\n      $node->sub_class($class);\n      }\n    }\n  $self;\n  }\n\nsub shape\n  {\n  my ($self) = @_;\n\n  # $self->{att}->{shape} || $self->attribute('shape');\n  '';\n  }\n\n#############################################################################\n# node handling\n\nsub add_node\n  {\n  # add a node to this group\n  my ($self,$n) = @_;\n\n  if (!ref($n) || !$n->isa(\"Graph::Easy::Node\"))\n    {\n    if (!ref($self->{graph}))\n      {\n      return $self->error(\"Cannot add non node-object $n to group '$self->{name}'\");\n      }\n    $n = $self->{graph}->add_node($n);\n    }\n  $self->{nodes}->{ $n->{name} } = $n;\n\n  # if defined attribute \"nodeclass\", put our nodes into that class\n  $n->sub_class($self->{att}->{nodeclass}) if exists $self->{att}->{nodeclass};\n\n  # register ourselves with the member\n  $n->{group} = $self;\n\n  # set the proper attribute (for layout)\n  $n->{att}->{group} = $self->{name};\n\n  # Register the nodes and the edge with our graph object\n  # and weaken the references. Be carefull to not needlessly\n  # override and weaken again an already existing reference, this\n  # is an O(N) operation in most Perl versions, and thus very slow.\n\n  # If the node does not belong to a graph yet or belongs to another\n  # graph, add it to our own graph:\n  weaken($n->{graph} = $self->{graph}) unless\n\t$n->{graph} && $self->{graph} && $n->{graph} == $self->{graph};\n\n  $n;\n  }\n\nsub add_member\n  {\n  # add a node or group to this group\n  my ($self,$n) = @_;\n \n  if (!ref($n) || !$n->isa(\"Graph::Easy::Node\"))\n    {\n    if (!ref($self->{graph}))\n      {\n      return $self->error(\"Cannot add non node-object $n to group '$self->{name}'\");\n      }\n    $n = $self->{graph}->add_node($n);\n    }\n  return $self->_add_edge($n) if $n->isa(\"Graph::Easy::Edge\");\n  return $self->add_group($n) if $n->isa('Graph::Easy::Group');\n\n  $self->{nodes}->{ $n->{name} } = $n;\n\n  # if defined attribute \"nodeclass\", put our nodes into that class\n  my $cl = $self->attribute('nodeclass');\n  $n->sub_class($cl) if $cl ne '';\n\n  # register ourselves with the member\n  $n->{group} = $self;\n\n  # set the proper attribute (for layout)\n  $n->{att}->{group} = $self->{name};\n\n  # Register the nodes and the edge with our graph object\n  # and weaken the references. Be carefull to not needlessly\n  # override and weaken again an already existing reference, this\n  # is an O(N) operation in most Perl versions, and thus very slow.\n\n  # If the node does not belong to a graph yet or belongs to another\n  # graph, add it to our own graph:\n  weaken($n->{graph} = $self->{graph}) unless\n\t$n->{graph} && $self->{graph} && $n->{graph} == $self->{graph};\n\n  $n;\n  }\n\nsub del_member\n  {\n  # delete a node or group from this group\n  my ($self,$n) = @_;\n\n  # XXX TOOD: groups vs. nodes\n  my $class = 'nodes'; my $key = 'name';\n  if ($n->isa('Graph::Easy::Group'))\n    {\n    # XXX TOOD: groups vs. nodes\n    $class = 'groups'; $key = 'id';\n    }\n  delete $self->{$class}->{ $n->{$key} };\n  delete $n->{group};\t\t\t# unregister us\n\n  if ($n->isa('Graph::Easy::Node'))\n    {\n    # find all edges that mention this node and drop them from the group\n    my $edges = $self->{edges_within};\n    for my $e (values %$edges)\n      {\n      delete $edges->{ $e->{id} } if $e->{from} == $n || $e->{to} == $n;\n      }\n    }\n\n  $self;\n  }\n\nsub del_node\n  {\n  # delete a node from this group\n  my ($self,$n) = @_;\n\n  delete $self->{nodes}->{ $n->{name} };\n  delete $n->{group};\t\t\t# unregister us\n  delete $n->{att}->{group};\t\t# delete the group attribute\n\n  # find all edges that mention this node and drop them from the group\n  my $edges = $self->{edges_within};\n  for my $e (values %$edges)\n    {\n    delete $edges->{ $e->{id} } if $e->{from} == $n || $e->{to} == $n;\n    }\n\n  $self;\n  }\n\nsub add_nodes\n  {\n  my $self = shift;\n\n  # make a copy in case of scalars\n  my @arg = @_;\n  foreach my $n (@arg)\n    {\n    if (!ref($n) && !ref($self->{graph}))\n      {\n      return $self->error(\"Cannot add non node-object $n to group '$self->{name}'\");\n      }\n    return $self->error(\"Cannot add group-object $n to group '$self->{name}'\")\n      if $n->isa('Graph::Easy::Group');\n\n    $n = $self->{graph}->add_node($n) unless ref($n);\n\n    $self->{nodes}->{ $n->{name} } = $n;\n\n    # set the proper attribute (for layout)\n    $n->{att}->{group} = $self->{name};\n\n#   XXX TODO TEST!\n#    # if defined attribute \"nodeclass\", put our nodes into that class\n#    $n->sub_class($self->{att}->{nodeclass}) if exists $self->{att}->{nodeclass};\n\n    # register ourselves with the member\n    $n->{group} = $self;\n\n    # Register the nodes and the edge with our graph object\n    # and weaken the references. Be carefull to not needlessly\n    # override and weaken again an already existing reference, this\n    # is an O(N) operation in most Perl versions, and thus very slow.\n\n    # If the node does not belong to a graph yet or belongs to another\n    # graph, add it to our own graph:\n    weaken($n->{graph} = $self->{graph}) unless\n\t$n->{graph} && $self->{graph} && $n->{graph} == $self->{graph};\n\n    }\n\n  @arg;\n  }\n\n#############################################################################\n\nsub _del_edge\n  {\n  # delete an edge from this group\n  my ($self,$e) = @_;\n\n  delete $self->{edges_within}->{ $e->{id} };\n  delete $e->{group};\t\t\t# unregister us\n\n  $self;\n  }\n\nsub _add_edge\n  {\n  # add an edge to this group (e.g. when both from/to of this edge belong\n  # to this group)\n  my ($self,$e) = @_;\n\n  if (!ref($e) || !$e->isa(\"Graph::Easy::Edge\"))\n    {\n    return $self->error(\"Cannot add non edge-object $e to group '$self->{name}'\");\n    }\n  $self->{edges_within}->{ $e->{id} } = $e;\n\n  # if defined attribute \"edgeclass\", put our edges into that class\n  my $edge_class = $self->attribute('edgeclass');\n  $e->sub_class($edge_class) if $edge_class ne '';\n\n  # XXX TODO: inline\n  $self->add_node($e->{from});\n  $self->add_node($e->{to});\n\n  # register us, but don't do weaken() if the ref was already set\n  weaken($e->{group} = $self) unless defined $e->{group} && $e->{group} == $self;\n\n  $e;\n  }\n\nsub add_edge\n  {\n  # Add an edge to the graph of this group, then register it with this group.\n  my ($self,$from,$to) = @_;\n\n  my $g = $self->{graph};\n  return $self->error(\"Cannot add edge to group '$self->{name}' without graph\")\n    unless defined $g;\n\n  my $edge = $g->add_edge($from,$to);\n\n  $self->_add_edge($edge);\n  }\n\nsub add_edge_once\n  {\n  # Add an edge to the graph of this group, then register it with this group.\n  my ($self,$from,$to) = @_;\n\n  my $g = $self->{graph};\n  return $self->error(\"Cannot non edge to group '$self->{name}' without graph\")\n    unless defined $g;\n\n  my $edge = $g->add_edge_once($from,$to);\n  # edge already exists => so fetch it\n  $edge = $g->edge($from,$to) unless defined $edge;\n\n  $self->_add_edge($edge);\n  }\n\n#############################################################################\n\nsub add_group\n  {\n  # add a group to us\n  my ($self,$group) = @_;\n\n  # group with that name already exists?\n  my $name = $group;\n  $group = $self->{groups}->{ $group } unless ref $group;\n\n  # group with that name doesn't exist, so create new one\n  $group = $self->{graph}->add_group($name) unless ref $group;\n\n  # index under the group name for easier lookup\n  $self->{groups}->{ $group->{name} } = $group;\n\n  # make attribute->('group') work\n  $group->{att}->{group} = $self->{name};\n\n  # register group with the graph and ourself\n  $group->{graph} = $self->{graph};\n  $group->{group} = $self;\n  {\n    no warnings; # dont warn on already weak references\n    weaken($group->{graph});\n    weaken($group->{group});\n  }\n  $self->{graph}->{score} = undef;\t\t# invalidate last layout\n\n  $group;\n  }\n\n# cell management - used by the layouter\n\nsub _cells\n  {\n  # return all the cells this group currently occupies\n  my $self = shift;\n\n  $self->{_cells};\n  }\n\nsub _clear_cells\n  {\n  # remove all belonging cells\n  my $self = shift;\n\n  $self->{_cells} = {};\n\n  $self;\n  }\n\nsub _add_cell\n  {\n  # add a cell to the list of cells this group covers\n  my ($self,$cell) = @_;\n\n  $cell->_update_boundaries();\n  $self->{_cells}->{\"$cell->{x},$cell->{y}\"} = $cell;\n  $cell;\n  }\n\nsub _del_cell\n  {\n  # delete a cell from the list of cells this group covers\n  my ($self,$cell) = @_;\n\n  delete $self->{_cells}->{\"$cell->{x},$cell->{y}\"};\n  delete $cell->{group};\n\n  $self;\n  }\n\nsub _find_label_cell\n  {\n  # go through all cells of this group and find one where to attach the label\n  my $self = shift;\n\n  my $g = $self->{graph};\n\n  my $align = $self->attribute('align');\n  my $loc = $self->attribute('labelpos');\n\n  # depending on whether the label should be on top or bottom:\n  my $match = qr/^\\s*gt\\s*\\z/;\n  $match = qr/^\\s*gb\\s*\\z/ if $loc eq 'bottom';\n\n  my $lc;\t\t\t\t\t\t# the label cell\n\n  for my $c (values %{$self->{_cells}})\n    {\n    # find a cell where to put the label\n    next unless $c->{cell_class} =~ $match;\n\n    if (defined $lc)\n      {\n      if ($align eq 'left')\n\t{\n\t# find top-most, left-most cell\n\tnext if $lc->{x} < $c->{x} || $lc->{y} < $c->{y};\n\t}\n      elsif ($align eq 'center')\n\t{\n\t# just find any top-most cell\n\tnext if $lc->{y} < $c->{y};\n\t}\n      elsif ($align eq 'right')\n\t{\n\t# find top-most, right-most cell\n\tnext if $lc->{x} > $c->{x} || $lc->{y} < $c->{y};\n\t}\n      }  \n    $lc = $c;\n    }\n\n  # find the cell mostly near the center in the found top-row\n  if (ref($lc) && $align eq 'center')\n    {\n    my ($left, $right);\n    # find left/right most coordinates\n    for my $c (values %{$self->{_cells}})\n      {\n      next if $c->{y} != $lc->{y};\n      $left = $c->{x} if !defined $left || $left > $c->{x};  \n      $right = $c->{x} if !defined $right || $right < $c->{x};\n      }\n    my $center = int(($right - $left) / 2 + $left);\n    my $min_dist;\n    # find the cell mostly near the center in the found top-row\n    for my $c (values %{$self->{_cells}})\n      {\n      next if $c->{y} != $lc->{y};\n      # squared to get rid of sign\n      my $dist = ($center - $c->{x}); $dist *= $dist;\n      next if defined $min_dist && $dist > $min_dist;\n      $min_dist = $dist; $lc = $c;\n      }\n    }\n\n  print STDERR \"# Setting label for group '$self->{name}' at $lc->{x},$lc->{y}\\n\"\n\tif $self->{debug};\n\n  $lc->_set_label() if ref($lc);\n  }\n\nsub layout\n  {\n  my $self = shift;\n\n  $self->_croak('Cannot call layout() on a Graph::Easy::Group directly.');\n  }\n\nsub _layout\n  {\n  my $self = shift;\n\n  ###########################################################################\n  # set local {debug} for groups\n  local $self->{debug} = $self->{graph}->{debug};\n\n  $self->SUPER::_layout();\n  }\n\nsub _set_cell_types\n  {\n  my ($self, $cells) = @_;\n\n  # Set the right cell class for all of our cells:\n  for my $cell (values %{$self->{_cells}})\n    {\n    $cell->_set_type($cells);\n    }\n \n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Group - A group of nodes (aka subgraph) in Graph::Easy\n\n=head1 SYNOPSIS\n\n        use Graph::Easy;\n\n        my $bonn = Graph::Easy::Node->new('Bonn');\n\n        $bonn->set_attribute('border', 'solid 1px black');\n\n        my $berlin = Graph::Easy::Node->new( name => 'Berlin' );\n\n\tmy $cities = Graph::Easy::Group->new(\n\t\tname => 'Cities',\n\t);\n        $cities->set_attribute('border', 'dashed 1px blue');\n\n\t$cities->add_nodes ($bonn);\n\t# $bonn will be ONCE in the group\n\t$cities->add_nodes ($bonn, $berlin);\n\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Group> represents a group of nodes in an C<Graph::Easy>\nobject. These nodes are grouped together on output.\n\n=head1 METHODS\n\n=head2 new()\n\n\tmy $group = Graph::Easy::Group->new( $options );\n\nCreate a new, empty group. C<$options> are the possible options, see\nL<Graph::Easy::Node> for a list.\n\n=head2 error()\n\n\t$last_error = $group->error();\n\n\t$group->error($error);\t\t\t# set new messags\n\t$group->error('');\t\t\t# clear error\n\nReturns the last error message, or '' for no error.\n\n=head2 as_ascii()\n\n\tmy $ascii = $group->as_ascii();\n\nReturn the group as a little box drawn in ASCII art as a string.\n\n=head2 name()\n\n\tmy $name = $group->name();\n\nReturn the name of the group.\n\n=head2 id()\n\n\tmy $id = $group->id();\n\nReturns the group's unique ID number.\n\n=head2 set_attribute()\n\n        $group->set_attribute('border-style', 'none');\n\nSets the specified attribute of this (and only this!) group to the\nspecified value.\n\n=head2 add_member()\n\n\t$group->add_member($node);\n\t$group->add_member($group);\n\nAdd the specified object to this group and returns this member. If the\npassed argument is a scalar, will treat it as a node name.\n\nNote that each object can only be a member of one group at a time.\n\n=head2 add_node()\n\n\t$group->add_node($node);\n\nAdd the specified node to this group and returns this node.\n\nNote that each object can only be a member of one group at a time.\n\n=head2 add_edge(), add_edge_once()\n\n\t$group->add_edge($edge);\t\t# Graph::Easy::Edge\n\t$group->add_edge($from, $to);\t\t# Graph::Easy::Node or\n\t\t\t\t\t\t# Graph::Easy::Group\n\t$group->add_edge('From', 'To');\t\t# Scalars\n\nIf passed an Graph::Easy::Edge object, moves the nodes involved in\nthis edge to the group.\n\nif passed two nodes, adds these nodes to the graph (unless they already\nexist) and adds an edge between these two nodes. See L<add_edge_once()>\nto avoid creating multiple edges.\n\nThis method works only on groups that are part of a graph.\n\nNote that each object can only be a member of one group at a time,\nand edges are automatically a member of a group if and only if both\nthe target and the destination node are a member of the same group.\n\n=head2 add_group()\n\n\tmy $inner = $group->add_group('Group name');\n\tmy $nested = $group->add_group($group);\n\nAdd a group as subgroup to this group and returns this group.\n\n=head2 del_member()\n\n\t$group->del_member($node);\n\t$group->del_member($group);\n\nDelete the specified object from this group.\n\n=head2 del_node()\n\n\t$group->del_node($node);\n\nDelete the specified node from this group.\n\n=head2 del_edge()\n\n\t$group->del_edge($edge);\n\nDelete the specified edge from this group.\n\n=head2 add_nodes()\n\n\t$group->add_nodes($node, $node2, ... );\n\nAdd all the specified nodes to this group and returns them as a list.\n\n=head2 nodes()\n\n\tmy @nodes = $group->nodes();\n\nReturns a list of all node objects that belong to this group.\n\n=head2 edges()\n\n\tmy @edges = $group->edges();\n\nReturns a list of all edge objects that lead to or from this group.\n\nNote: This does B<not> return edges between nodes that are inside the group,\nfor this see L<edges_within()>.\n\n=head2 edges_within()\n\n\tmy @edges_within = $group->edges_within();\n\nReturns a list of all edge objects that are I<inside> this group, in arbitrary\norder. Edges are automatically considered I<inside> a group if their starting\nand ending node both are in the same group.\n\nNote: This does B<not> return edges between this group and other groups,\nnor edges between this group and nodes outside this group, for this see\nL<edges()>.\n\n=head2 groups()\n\n\tmy @groups = $group->groups();\n\nReturns the contained groups of this group as L<Graph::Easy::Group> objects,\nin arbitrary order.\n  \n=head2 groups_within()\n\n\t# equivalent to $group->groups():\n\tmy @groups = $group->groups_within();\t\t# all\n\tmy @toplevel_groups = $group->groups_within(0);\t# level 0 only\n\nReturn the groups that are inside this group, up to the specified level,\nin arbitrary order.\n\nThe default level is -1, indicating no bounds and thus all contained\ngroups are returned.\n\nA level of 0 means only the direct children, and hence only the toplevel\ngroups will be returned. A level 1 means the toplevel groups and their\ntoplevel children, and so on.\n\n=head2 as_txt()\n\n\tmy $txt = $group->as_txt();\n\nReturns the group as Graph::Easy textual description.\n\n=head2 _find_label_cell()\n\n\t$group->_find_label_cell();\n\nCalled by the layouter once for each group. Goes through all cells of this\ngroup and finds one where to attach the label to. Internal usage only.\n\n=head2 get_attributes()\n\n        my $att = $object->get_attributes();\n\nReturn all effective attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance and default values.\n\nSee also L<raw_attributes()>.\n\n=head2 raw_attributes()\n\n        my $att = $object->get_attributes();\n\nReturn all set attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance, but does not include\ndefault values for unset attributes.\n\nSee also L<get_attributes()>.\n\n=head2 attribute related methods\n\nYou can call all the various attribute related methods like C<set_attribute()>,\nC<get_attribute()>, etc. on a group, too. For example:\n\n\t$group->set_attribute('label', 'by train');\n\tmy $attr = $group->get_attributes();\n\nYou can find more documentation in L<Graph::Easy>.\n\n=head2 layout()\n\nThis routine should not be called on groups, it only works on the graph\nitself.\n\n=head2 shape()\n\n\tmy $shape = $group->shape();\n\nReturns the shape of the group as string.\n\n=head2 has_as_successor()\n\n\tif ($group->has_as_successor($other))\n\t  {\n\t  ...\n\t  }\n\nReturns true if C<$other> (a node or group) is a successor of this group, e.g.\nif there is an edge leading from this group to C<$other>.\n\n=head2 has_as_predecessor()\n\n\tif ($group->has_as_predecessor($other))\n\t  {\n\t  ...\n\t  }\n\nReturns true if the group has C<$other> (a group or node) as predecessor, that\nis if there is an edge leading from C<$other> to this group.\n\n=head2 root_node()\n\n\tmy $root = $group->root_node();\n\nReturn the root node as L<Graph::Easy::Node> object, if it was\nset with the 'root' attribute.\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<Graph::Easy::Node>, L<Graph::Easy::Manual>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Layout/Chain.pm": "#############################################################################\n# One chain of nodes in a Graph::Easy - used internally for layouts.\n#\n# (c) by Tels 2004-2006. Part of Graph::Easy\n#############################################################################\n\npackage Graph::Easy::Layout::Chain;\n\nuse Graph::Easy::Base;\n$VERSION = '0.09';\n@ISA = qw/Graph::Easy::Base/;\n\nuse strict;\n\nuse constant {\n  _ACTION_NODE  => 0, # place node somewhere\n  _ACTION_TRACE => 1, # trace path from src to dest\n  _ACTION_CHAIN => 2, # place node in chain (with parent)\n  _ACTION_EDGES => 3, # trace all edges (shortes connect. first)\n  };\n\n#############################################################################\n\nsub _init\n  {\n  # Generic init routine, to be overriden in subclasses.\n  my ($self,$args) = @_;\n  \n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(start|graph)\\z/)\n      {\n      require Carp;\n      Carp::confess (\"Invalid argument '$k' passed to __PACKAGE__->new()\");\n      }\n    $self->{$k} = $args->{$k};\n    }\n \n  $self->{end} = $self->{start};\n \n  # store chain at node (to lookup node => chain info)\n  $self->{start}->{_chain} = $self;\n  $self->{start}->{_next} = undef;\n\n  $self->{len} = 1;\n\n  $self;\n  }\n\nsub start\n  {\n  # return first node in the chain\n  my $self = shift;\n\n  $self->{start};\n  }\n\nsub end\n  {\n  # return last node in the chain\n  my $self = shift;\n\n  $self->{end};\n  }\n\nsub add_node\n  {\n  # add a node at the end of the chain\n  my ($self, $node) = @_;\n\n  # store at end\n  $self->{end}->{_next} = $node;\n  $self->{end} = $node;\n\n  # store chain at node (to lookup node => chain info)\n  $node->{_chain} = $self;\n  $node->{_next} = undef;\n  \n  $self->{len} ++;\n\n  $self;\n  }\n\nsub length\n  {\n  # Return the length of the chain in nodes. Takes optional\n  # node from where to calculate length.\n  my ($self, $node) = @_;\n\n  return $self->{len} unless defined $node;\n\n  my $len = 0;\n  while (defined $node)\n    {\n    $len++; $node = $node->{_next};\n    }\n\n  $len;\n  }\n\nsub nodes\n  {\n  # return all the nodes in the chain as a list, in order.\n  my $self = shift;\n\n  my @nodes = ();\n  my $n = $self->{start};\n  while (defined $n)\n    {\n    push @nodes, $n;\n    $n = $n->{_next};\n    }\n\n  @nodes;\n  }\n\nsub layout\n  {\n  # Return an action stack containing the nec. actions to\n  # lay out the nodes in the chain, plus any connections between\n  # them.\n  my ($self, $edge) = @_;\n\n  # prevent doing it twice \n  return [] if $self->{_done}; $self->{_done} = 1;\n\n  my @TODO = ();\n\n  my $g = $self->{graph};\n\n  # first, layout all the nodes in the chain:\n\n  # start with first node\n  my $pre = $self->{start}; my $n = $pre->{_next};\n  if (exists $pre->{_todo})\n    {\n    # edges with a flow attribute must be handled differently\n    # XXX TODO: the test for attribute('flow') might be wrong (raw_attribute()?)\n    if ($edge && ($edge->{to} == $pre) && ($edge->attribute('flow') || $edge->has_ports()))\n      {\n      push @TODO, $g->_action( _ACTION_CHAIN, $pre, 0, $edge->{from}, $edge);\n      }\n    else\n      {\n      push @TODO, $g->_action( _ACTION_NODE, $pre, 0, $edge );\n      }\n    }\n\n  print STDERR \"# Stack after first:\\n\" if $g->{debug};\n  $g->_dump_stack(@TODO) if $g->{debug};\n\n  while (defined $n)\n    {\n    if (exists $n->{_todo})\n      {\n      # CHAIN means if $n isn't placed yet, it will be done with\n      # $pre as parent:\n\n      # in case there are multiple edges to the target node, use the first\n      # one to determine the flow:\n      my @edges = $g->edge($pre,$n);\n\n      push @TODO, $g->_action( _ACTION_CHAIN, $n, 0, $pre, $edges[0] );\n      }\n    $pre = $n;\n    $n = $n->{_next};\n    }\n\n  print STDERR \"# Stack after chaining:\\n\" if $g->{debug};\n  $g->_dump_stack(@TODO) if $g->{debug};\n\n  # link from each node to the next\n  $pre = $self->{start}; $n = $pre->{_next};\n  while (defined $n)\n    {\n    # first do edges going from P to N\n    #for my $e (sort { $a->{to}->{name} cmp $b->{to}->{name} } values %{$pre->{edges}})\n    for my $e (values %{$pre->{edges}})\n      {\n      # skip selfloops and backward links, these will be done later\n      next if $e->{to} != $n;\n\n      next unless exists $e->{_todo};\n\n      # skip links from/to groups\n      next if $e->{to}->isa('Graph::Easy::Group') ||\n              $e->{from}->isa('Graph::Easy::Group');\n\n#      # skip edges with a flow\n#      next if exists $e->{att}->{start} || exist $e->{att}->{end};\n\n      push @TODO, [ _ACTION_TRACE, $e ];\n      delete $e->{_todo};\n      }\n\n    } continue { $pre = $n; $n = $n->{_next}; }\n\n  print STDERR \"# Stack after chain-linking:\\n\" if $g->{debug};\n  $g->_dump_stack(@TODO) if $g->{debug};\n\n  # Do all other links inside the chain (backwards, going forward more than\n  # one node etc)\n\n  $n = $self->{start};\n  while (defined $n)\n    {\n    my @edges;\n\n    my @count;\n\n    print STDERR \"# inter-chain link from $n->{name}\\n\" if $g->{debug};\n\n    # gather all edges starting at $n, but do the ones with a flow first\n#    for my $e (sort { $a->{to}->{name} cmp $b->{to}->{name} } values %{$n->{edges}})\n    for my $e (values %{$n->{edges}})\n      {\n      # skip selfloops, these will be done later\n      next if $e->{to} == $n;\n\n      next if !ref($e->{to}->{_chain});\n      next if !ref($e->{from}->{_chain});\n\n      next if $e->has_ports();\n\n      # skip links from/to groups\n      next if $e->{to}->isa('Graph::Easy::Group') ||\n              $e->{from}->isa('Graph::Easy::Group');\n\n      print STDERR \"# inter-chain link from $n->{name} to $e->{to}->{name}\\n\" if $g->{debug};\n\n      # leaving the chain?\n      next if $e->{to}->{_chain} != $self;\n\n#      print STDERR \"#    trying for $n->{name}:\\t $e->{from}->{name} to $e->{to}->{name}\\n\";\n      next unless exists $e->{_todo};\n\n      # calculate for this edge, how far it goes\n      my $count = 0;\n      my $curr = $n;\n      while (defined $curr && $curr != $e->{to})\n        {\n        $curr = $curr->{_next}; $count ++;\n        }\n      if (!defined $curr)\n        {\n        # edge goes backward\n\n        # start at $to\n        $curr = $e->{to};\n        $count = 0;\n        while (defined $curr && $curr != $e->{from})\n          {\n          $curr = $curr->{_next}; $count ++;\n          }\n        $count = 100000 if !defined $curr;\t# should not happen\n        }\n      push @edges, [ $count, $e ];\n      push @count, [ $count, $e->{from}->{name}, $e->{to}->{name} ];\n      }\n\n#    use Data::Dumper; print STDERR \"count\\n\", Dumper(@count);\n\n    # do edges, shortest first \n    for my $e (sort { $a->[0] <=> $b->[0] } @edges)\n      {\n      push @TODO, [ _ACTION_TRACE, $e->[1] ];\n      delete $e->[1]->{_todo};\n      }\n\n    $n = $n->{_next};\n    }\n \n  # also do all selfloops on $n\n  $n = $self->{start};\n  while (defined $n)\n    {\n#    for my $e (sort { $a->{to}->{name} cmp $b->{to}->{name} } values %{$n->{edges}})\n    for my $e (values %{$n->{edges}})\n      {\n      next unless exists $e->{_todo};\n\n#      print STDERR \"# $e->{from}->{name} to $e->{to}->{name} on $n->{name}\\n\";\n#      print STDERR \"# ne $e->{to} $n $e->{id}\\n\" \n#       if $e->{from} != $n || $e->{to} != $n;\t\t# no selfloop?\n\n      next if $e->{from} != $n || $e->{to} != $n;\t# no selfloop?\n\n      push @TODO, [ _ACTION_TRACE, $e ];\n      delete $e->{_todo};\n      }\n    $n = $n->{_next};\n    }\n\n  print STDERR \"# Stack after self-loops:\\n\" if $g->{debug};\n  $g->_dump_stack(@TODO) if $g->{debug};\n\n  # XXX TODO\n  # now we should do any links that start or end at this chain, recursively\n\n  $n = $self->{start};\n  while (defined $n)\n    {\n\n    # all chains that start at this node\n    for my $e (sort { $a->{to}->{name} cmp $b->{to}->{name} } values %{$n->{edges}})\n      {\n      my $to = $e->{to};\n\n      # skip links to groups\n      next if $to->isa('Graph::Easy::Group');\n\n#      print STDERR \"# chain-tracking to: $to->{name} $to->{_chain}\\n\";\n\n      next unless exists $to->{_chain} && ref($to->{_chain}) =~ /Chain/;\n      my $chain = $to->{_chain};\n      next if $chain->{_done};\n\n#      print STDERR \"# chain-tracking to: $to->{name}\\n\";\n\n      # pass the edge along, in case it has a flow\n#      my @pass = ();\n#      push @pass, $e if $chain->{_first} && $e->{to} == $chain->{_first};\n      push @TODO, @{ $chain->layout($e) } unless $chain->{_done};\n\n      # link the edges to $to\n      next unless exists $e->{_todo};\t# was already done above?\n\n      # next if $e->has_ports();\n\n      push @TODO, [ _ACTION_TRACE, $e ];\n      delete $e->{_todo};\n      }\n    $n = $n->{_next};\n    }\n \n  \\@TODO;\n  }\n\nsub dump\n  {\n  # dump the chain to STDERR\n  my ($self, $indent) = @_;\n\n  $indent = '' unless defined $indent;\n\n  print STDERR \"#$indent chain id $self->{id} (len $self->{len}):\\n\";\n  print STDERR \"#$indent is empty\\n\" and return if $self->{len} == 0;\n\n  my $n = $self->{start};\n  while (defined $n)\n    {\n    print STDERR \"#$indent  $n->{name} (chain id: $n->{_chain}->{id})\\n\";\n    $n = $n->{_next};\n    }\n  $self;\n  }\n\nsub merge\n  {\n  # take another chain, and merge it into ourselves. If $where is defined,\n  # absorb only the nodes from $where onwards (instead of all of them).\n  my ($self, $other, $where) = @_;\n\n  my $g = $self->{graph};\n\n  print STDERR \"# panik: \", join(\" \\n\",caller()),\"\\n\" if !defined $other;\n\n  print STDERR \n   \"# Merging chain $other->{id} (len $other->{len}) into $self->{id} (len $self->{len})\\n\"\n     if $g->{debug};\n\n  print STDERR \n   \"# Merging from $where->{name} onwards\\n\"\n     if $g->{debug} && ref($where);\n \n  # cannot merge myself into myself (without allocating infinitely memory)\n  return if $self == $other;\n\n  # start at start as default\n  $where = undef unless ref($where) && exists $where->{_chain} && $where->{_chain} == $other;\n\n  $where = $other->{start} unless defined $where;\n  \n  # make all nodes from chain #1 belong to it (to detect loops)\n  my $n = $self->{start};\n  while (defined $n)\n    {\n    $n->{_chain} = $self;\n    $n = $n->{_next};\n    }\n\n  print STDERR \"# changed nodes\\n\" if $g->{debug};\n  $self->dump() if $g->{debug};\n\n  # terminate at $where\n  $self->{end}->{_next} = $where;\n  $self->{end} = $other->{end};\n\n  # start at joiner\n  $n = $where;\n  while (ref($n))\n    {\n    $n->{_chain} = $self;\n    my $pre = $n;\n    $n = $n->{_next};\n\n#    sleep(1);\n#    print \"# at $n->{name} $n->{_chain}\\n\" if ref($n);\n    if (ref($n) && defined $n->{_chain} && $n->{_chain} == $self)\t# already points into ourself?\n      {\n#      sleep(1);\n#      print \"# pre $pre->{name} $pre->{_chain}\\n\";\n      $pre->{_next} = undef;\t# terminate\n      $self->{end} = $pre;\n      last;\n      }\n    }\n\n  # could speed this up\n  $self->{len} = 0; $n = $self->{start};\n  while (defined $n)\n    {\n    $self->{len}++; $n = $n->{_next};\n    }\n\n#  print \"done merging, dumping result:\\n\";\n#  $self->dump(); sleep(10);\n\n  if (defined $other->{start} && $where == $other->{start})\n    {\n    # we absorbed the other chain completely, so drop it\n    $other->{end} = undef;\n    $other->{start} = undef;\n    $other->{len} = 0;\n    # caller is responsible for cleaning it up\n    }\n\n  print STDERR \"# after merging\\n\" if $g->{debug};\n  $self->dump() if $g->{debug};\n\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout::Chain - Chain of nodes for layouter\n\n=head1 SYNOPSIS\n\n\t# used internally, do not use directly\n\n        use Graph::Easy;\n        use Graph::Easy::Layout::Chain;\n\n\tmy $graph = Graph::Easy->new( );\n\tmy ($node, $node2) = $graph->add_edge( 'A', 'B' );\n\n\tmy $chain = Graph::Easy::Layout::Chain->new(\n\t\tstart => $node,\n\t\tgraph => $graph, );\n\n\t$chain->add_node( $node2 );\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Layout::Chain> object represents a chain of nodes\nfor the layouter.\n\n=head1 METHODS\n\n=head2 new()\n\n        my $chain = Graph::Easy::Layout::Chain->new( start => $node );\n\nCreate a new chain and set its starting node to C<$node>.\n\n=head2 length()\n\n\tmy $len = $chain->length();\n\nReturn the length of the chain, in nodes.\n\n\tmy $len = $chain->length( $node );\n\nGiven an optional C<$node> as argument, returns the length\nfrom that node onwards. For the chain with the three nodes\nA, B and C would return 3, 2, and 1 for A, B and C, respectively.\n\nReturns 0 if the passed node is not part of this chain.\n\n=head2 nodes()\n\n\tmy @nodes = $chain->nodes();\n\nReturn all the node objects in the chain as list, in order.\n\n=head2 add_node()\n\n\t$chain->add_node( $node );\n\nAdd C<$node> to the end of the chain.\n\n=head2 start()\n\n\tmy $node = $chain->start();\n\nReturn first node in the chain.\n\n=head2 end()\n\n\tmy $node = $chain->end();\n\nReturn last node in the chain.\n\n=head2 layout()\n\n\tmy $todo = $chain->layout();\n\nReturn an action stack as array ref, containing the nec. actions to \nlayout the chain (nodes, plus interlinks in the chain).\n\nWill recursively traverse all chains linked to this chain.\n\n=head2 merge()\n\n\tmy $chain->merge ( $other_chain );\n\tmy $chain->merge ( $other_chain, $where );\n\nMerge the other chain into ourselves, adding its nodes at our end.\nThe other chain is emptied and must be deleted by the caller.\n  \nIf C<$where> is defined and a member of C<$other_chain>, absorb only the\nnodes from C<$where> onwards, instead of all of them.\n\n=head2 error()\n\n\t$last_error = $node->error();\n\n\t$node->error($error);\t\t\t# set new messags\n\t$node->error('');\t\t\t# clear error\n\nReturns the last error message, or '' for no error.\n\n=head2 dump()\n\n\t$chain->dump();\n\nDump the chain to STDERR, to aid debugging.\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<Graph::Easy::Layout>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2006 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Layout/Force.pm": "#############################################################################\n# Force-based layouter for Graph::Easy.\n#\n# (c) by Tels 2004-2007.\n#############################################################################\n\npackage Graph::Easy::Layout::Force;\n\n$VERSION = '0.01';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\n\nsub _layout_force\n  {\n  # Calculate for each node the force on it, then move them accordingly.\n  # When things have settled, stop.\n  my ($self) = @_;\n\n  # For each node, calculate the force actiing on it, seperated into two\n  # components along the X and Y axis:\n\n  # XXX TODO: replace with all contained nodes + groups\n  my @nodes = $self->nodes();\n\n  return if @nodes == 0;\n\n  my $root = $self->root_node();\n\n  if (!defined $root)\n    {\n    # find a suitable root node\n    $root = $nodes[0];\n    }\n\n  # this node never moves\n  $root->{_pinned} = undef;\n  $root->{x} = 0;\n  $root->{y} = 0;\n\n  # get the \"gravity\" force\n  my $gx = 0; my $gy = 0;\n\n  my $flow = $self->flow();\n  if ($flow == 0)\n    {\n    $gx = 1;\n    }\n  elsif ($flow == 90)\n    {\n    $gy = -1;\n    }\n  elsif ($flow == 270)\n    {\n    $gy = 1;\n    }\n  else # ($flow == 180)\n    {\n    $gx = -1;\n    }\n\n  my @particles;\n  # set initial positions\n  for my $n (@nodes)\n    {\n    # the net force on this node is the gravity\n    $n->{_x_force} = $gx;\n    $n->{_y_force} = $gy;\n    if ($root == $n || defined $n->{origin})\n      {\n      # nodes that are relative to another are \"pinned\"\n      $n->{_pinned} = undef;\n      }\n    else\n      {\n      $n->{x} = rand(100);\n      $n->{y} = rand(100);\n      push @particles, $n;\n      }\n    }\n\n  my $energy = 1;\n  while ($energy > 0.1)\n    {\n    $energy = 0;\n    for my $n (@particles)\n      {\n      # reset forces on this node\n      $n->{_x_force} = 0;\n      $n->{_y_force} = 0;\n\n      # Add forces of all other nodes. We need to include pinned nodes here,\n      # too, since a moving node might get near a pinned one and get repelled.\n      for my $n2 (@nodes)\n        {\n        next if $n2 == $n;\t\t\t# don't repel yourself\n\n\tmy $dx = ($n->{x} - $n2->{x});\n\tmy $dy = ($n->{y} - $n2->{y});\n\n\tmy $r = $dx * $dx + $dy * $dy;\n\n\t$r = 0.01 if $r < 0.01;\t\t\t# too small? \n\tif ($r < 4)\n\t  {\n\t  # not too big\n\t  $n->{_x_force} += 1 / $dx * $dx;\n\t  $n->{_y_force} += 1 / $dy * $dy;\n\n\t  my $dx2 = 1 / $dx * $dx;\n\t  my $dy2 = 1 / $dy * $dy;\n\n\t  print STDERR \"# Force between $n->{name} and $n2->{name}: fx $dx2, fy $dy2\\n\";\n\t  }\n        }\n\n      # for all edges connected at this node\n      for my $e (values %{$n->{edges}})\n\t{\n\t# exclude self-loops\n\tnext if $e->{from} == $n && $e->{to} == $n;\n\n\t# get the other end-point of this edge\n\tmy $n2 = $e->{from}; $n2 = $e->{to} if $n2 == $n;\n\n\t# XXX TODO\n\t# we should \"connect\" the edges to the appropriate port so that\n\t# they excert an off-center force\n\n\tmy $dx = -($n->{x} - $n2->{x}) / 2;\n\tmy $dy = -($n->{y} - $n2->{y}) / 2;\n\n\tprint STDERR \"# Spring force between $n->{name} and $n2->{name}: fx $dx, fy $dy\\n\";\n\t$n->{_x_force} += $dx; \n\t$n->{_y_force} += $dy;\n\t}\n\n      print STDERR \"# $n->{name}: Summed force: fx $n->{_x_force}, fy $n->{_y_force}\\n\";\n\n      # for grid-like layouts, add a small force drawing this node to the gridpoint\n      # 0.7 => 1 - 0.7 => 0.3\n      # 1.2 => 1 - 1.2 => -0.2\n\n      my $dx = int($n->{x} + 0.5) - $n->{x};\n      $n->{_x_force} += $dx;\n      my $dy = int($n->{y} + 0.5) - $n->{y};\n      $n->{_y_force} += $dy;\n\n      print STDERR \"# $n->{name}: Final force: fx $n->{_x_force}, fy $n->{_y_force}\\n\";\n\n      $energy += $n->{_x_force} * $n->{_x_force} + $n->{_x_force} * $n->{_y_force}; \n\n      print STDERR \"# Net energy: $energy\\n\";\n      }\n\n    # after having calculated all forces, move the nodes\n    for my $n (@particles)\n      {\n      my $dx = $n->{_x_force};\n      $dx = 5 if $dx > 5;\t\t# limit it\n      $n->{x} += $dx;\n\n      my $dy = $n->{_y_force};\n      $dy = 5 if $dy > 5;\t\t# limit it\n      $n->{y} += $dy;\n\n      print STDERR \"# $n->{name}: Position $n->{x}, $n->{y}\\n\";\n      }\n\n    sleep(1); print STDERR \"\\n\";\n    }\n\n  for my $n (@nodes)\n    {\n    delete $n->{_x_force};\n    delete $n->{_y_force};\n    }\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout::Force - Force-based layouter for Graph::Easy\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\t$graph->add_edge ('Bonn', 'Berlin');\n\t$graph->add_edge ('Bonn', 'Ulm');\n\t$graph->add_edge ('Ulm', 'Berlin');\n\n\t$graph->layout( type => 'force' );\n\n\tprint $graph->as_ascii( );\n\n\t# prints:\n\t\n\t#   +------------------------+\n\t#   |                        v\n\t# +------+     +-----+     +--------+\n\t# | Bonn | --> | Ulm | --> | Berlin |\n\t# +------+     +-----+     +--------+\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Layout::Force> contains routines that calculate a\nforce-based layout for a graph.\n\nNodes repell each other, while edges connecting them draw them together.\n\nThe layouter calculates the forces on each node, then moves them around\naccording to these forces until things have settled down.\n\nUsed automatically by Graph::Easy.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 METHODS\n\nThis module injects the following methods into Graph::Easy:\n\n=head2 _layout_force()\n\nCalculates the node position with a force-based method.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Layout/Grid.pm": "#############################################################################\n# Grid-management and layout preperation.\n#\n# (c) by Tels 2004-2006.\n#############################################################################\n\npackage Graph::Easy::Layout::Grid;\n\n$VERSION = '0.07';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\n\nsub _balance_sizes\n  {\n  # Given a list of column/row sizes and a minimum size that their sum must\n  # be, will grow individual sizes until the constraint (sum) is met.\n  my ($self, $sizes, $need) = @_;\n\n  # XXX TODO: we can abort the loop and distribute the remaining nec. size\n  # once all elements in $sizes are equal.\n\n  return if $need < 1;\n\n  # if there is only one element, return it immidiately\n  if (@$sizes == 1)\n    {\n    $sizes->[0] = $need if $sizes->[0] < $need;\n    return;\n    }\n\n  # endless loop until constraint is met\n  while (1)\n    {\n  \n    # find the smallest size, and also compute their sum\n    my $sum = 0; my $i = 0;\n    my $sm = $need + 1;\t\t# start with an arbitrary size\n    my $sm_i = 0;\t\t# if none is != 0, then use the first\n    for my $s (@$sizes)\n      {\n      $sum += $s;\n      next if $s == 0;\n      if ($s < $sm)\n\t{\n        $sm = $s; $sm_i = $i; \n\t}\n      $i++;\n      }\n\n    # their sum is already equal or bigger than what we need?\n    last if $sum >= $need;\n\n    # increase the smallest size by one, then try again\n    $sizes->[$sm_i]++;\n    }\n \n#  use Data::Dumper; print STDERR \"# \" . Dumper($sizes),\"\\n\";\n\n  undef;\n  }\n\nsub _prepare_layout\n  {\n  # this method is used by as_ascii() and as_svg() to find out the\n  # sizes and placement of the different cells (edges, nodes etc).\n  my ($self,$format) = @_;\n\n  # Find out for each row and colum how big they are:\n  #   +--------+-----+------+\n  #   | Berlin | --> | Bonn | \n  #   +--------+-----+------+\n  # results in:\n  #        w,  h,  x,  y\n  # 0,0 => 10, 3,  0,  0\n  # 1,0 => 7,  3,  10, 0\n  # 2,0 => 8,  3,  16, 0\n\n  # Technically, we also need to \"compress\" away non-existant columns/rows.\n  # We achive that by simply rendering them with size 0, so they become\n  # practically invisible.\n\n  my $cells = $self->{cells};\n  my $rows = {};\n  my $cols = {};\n\n  # the last column/row (highest X,Y pair)\n  my $mx = -1000000; my $my = -1000000;\n\n  # We need to do this twice, once for single-cell objects, and again for\n  # objects covering multiple cells. The single-cell objects can be solved\n  # first:\n\n  # find all x and y occurances to sort them by row/columns\n  for my $cell (values %$cells)\n    {\n    my ($x,$y) = ($cell->{x}, $cell->{y});\n\n    {\n      no strict 'refs';\n\n      my $method = '_correct_size_' . $format;\n      $method = '_correct_size' unless $cell->can($method);\n      $cell->$method();\n    }\n\n    my $w = $cell->{w} || 0;\n    my $h = $cell->{h} || 0;\n\n    # Set the minimum cell size only for single-celled objects:\n    if ( (($cell->{cx}||1) + ($cell->{cy}||1)) == 2)\n      { \n      # record maximum size for that col/row\n      $rows->{$y} = $h if $h >= ($rows->{$y} || 0);\n      $cols->{$x} = $w if $w >= ($cols->{$x} || 0);\n      }\n\n    # Find highest X,Y pair. Always use x,y, and not x+cx,y+cy, because\n    # a multi-celled object \"sticking\" out will not count unless there\n    # is another object in the same row/column.\n    $mx = $x if $x > $mx;\n    $my = $y if $y > $my;\n    } \n\n  # insert a dummy row/column with size=0 as last\n  $rows->{$my+1} = 0;\n  $cols->{$mx+1} = 0;\n\n  # do the last step again, but for multi-celled objects\n  for my $cell (values %$cells)\n    {\n    my ($x,$y) = ($cell->{x}, $cell->{y});\n\n    my $w = $cell->{w} || 0;\n    my $h = $cell->{h} || 0;\n\n    # Set the minimum cell size only for multi-celled objects:\n    if ( (($cell->{cx} || 1) + ($cell->{cy}||1)) > 2)\n      {\n      $cell->{cx} ||= 1;\n      $cell->{cy} ||= 1;\n\n      # do this twice, for X and Y:\n\n#      print STDERR \"\\n# \", $cell->{name} || $cell->{id}, \" cx=$cell->{cx} cy=$cell->{cy} $cell->{w},$cell->{h}:\\n\";\n\n      # create an array with the current sizes for the affacted rows/columns\n      my @sizes;\n\n#      print STDERR \"# $cell->{cx} $cell->{cy} at cx:\\n\";\n\n      # XXX TODO: no need to do this for empty/zero cols\n      for (my $i = 0; $i < $cell->{cx}; $i++)\n        {\n        push @sizes, $cols->{$i+$x} || 0;\n\t}\n      $self->_balance_sizes(\\@sizes, $cell->{w});\n      # store the result back\n      for (my $i = 0; $i < $cell->{cx}; $i++)\n        {\n#        print STDERR \"# store back $sizes[$i] to col \", $i+$x,\"\\n\";\n        $cols->{$i+$x} = $sizes[$i];\n\t}\n\n      @sizes = ();\n\n#      print STDERR \"# $cell->{cx} $cell->{cy} at cy:\\n\";\n\n      # XXX TODO: no need to do this for empty/zero cols\n      for (my $i = 0; $i < $cell->{cy}; $i++)\n        {\n        push @sizes, $rows->{$i+$y} || 0;\n\t}\n      $self->_balance_sizes(\\@sizes, $cell->{h});\n      # store the result back\n      for (my $i = 0; $i < $cell->{cy}; $i++)\n        {\n#        print STDERR \"# store back $sizes[$i] to row \", $i+$y,\"\\n\";\n        $rows->{$i+$y} = $sizes[$i];\n\t}\n      }\n    } \n\n  print STDERR \"# Calculating absolute positions for rows/columns\\n\" if $self->{debug};\n\n  # Now run through all rows/columns and get their absolute pos by taking all\n  # previous ones into account.\n  my $pos = 0;\n  for my $y (sort { $a <=> $b } keys %$rows)\n    {\n    my $s = $rows->{$y};\n    $rows->{$y} = $pos;\t\t\t# first is 0, second is $rows[1] etc\n    $pos += $s;\n    }\n  $pos = 0;\n  for my $x (sort { $a <=> $b } keys %$cols)\n    {\n    my $s = $cols->{$x};\n    $cols->{$x} = $pos;\n    $pos += $s;\n    }\n\n  # find out max. dimensions for framebuffer\n  print STDERR \"# Finding max. dimensions for framebuffer\\n\" if $self->{debug};\n  my $max_y = 0; my $max_x = 0;\n\n  for my $v (values %$cells)\n    {\n    # Skip multi-celled nodes for later. \n    next if ($v->{cx}||1) + ($v->{cy}||1) != 2;\n\n    # X and Y are col/row, so translate them to real pos\n    my $x = $cols->{ $v->{x} };\n    my $y = $rows->{ $v->{y} };\n\n    # Also set correct the width/height of each cell to be the maximum\n    # width/height of that row/column and store the previous size in 'minw'\n    # and 'minh', respectively.\n\n    $v->{minw} = $v->{w};\n    $v->{minh} = $v->{h};\n\n    # find next col/row\n    my $nx = $v->{x} + 1;\n    my $next_col = $cols->{ $nx };\n    my $ny = $v->{y} + 1;\n    my $next_row = $rows->{ $ny };\n\n    $next_col = $cols->{ ++$nx } while (!defined $next_col);\n    $next_row = $rows->{ ++$ny } while (!defined $next_row);\n\n    $v->{w} = $next_col - $x;\n    $v->{h} = $next_row - $y;\n\n    my $m = $y + $v->{h} - 1;\n    $max_y = $m if $m > $max_y;\n    $m = $x + $v->{w} - 1;\n    $max_x = $m if $m > $max_x;\n    }\n\n  # repeat the previous step, now for multi-celled objects\n  foreach my $v (values %{$self->{cells}})\n    {\n    next unless defined $v->{x} && (($v->{cx}||1) + ($v->{cy}||1) > 2);\n\n    # X and Y are col/row, so translate them to real pos\n    my $x = $cols->{ $v->{x} };\n    my $y = $rows->{ $v->{y} };\n\n    $v->{minw} = $v->{w};\n    $v->{minh} = $v->{h};\n\n    # find next col/row\n    my $nx = $v->{x} + ($v->{cx} || 1);\n    my $next_col = $cols->{ $nx };\n    my $ny = $v->{y} + ($v->{cy} || 1);\n    my $next_row = $rows->{ $ny };\n\n    $next_col = $cols->{ ++$nx } while (!defined $next_col);\n    $next_row = $rows->{ ++$ny } while (!defined $next_row);\n\n    $v->{w} = $next_col - $x;\n    $v->{h} = $next_row - $y;\n\n    my $m = $y + $v->{h} - 1;\n    $max_y = $m if $m > $max_y;\n    $m = $x + $v->{w} - 1;\n    $max_x = $m if $m > $max_x;\n    }\n\n  # return what we found out:\n  ($rows,$cols,$max_x,$max_y);\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout::Grid - Grid management and size calculation\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\t$graph->layout();\n\n\tprint $graph->as_ascii( );\n\n\t# prints:\n\n\t# +------+     +--------+\n\t# | Bonn | --> | Berlin |\n\t# +------+     +--------+\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Layout::Grid> contains routines that calculate cell sizes\non the grid, which is necessary for ASCII, boxart and SVG output.\n\nUsed automatically by Graph::Easy.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 METHODS\n\nThis module injects the following methods into Graph::Easy:\n\n=head2 _prepare_layout()\n\n  \tmy ($rows,$cols,$max_x,$max_y, \\@V) = $graph->_prepare_layout();\n\nReturns two hashes (C<$rows> and C<$cols>), containing the columns and rows\nof the layout with their nec. sizes (in chars) plus the maximum\nframebuffer size nec. for this layout. Also returns reference of\na list of all cells to be rendered.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2006 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Layout/Path.pm": "#############################################################################\n# Path and cell management for Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Layout::Path;\n\n$VERSION = '0.16';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy::Node;\n\nuse strict;\n\nuse Graph::Easy::Edge::Cell qw/\n EDGE_END_E EDGE_END_N EDGE_END_S EDGE_END_W\n/;\n\nsub _shuffle_dir\n  {\n  # take a list with four entries and shuffle them around according to $dir\n  my ($self, $e, $dir) = @_;\n\n  # $dir: 0 => north, 90 => east, 180 => south, 270 => west\n\n  $dir = 90 unless defined $dir;\t\t# default is east\n\n  return [ @$e ] if $dir == 90;\t\t\t# default is no shuffling\n\n  my @shuffle = (0,1,2,3);\t\t\t# the default\n  @shuffle = (1,2,0,3) if $dir == 180;\t\t# south\n  @shuffle = (2,3,1,0) if $dir == 270;\t\t# west\n  @shuffle = (3,0,2,1) if $dir == 0;\t\t# north\n\n  [\n    $e->[ $shuffle[0] ],\n    $e->[ $shuffle[1] ],\n    $e->[ $shuffle[2] ],\n    $e->[ $shuffle[3] ],\n  ];\n  }\n\nsub _shift\n  {\n  # get a flow shifted by X° to $dir\n  my ($self, $turn) = @_;\n\n  my $dir = $self->flow();\n\n  $dir += $turn;\n  $dir += 360 if $dir < 0;\n  $dir -= 360 if $dir > 360;\n  $dir;\n  }\n\nsub _near_places\n  {\n  # Take a node and return a list of possible placements around it and\n  # prune out already occupied cells. $d is the distance from the node\n  # border and defaults to two (for placements). Set it to one for\n  # adjacent cells. \n\n  # If defined, $type contains four flags for each direction. If undef,\n  # two entries (x,y) will be returned for each pos, instead of (x,y,type).\n\n  # If $loose is true, no checking whether the returned fields are free\n  # is done.\n\n  my ($n, $cells, $d, $type, $loose, $dir) = @_;\n\n  my $cx = $n->{cx} || 1;\n  my $cy = $n->{cy} || 1;\n  \n  $d = 2 unless defined $d;\t\t# default is distance = 2\n\n  my $flags = $type;\n\n  if (ref($flags) ne 'ARRAY')\n    {\n    $flags = [\n      EDGE_END_W,\n      EDGE_END_N,\n      EDGE_END_E,\n      EDGE_END_S,\n     ];\n    }\n  $dir = $n->flow() unless defined $dir;\n\n  my $index = $n->_shuffle_dir( [ 0,3,6,9], $dir);\n\n  my @places = ();\n\n  # single-celled node\n  if ($cx + $cy == 2)\n    {\n    my @tries  = (\n  \t$n->{x} + $d, $n->{y}, $flags->[0],\t# right\n\t$n->{x}, $n->{y} + $d, $flags->[1],\t# down\n\t$n->{x} - $d, $n->{y}, $flags->[2],\t# left\n\t$n->{x}, $n->{y} - $d, $flags->[3],\t# up\n      );\n\n    for my $i (0..3)\n      {\n      my $idx = $index->[$i];\n      my ($x,$y,$t) = ($tries[$idx], $tries[$idx+1], $tries[$idx+2]);\n\n#      print STDERR \"# Considering place $x, $y \\n\";\n\n      # This quick check does not take node clusters or multi-celled nodes\n      # into account. These are handled in $node->_do_place() later.\n      next if !$loose && exists $cells->{\"$x,$y\"};\n      push @places, $x, $y;\n      push @places, $t if defined $type;\n      }\n    return @places;\n    }\n\n  # Handle a multi-celled node. For a 3x2 node:\n  #      A   B   C\n  #   J [00][10][20] D\n  #   I [10][11][21] E\n  #      H   G   F\n  # we have 10 (3 * 2 + 2 * 2) places to consider\n\n  my $nx = $n->{x};\n  my $ny = $n->{y};\n  my ($px,$py);\n\n  my $idx = 0;\n  my @results = ( [], [], [], [] );\n \n  $cy--; $cx--;\n  my $t = $flags->[$idx++];\n  # right\n  $px = $nx + $cx + $d;\n  for my $y (0 .. $cy)\n    {\n    $py = $y + $ny;\n    next if exists $cells->{\"$px,$py\"} && !$loose;\n    push @{$results[0]}, $px, $py;\n    push @{$results[0]}, $t if defined $type;\n    }\n\n  # below\n  $py = $ny + $cy + $d;\n  $t = $flags->[$idx++];\n  for my $x (0 .. $cx)\n    {\n    $px = $x + $nx;\n    next if exists $cells->{\"$px,$py\"} && !$loose;\n    push @{$results[1]}, $px, $py;\n    push @{$results[1]}, $t if defined $type;\n    }\n\n  # left\n  $px = $nx - $d;\n  $t = $flags->[$idx++];\n  for my $y (0 .. $cy)\n    {\n    $py = $y + $ny;\n    next if exists $cells->{\"$px,$py\"} && !$loose;\n    push @{$results[2]}, $px, $py;\n    push @{$results[2]}, $t if defined $type;\n    }\n\n  # top\n  $py = $ny - $d;\n  $t = $flags->[$idx];\n  for my $x (0 .. $cx)\n    {\n    $px = $x + $nx;\n    next if exists $cells->{\"$px,$py\"} && !$loose;\n    push @{$results[3]}, $px, $py;\n    push @{$results[3]}, $t if defined $type;\n    }\n\n  # accumulate the results in the requested, shuffled order\n  for my $i (0..3)\n    {\n    my $idx = $index->[$i] / 3;\n    push @places, @{$results[$idx]};\n    }\n\n  @places;\n  }\n\nsub _allowed_places\n  {\n  # given a list of potential positions, and a list of allowed positions,\n  # return the valid ones (e.g. that are in both lists)\n  my ($self, $places, $allowed, $step) = @_;\n\n  print STDERR \n   \"# calculating allowed places for $self->{name} from \" . @$places . \n   \" positions and \" . scalar @$allowed . \" allowed ones:\\n\"\n    if $self->{graph}->{debug};\n\n  $step ||= 2;\t\t\t\t# default: \"x,y\"\n\n  my @good;\n  my $i = 0;\n  while ($i < @$places)\n    {\n    my ($x,$y) = ($places->[$i], $places->[$i+1]);\n    my $allow = 0;\n    my $j = 0;\n    while ($j < @$allowed)\n      {\n      my ($m,$n) = ($allowed->[$j], $allowed->[$j+1]);\n      $allow++ and last if ($m == $x && $n == $y);\n      } continue { $j += 2; }\n    next unless $allow;\n    push @good, $places->[$i + $_ -1] for (1..$step);\n    } continue { $i += $step; }\n\n  print STDERR \"#  left with \" . ((scalar @good) / $step) . \" position(s)\\n\" if $self->{graph}->{debug};\n  @good;\n  }\n\nsub _allow\n  {\n  # return a list of places, depending on the start/end atribute:\n  # \"south\" - any place south\n  # \"south,0\" - first place south\n  # \"south,-1\" - last place south  \n  # XXX TODO:\n  # \"south,0..2\" - first three places south\n  # \"south,0,1,-1\" - first, second and last place south  \n\n  my ($self, $dir, @pos) = @_;\n\n  # for relative direction, get the absolute flow from the node\n  if ($dir =~ /^(front|forward|back|left|right)\\z/)\n    {\n    # get the flow at the node\n    $dir = $self->flow();\n    }\n\n  my $place = {\n    'south' => [  0,0, 0,1, 'cx', 1,0 ],\n    'north' => [ 0,-1, 0,0, 'cx', 1,0 ],\n    'east' =>  [  0,0, 1,0, 'cy', 0,1 ],\n    'west' =>  [ -1,0, 0,0, 'cy', 0,1 ] ,\n    180 => [  0,0, 0,1, 'cx', 1,0 ],\n    0 => [ 0,-1, 0,0, 'cx', 1,0 ],\n    90 =>  [  0,0, 1,0, 'cy', 0,1 ],\n    270 =>  [ -1,0, 0,0, 'cy', 0,1 ] ,\n    };\n\n  my $p = $place->{$dir};\n\n  return [] unless defined $p;\n\n  # start pos\n  my $x = $p->[0] + $self->{x} + $p->[2] * $self->{cx};\n  my $y = $p->[1] + $self->{y} + $p->[3] * $self->{cy};\n\n  my @allowed;\n  push @pos, '' if @pos == 0;\n\n  my $c = $p->[4];\n  if (@pos == 1 && $pos[0] eq '')\n    {\n    # allow all of them\n    for (1 .. $self->{$c})\n      {\n      push @allowed, $x, $y;\n      $x += $p->[5];\n      $y += $p->[6];\n      }\n    } \n  else\n    {\n    # allow only the given position\n    my $ps = $pos[0];\n    # limit to 0..$self->{cx}-1\n    $ps = $self->{$c} + $ps if $ps < 0;\n    $ps = 0 if $ps < 0;\n    $ps = $self->{$c} - 1 if $ps >= $self->{$c};\n    $x += $p->[5] * $ps;\n    $y += $p->[6] * $ps;\n    push @allowed, $x, $y;\n    }\n\n  \\@allowed;\n  }\n\npackage Graph::Easy;\nuse strict;\nuse Graph::Easy::Node::Cell;\n\nuse Graph::Easy::Edge::Cell qw/\n  EDGE_HOR EDGE_VER EDGE_CROSS\n  EDGE_TYPE_MASK\n  EDGE_HOLE\n /;\n\nsub _clear_tries\n  {\n  # Take a list of potential positions for a node, and then remove the\n  # ones that are immidiately near any other node.\n  # Returns a list of \"good\" positions. Afterwards $node->{x} is undef.\n  my ($self, $node, $cells, $tries) = @_;\n\n  my $src = 0; my @new;\n\n  print STDERR \"# clearing \", scalar @$tries / 2, \" tries for $node->{name}\\n\" if $self->{debug};\n\n  my $node_grandpa = $node->find_grandparent();\n\n  while ($src < scalar @$tries)\n    {\n    # check the current position\n\n    # temporary place node here\n    my $x = $tries->[$src];\n    my $y = $tries->[$src+1];\n\n#    print STDERR \"# checking $x,$y\\n\" if $self->{debug};\n\n    $node->{x} = $x;\n    $node->{y} = $y;\n\n    my @near = $node->_near_places($cells, 1, undef, 1);\n\n    # push also the four corner cells to avoid placing nodes corner-to-corner\n    push @near, $x-1, $y-1,\t\t\t\t\t# upperleft corner\n                $x-1, $y+($node->{cy}||1),\t\t\t# lowerleft corner\n                $x+($node->{cx}||1), $y+($node->{cy}||1),\t# lowerright corner\n                $x+($node->{cx}||1), $y-1;\t\t\t# upperright corner\n    \n    # check all near places to be free from nodes (except our children)\n    my $j = 0; my $g = 0;\n    while ($j < @near)\n      {\n      my $xy = $near[$j]. ',' . $near[$j+1];\n\n#      print STDERR \"# checking near-place: $xy: \" . ref($cells->{$xy}) . \"\\n\" if $self->{debug};\n      \n      my $cell = $cells->{$xy};\n\n      # skip, unless we are a children of node, or the cell is our children\n      next unless ref($cell) && $cell->isa('Graph::Easy::Node');\n\n      my $grandpa = $cell->find_grandparent();\n\n      #       this cell is our children\n      #                            this cell is our grandpa\n      #                                                      has the same grandpa as node\n      next if $grandpa == $node || $cell == $node_grandpa || $grandpa == $node_grandpa;\n\n      $g++; last;\n\n      } continue { $j += 2; }\n\n    if ($g == 0)\n      {\n      push @new, $tries->[$src], $tries->[$src+1];\n      }\n    $src += 2;\n    }\n\n  $node->{x} = undef;\n\n  @new;\n  }\n\nmy $flow_shift = {\n  270 => [ 0, -1 ],\n   90 => [ 0,  1 ],\n    0 => [ 1,  0 ],\n  180 => [ -1, 0 ],\n  };\n\nsub _placed_shared\n  {\n  # check whether one of the nodes from the list of shared was already placed\n  my ($self) = shift;\n\n  my $placed;\n  for my $n (@_)\n    {\n    $placed = [$n->{x}, $n->{y}] and last if defined $n->{x};\n    }\n  $placed;\n  }\n\nsub _find_node_place\n  {\n  # Try to place a node (or node cluster). Return score (usually 0).\n  my ($self, $node, $try, $parent, $edge) = @_;\n\n  $try ||= 0;\n\n  print STDERR \"# Finding place for $node->{name}, try #$try\\n\" if $self->{debug};\n  print STDERR \"# Parent node is '$parent->{name}'\\n\" if $self->{debug} && ref $parent;\n\n  print STDERR \"# called from \". join (\" \", caller) . \"\\n\" if $self->{debug};\n\n  # If the node has a user-set rank, see if we already placed another node in that\n  # row/column\n  if ($node->{rank} >= 0)\n    {\n    my $r = abs($node->{rank});\n#    print STDERR \"# User-set rank for $node->{name} (rank $r)\\n\";\n    my $c = $self->{_rank_coord};\n#    use Data::Dumper; print STDERR \"# rank_pos: \\n\", Dumper($self->{_rank_pos});\n    if (exists $self->{_rank_pos}->{ $r })\n      {\n      my $co = { x => 0, y => 0 };\n      $co->{$c} = $self->{_rank_pos}->{ $r };\n      while (1 < 3)\n        {\n#\tprint STDERR \"# trying to force placement of '$node->{name}' at $co->{x} $co->{y}\\n\";    \n        return 0 if $node->_do_place($co->{x},$co->{y},$self);\n        $co->{$c} += 2;\n        }\n      }\n    }\n\n  my $cells = $self->{cells};\n\n#  local $self->{debug} = 1;\n\n  my $min_dist = 2;\n  # minlen = 0 => min_dist = 2,\n  # minlen = 1 => min_dist = 2, \n  # minlen = 2 => min_dist = 3, etc\n  $min_dist = $edge->attribute('minlen') + 1 if ref($edge);\n\n  # if the node has outgoing edges (which might be shared)\n  if (!ref($edge))\n    {\n    (undef,$edge) = each %{$node->{edges}} if keys %{$node->{edges}} > 0;\n    }\n\n  my $dir = undef; $dir = $edge->flow() if ref($edge);\n\n  my @tries;\n#  if (ref($parent) && defined $parent->{x})\n  if (keys %{$node->{edges}} > 0)\n    {\n    my $src_node = $parent; $src_node = $edge->{from} if ref($edge) && !ref($parent);\n    print STDERR \"#  from $src_node->{name} to $node->{name}: edge $edge dir $dir\\n\" if $self->{debug};\n\n    # if there are more than one edge to this node, and they share a start point,\n    # move the node at least 3 cells away to create space for the joints\n\n    my ($s_p, @ss_p);\n    ($s_p, @ss_p) = $edge->port('start') if ref($edge);\n\n    my ($from,$to);\n    if (ref($edge))\n      {\n      $from = $edge->{from}; $to = $edge->{to};\n      }\n\n    my @shared_nodes;\n    @shared_nodes = $from->nodes_sharing_start($s_p,@ss_p) if defined $s_p && @ss_p > 0;\n\n    print STDERR \"# Edge from '$src_node->{name}' shares an edge start with \", scalar @shared_nodes, \" other nodes\\n\"\n\tif $self->{debug};\n\n    if (@shared_nodes > 1)\n      {\n      $min_dist = 3 if $min_dist < 3;\t\t\t\t# make space\n      $min_dist++ if $edge->label() ne '';\t\t\t# make more space for the label\n\n      # if we are the first shared node to be placed\n      my $placed = $self->_placed_shared(@shared_nodes);\n\n      if (defined $placed)\n        {\n        # we are not the first, so skip the placement below\n\t# instead place on the same column/row as already placed node(s)\n        my ($bx, $by) = @$placed;\n\n\tmy $flow = $node->flow();\n\n\tprint STDERR \"# One of the shared nodes was already placed at ($bx,$by) with flow $flow\\n\"\n\t  if $self->{debug};\n\n\tmy $ofs = 2;\t\t\t# start with a distance of 2\n\tmy ($mx, $my) = @{ ($flow_shift->{$flow} || [ 0, 1 ]) };\n\n\twhile (1)\n\t  {\n\t  my $x = $bx + $mx * $ofs; my $y = $by + $my * $ofs;\n\n\t  print STDERR \"# Trying to place $node->{name} at ($x,$y)\\n\"\n\t    if $self->{debug};\n\n\t  next if $self->_clear_tries($node, $cells, [ $x,$y ]) == 0;\n\t  last if $node->_do_place($x,$y,$self);\n\t  }\n\tcontinue {\n\t    $ofs += 2;\n\t  }\n        return 0;\t\t\t# found place already\n\t} # end we-are-the-first-to-be-placed\n      }\n\n    # shared end point?\n    ($s_p, @ss_p) = $edge->port('end') if ref($edge);\n\n    @shared_nodes = $to->nodes_sharing_end($s_p,@ss_p) if defined $s_p && @ss_p > 0;\n\n    print STDERR \"# Edge from '$src_node->{name}' shares an edge end with \", scalar @shared_nodes, \" other nodes\\n\"\n\tif $self->{debug};\n\n    if (@shared_nodes > 1)\n      {\n      $min_dist = 3 if $min_dist < 3;\n      $min_dist++ if $edge->label() ne '';\t\t\t# make more space for the label\n\n      # if the node to be placed is not in the list to be placed, it is the end-point\n      \n      # see if we are the first shared node to be placed\n      my $placed = $self->_placed_shared(@shared_nodes);\n\n#      print STDERR \"# \"; for (@shared_nodes) { print $_->{name}, \" \"; } print \"\\n\";\n\n      if ((grep( $_ == $node, @shared_nodes)) && defined $placed)\n\t{\n        # we are not the first, so skip the placement below\n\t# instead place on the same column/row as already placed node(s)\n        my ($bx, $by) = @$placed;\n\n\tmy $flow = $node->flow();\n\n\tprint STDERR \"# One of the shared nodes was already placed at ($bx,$by) with flow $flow\\n\"\n\t  if $self->{debug};\n\n\tmy $ofs = 2;\t\t\t# start with a distance of 2\n\tmy ($mx, $my) = @{ ($flow_shift->{$flow} || [ 0, 1 ]) };\n\n\twhile (1)\n\t  {\n\t  my $x = $bx + $mx * $ofs; my $y = $by + $my * $ofs;\n\n\t  print STDERR \"# Trying to place $node->{name} at ($x,$y)\\n\"\n\t    if $self->{debug};\n\n\t  next if $self->_clear_tries($node, $cells, [ $x,$y ]) == 0;\n\t  last if $node->_do_place($x,$y,$self);\n\t  }\n\tcontinue {\n\t    $ofs += 2;\n\t  }\n        return 0;\t\t\t# found place already\n\t} # end we-are-the-first-to-be-placed\n      }\n    }\n\n  if (ref($parent) && defined $parent->{x})\n    {\n    @tries = $parent->_near_places($cells, $min_dist, undef, 0, $dir);\n\n    print STDERR \n\t\"# Trying chained placement of $node->{name} with min distance $min_dist from parent $parent->{name}\\n\"\n\tif $self->{debug};\n\n    # weed out positions that are unsuitable\n    @tries = $self->_clear_tries($node, $cells, \\@tries);\n\n    splice (@tries,0,$try) if $try > 0;\t# remove the first N tries\n    print STDERR \"# Left with \" . scalar @tries . \" tries for node $node->{name}\\n\" if $self->{debug};\n\n    while (@tries > 0)\n      {\n      my $x = shift @tries;\n      my $y = shift @tries;\n\n      print STDERR \"# Trying to place $node->{name} at $x,$y\\n\" if $self->{debug};\n      return 0 if $node->_do_place($x,$y,$self);\n      } # for all trial positions\n    }\n\n  print STDERR \"# Trying to place $node->{name} at 0,0\\n\" if $try == 0 && $self->{debug};\n  # Try to place node at upper left corner (the very first node to be\n  # placed will usually end up there).\n  return 0 if $try == 0 && $node->_do_place(0,0,$self);\n\n  # try to place node near the predecessor(s)\n  my @pre_all = $node->predecessors();\n\n  print STDERR \"# Predecessors of $node->{name} \" . scalar @pre_all . \"\\n\" if $self->{debug};\n\n  # find all already placed predecessors\n  my @pre;\n  for my $p (@pre_all)\n    {\n    push @pre, $p if defined $p->{x};\n    print STDERR \"# Placed predecessors of $node->{name}: $p->{name} at $p->{x},$p->{y}\\n\" if $self->{debug} && defined $p->{x};\n    }\n\n  # sort predecessors on their rank (to try first the higher ranking ones on placement)\n  @pre = sort { $b->{rank} <=> $a->{rank} } @pre;\n\n  print STDERR \"# Number of placed predecessors of $node->{name}: \" . scalar @pre . \"\\n\" if $self->{debug};\n\n  if (@pre <= 2 && @pre > 0)\n    {\n\n    if (@pre == 1)\n      {\n      # only one placed predecessor, so place $node near it\n      print STDERR \"# placing $node->{name} near predecessor\\n\" if $self->{debug};\n      @tries = ( $pre[0]->_near_places($cells, $min_dist), $pre[0]->_near_places($cells,$min_dist+2) ); \n      }\n    else\n      {\n      # two placed predecessors, so place at crossing point of both of them\n      # compute difference between the two nodes\n\n      my $dx = ($pre[0]->{x} - $pre[1]->{x});\n      my $dy = ($pre[0]->{y} - $pre[1]->{y});\n\n      # are both nodes NOT on a straight line?\n      if ($dx != 0 && $dy != 0)\n        {\n        # ok, so try to place at the crossing point\n\t@tries = ( \n\t  $pre[0]->{x}, $pre[1]->{y},\n\t  $pre[0]->{y}, $pre[1]->{x},\n\t);\n        }\n      else\n        {\n        # two nodes on a line, try to place node in the middle\n        if ($dx == 0)\n          {\n\t  @tries = ( $pre[1]->{x}, $pre[1]->{y} + int($dy / 2) );\n          }\n        else\n          {\n\t  @tries = ( $pre[1]->{x} + int($dx / 2), $pre[1]->{y} );\n          }\n        }\n      # XXX TODO BUG: shouldnt we also try this if we have more than 2 placed\n      # predecessors?\n\n      # In addition, we can also try to place the node around the\n      # different nodes:\n      foreach my $n (@pre)\n        {\n        push @tries, $n->_near_places($cells, $min_dist);\n        }\n      }\n    }\n\n  my @suc_all = $node->successors();\n\n  # find all already placed successors\n  my @suc;\n  for my $s (@suc_all)\n    {\n    push @suc, $s if defined $s->{x};\n    }\n  print STDERR \"# Number of placed successors of $node->{name}: \" . scalar @suc . \"\\n\" if $self->{debug};\n  foreach my $s (@suc)\n    {\n    # for each successors (especially if there is only one), try to place near\n    push @tries, $s->_near_places($cells, $min_dist); \n    push @tries, $s->_near_places($cells, $min_dist + 2);\n    }\n\n  # weed out positions that are unsuitable\n  @tries = $self->_clear_tries($node, $cells, \\@tries);\n\n  print STDERR \"# Left with \" . scalar @tries . \" for node $node->{name}\\n\" if $self->{debug};\n\n  splice (@tries,0,$try) if $try > 0;\t# remove the first N tries\n  \n  while (@tries > 0)\n    {\n    my $x = shift @tries;\n    my $y = shift @tries;\n\n    print STDERR \"# Trying to place $node->{name} at $x,$y\\n\" if $self->{debug};\n    return 0 if $node->_do_place($x,$y,$self);\n\n    } # for all trial positions\n\n  ##############################################################################\n  # all simple possibilities exhausted, try a generic approach\n\n  print STDERR \"# No more simple possibilities for node $node->{name}\\n\" if $self->{debug};\n\n  # XXX TODO:\n  # find out which sides of the node predecessor node(s) still have free\n  # ports/slots. With increasing distances, try to place the node around these.\n\n  # If no predecessors/incoming edges, try to place in column 0, otherwise \n  # considered the node's rank, too\n\n  my $col = 0; $col = $node->{rank} * 2 if @pre > 0;\n\n  $col = $pre[0]->{x} if @pre > 0;\n  \n  # find the first free row\n  my $y = 0;\n  $y +=2 while (exists $cells->{\"$col,$y\"});\n  $y += 1 if exists $cells->{\"$col,\" . ($y-1)};\t\t# leave one cell spacing\n\n  # now try to place node (or node cluster)\n  while (1)\n    {\n    next if $self->_clear_tries($node, $cells, [ $col,$y ]) == 0;\n    last if $node->_do_place($col,$y,$self);\n    }\n    continue {\n    $y += 2;\n    }\n\n  $node->{x} = $col; \n\n  0;\t\t\t\t\t\t\t# success, score 0 \n  }\n\nsub _trace_path\n  {\n  # find a free way from $src to $dst (both need to be placed beforehand)\n  my ($self, $src, $dst, $edge) = @_;\n\n  print STDERR \"# Finding path from '$src->{name}' to '$dst->{name}'\\n\" if $self->{debug};\n  print STDERR \"# src: $src->{x}, $src->{y} dst: $dst->{x}, $dst->{y}\\n\" if $self->{debug};\n\n  my $coords = $self->_find_path ($src, $dst, $edge);\n\n  # found no path?\n  if (!defined $coords)\n    {\n    print STDERR \"# Unable to find path from $src->{name} ($src->{x},$src->{y}) to $dst->{name} ($dst->{x},$dst->{y})\\n\" if $self->{debug};\n    return undef;\n    }\n\n  # path is empty, happens for sharing edges with only a joint\n  return 1 if scalar @$coords == 0;\n\n  # Create all cells from the returned list and score path (lower score: better)\n  my $i = 0;\n  my $score = 0;\n  while ($i < scalar @$coords)\n    {\n    my $type = $coords->[$i+2];\n    $self->_create_cell($edge,$coords->[$i],$coords->[$i+1],$type);\n    $score ++;\t\t\t\t\t# each element: one point\n    $type &= EDGE_TYPE_MASK;\t\t\t# mask flags\n    # edge bend or cross: one point extra\n    $score ++ if $type != EDGE_HOR && $type != EDGE_VER;\n    $score += 3 if $type == EDGE_CROSS;\t\t# crossings are doubleplusungood\n    $i += 3;\n    }\n\n  $score;\n  }\n\nsub _create_cell\n  {\n  my ($self,$edge,$x,$y,$type) = @_;\n\n  my $cells = $self->{cells}; my $xy = \"$x,$y\";\n  \n  if (ref($cells->{$xy}) && $cells->{$xy}->isa('Graph::Easy::Edge'))\n    {\n    $cells->{$xy}->_make_cross($edge,$type & EDGE_FLAG_MASK);\n    # insert a EDGE_HOLE into the cells of the edge (but not into the list of\n    # to-be-rendered cells). This cell will be removed by the optimizer later on.\n    Graph::Easy::Edge::Cell->new( type => EDGE_HOLE, edge => $edge, x => $x, y => $y );\n    return;\n    }\n\n  my $path = Graph::Easy::Edge::Cell->new( type => $type, edge => $edge, x => $x, y => $y );\n  $cells->{$xy} = $path;\t# store in cells\n  }\n\nsub _path_is_clear\n  {\n  # For all points (x,y pairs) in the path, check that the cell is still free\n  # $path points to a list of [ x,y,type, x,y,type, ...]\n  my ($self,$path) = @_;\n\n  my $cells = $self->{cells};\n  my $i = 0;\n  while ($i < scalar @$path)\n    {\n    my $x = $path->[$i];\n    my $y = $path->[$i+1];\n    # my $t = $path->[$i+2];\n    $i += 3;\n\n    return 0 if exists $cells->{\"$x,$y\"};\t# obstacle hit\n    } \n  1;\t\t\t\t\t\t# path is clear\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout::Path - Path management for Manhattan-style grids\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\t$graph->layout();\n\n\tprint $graph->as_ascii( );\n\n\t# prints:\n\n\t# +------+     +--------+\n\t# | Bonn | --> | Berlin |\n\t# +------+     +--------+\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Layout::Scout> contains just the actual path-managing code for\nL<Graph::Easy|Graph::Easy>, e.g. to create/destroy/maintain paths, node\nplacement etc.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 METHODS into Graph::Easy\n\nThis module injects the following methods into C<Graph::Easy>:\n\n=head2 _path_is_clear()\n\n\t$graph->_path_is_clear($path);\n\nFor all points (x,y pairs) in the path, check that the cell is still free.\nC<$path> points to a list x,y,type pairs as in C<< [ [x,y,type], [x,y,type], ...] >>.\n\n=head2 _create_cell()\n\n\tmy $cell = $graph->($edge,$x,$y,$type);\n\nCreate a cell at C<$x,$y> coordinates with type C<$type> for the specified\nedge.\n\n=head2 _path_is_clear()\n\n\t$graph->_path_is_clear();\n\nFor all points (x,y pairs) in the path, check that the cell is still free.\nC<$path> points to a list of C<[ x,y,type, x,y,type, ...]>.\n\nReturns true when the path is clear, false otherwise.\n\n=head2 _trace_path()\n\n\tmy $path = my $graph->_trace_path($src,$dst,$edge);\n\nFind a free way from source node/group to destination node/group for the\nspecified edge. Both source and destination need to be placed beforehand.\n\n=head1 METHODS in Graph::Easy::Node\n\nThis module injects the following methods into C<Graph::Easy::Node>:\n\n=head2 _near_places()\n\n\tmy $node->_near_places();\n  \nTake a node and return a list of possible placements around it and\nprune out already occupied cells. $d is the distance from the node\nborder and defaults to two (for placements). Set it to one for\nadjacent cells. \n\n=head2 _shuffle_dir()\n\n\tmy $dirs = $node->_shuffle_dir( [ 0,1,2,3 ], $dir);\n\nTake a ref to an array with four entries and shuffle them around according to\nC<$dir>.\n\n=head2 _shift()\n\n\tmy $dir = $node->_shift($degrees);\n\nReturn a the C<flow()> direction shifted by X degrees to C<$dir>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Layout/Repair.pm": "#############################################################################\n# Layout directed graphs on a flat plane. Part of Graph::Easy.\n#\n# Code to repair spliced layouts (after group cells have been inserted).\n#\n#############################################################################\n\npackage Graph::Easy::Layout::Repair;\n\n$VERSION = '0.08';\n\n#############################################################################\n#############################################################################\n# for layouts with groups:\n\npackage Graph::Easy;\n\nuse strict;\n\nsub _edges_into_groups\n  {\n  my $self = shift;\n\n  # Put all edges between two nodes with the same group in the group as well\n  for my $edge (values %{$self->{edges}})\n    {\n    my $gf = $edge->{from}->group();\n    my $gt = $edge->{to}->group();\n\n    $gf->_add_edge($edge) if defined $gf && defined $gt && $gf == $gt;\n    }\n\n  $self;\n  }\n\nsub _repair_nodes\n  {\n  # Splicing the rows/columns to add filler cells will have torn holes into\n  # multi-edges nodes, so we insert additional filler cells.\n  my ($self) = @_;\n  my $cells = $self->{cells};\n\n  # Make multi-celled nodes occupy the proper double space due to splicing\n  # in group cell has doubled the layout in each direction:\n  for my $n ($self->nodes())\n    {\n    # 1 => 1, 2 => 3, 3 => 5, 4 => 7 etc\n    $n->{cx} = $n->{cx} * 2 - 1;\n    $n->{cy} = $n->{cy} * 2 - 1;\n    }\n\n  # We might get away with not inserting filler cells if we just mark the\n  # cells as used (e.g. use only one global filler cell) since filler cells\n  # aren't actually rendered, anyway.\n\n  for my $cell (values %$cells)\n    {\n    next unless $cell->isa('Graph::Easy::Node::Cell');\n\n    # we have \"[ empty  ] [ filler ]\" (unless cell is on the same column as node)\n    if ($cell->{x} > $cell->{node}->{x})\n      {\n      my $x = $cell->{x} - 1; my $y = $cell->{y}; \n\n#      print STDERR \"# inserting filler at $x,$y for $cell->{node}->{name}\\n\";\n      $cells->{\"$x,$y\"} = \n        Graph::Easy::Node::Cell->new(node => $cell->{node}, x => $x, y => $y );\n      }\n\n    # we have \" [ empty ]  \"\n    #         \" [ filler ] \" (unless cell is on the same row as node)\n    if ($cell->{y} > $cell->{node}->{y})\n      {\n      my $x = $cell->{x}; my $y = $cell->{y} - 1;\n\n#      print STDERR \"# inserting filler at $x,$y for $cell->{node}->{name}\\n\";\n      $cells->{\"$x,$y\"} = \n        Graph::Easy::Node::Cell->new(node => $cell->{node}, x => $x, y => $y );\n      }\n    }\n  }\n\nsub _repair_cell\n  {\n  my ($self, $type, $edge, $x, $y, $after, $before) = @_;\n\n  # already repaired?\n  return if exists $self->{cells}->{\"$x,$y\"};\n\n#  print STDERR \"# Insert edge cell at $x,$y (type $type) for edge $edge->{from}->{name} --> $edge->{to}->{name}\\n\";\n\n  $self->{cells}->{\"$x,$y\"} =\n    Graph::Easy::Edge::Cell->new( \n      type => $type, \n      edge => $edge, x => $x, y => $y, before => $before, after => $after );\n\n  }\n\nsub _splice_edges\n  {\n  # Splicing the rows/columns to add filler cells might have torn holes into\n  # edges, so we splice these together again.\n  my ($self) = @_;\n\n  my $cells = $self->{cells};\n\n  print STDERR \"# Reparing spliced layout\\n\" if $self->{debug};\n\n  # Edge end/start points inside groups are not handled here, but in\n  # _repair_group_edge()\n\n  # go over the old layout, because the new cells were inserted into odd\n  # rows/columns and we do not care for these:\n  for my $cell (sort { $a->{x} <=> $b->{x} || $a->{y} <=> $b->{y} } values %$cells)\n    {\n    next unless $cell->isa('Graph::Easy::Edge::Cell');\n \n    my $edge = $cell->{edge}; \n\n    #########################################################################\n    # check for \"[ JOINT ] [ empty  ] [ edge ]\"\n    \n    my $x = $cell->{x} + 2; my $y = $cell->{y}; \n\n    my $type = $cell->{type} & EDGE_TYPE_MASK;\n\n    # left is a joint and right exists\n    if ( ($type == EDGE_S_E_W || $type == EDGE_N_E_W || $type == EDGE_E_N_S)\n         && exists $cells->{\"$x,$y\"})\n      {\n      my $right = $cells->{\"$x,$y\"};\n\n#      print STDERR \"# at $x,$y\\n\";\n\n      # |-> [ empty ] [ node ]\n      if ($right->isa('Graph::Easy::Edge::Cell'))\n\t{\n        # when the left one is a joint, the right one must be an edge\n        $self->error(\"Found non-edge piece ($right->{type} $right) right to a joint ($type)\") \n          unless $right->isa('Graph::Easy::Edge::Cell');\n\n#        print STDERR \"splicing in HOR piece to the right of joint at $x, $y ($edge $right $right->{edge})\\n\";\n\n        # insert the new piece before the first part of the edge after the joint\n        $self->_repair_cell(EDGE_HOR(), $right->{edge},$cell->{x}+1,$y,0)\n          if $edge != $right->{edge};\n        }\n      }\n\n    #########################################################################\n    # check for \"[ edge ] [ empty  ] [ joint ]\"\n    \n    $x = $cell->{x} - 2; $y = $cell->{y}; \n\n    # right is a joint and left exists\n    if ( ($type == EDGE_S_E_W || $type == EDGE_N_E_W || $type == EDGE_W_N_S)\n         && exists $cells->{\"$x,$y\"})\n     {\n      my $left = $cells->{\"$x,$y\"};\n\n      # [ node ] [ empty ] [ <-| ]\n      if (!$left->isa('Graph::Easy::Node'))\n\t{\n        # when the left one is a joint, the right one must be an edge\n        $self->error('Found non-edge piece right to a joint') \n          unless $left->isa('Graph::Easy::Edge::Cell');\n\n        # insert the new piece before the joint\n        $self->_repair_cell(EDGE_HOR(), $edge, $cell->{x}+1,$y,0) # $left,$cell)\n          if $edge != $left->{edge};\n\t}\n      }\n\n    #########################################################################\n    # check for \" [ joint ]\n    #\t\t  [ empty ]\n    #             [ edge ]\"\n    \n    $x = $cell->{x}; $y = $cell->{y} + 2; \n\n    # top is a joint and down exists\n    if ( ($type == EDGE_S_E_W || $type == EDGE_E_N_S || $type == EDGE_W_N_S)\n         && exists $cells->{\"$x,$y\"})\n     {\n      my $bottom = $cells->{\"$x,$y\"};\n\n      # when top is a joint, the bottom one must be an edge\n      $self->error('Found non-edge piece below a joint') \n        unless $bottom->isa('Graph::Easy::Edge::Cell');\n\n#      print STDERR \"splicing in VER piece below joint at $x, $y\\n\";\n\n\t# XXX TODO\n      # insert the new piece after the joint\n      $self->_repair_cell(EDGE_VER(), $bottom->{edge},$x,$cell->{y}+1,0)\n        if $edge != $bottom->{edge}; \n      }\n\n    #########################################################################\n    # check for \"[ --- ] [ empty  ] [ ---> ]\"\n\n    $x = $cell->{x} + 2; $y = $cell->{y}; \n\n    if (exists $cells->{\"$x,$y\"})\n      {\n      my $right = $cells->{\"$x,$y\"};\n\n      $self->_repair_cell(EDGE_HOR(), $edge, $cell->{x}+1,$y,$cell,$right)\n        if $right->isa('Graph::Easy::Edge::Cell') && \n           defined $right->{edge} && defined $right->{type} &&\n\t# check that both cells belong to the same edge\n\t(  $edge == $right->{edge}  ||\n\t# or the right part is a cross\n\t   $right->{type} == EDGE_CROSS ||\n\t# or the left part is a cross\n\t   $cell->{type} == EDGE_CROSS );\n      }\n    \n    #########################################################################\n    # check for [ | ]\n    #\t\t[ empty ]\n    #\t\t[ | ]\n    $x = $cell->{x}; $y = $cell->{y}+2; \n\n    if (exists $cells->{\"$x,$y\"})\n      {\n      my $below = $cells->{\"$x,$y\"};\n\n      $self->_repair_cell(EDGE_VER(),$edge,$x,$cell->{y}+1,$cell,$below)\n\tif $below->isa('Graph::Easy::Edge::Cell') &&\n        # check that both cells belong to the same edge\n\t(  $edge == $below->{edge}  ||\n\t# or the lower part is a cross\n\t   $below->{type} == EDGE_CROSS ||\n\t# or the upper part is a cross\n\t   $cell->{type} == EDGE_CROSS );\n      }\n\n    } # end for all cells\n\n  $self;\n  }\n\nsub _new_edge_cell\n  {\n  # create a new edge cell to be spliced into the layout for repairs\n  my ($self, $cells, $group, $edge, $x, $y, $after, $type) = @_;\n\n  $type += EDGE_SHORT_CELL() if defined $group;\n\n  my $e_cell = Graph::Easy::Edge::Cell->new( \n\t  type => $type, edge => $edge, x => $x, y => $y, after => $after);\n  $group->_del_cell($e_cell) if defined $group;\n  $cells->{\"$x,$y\"} = $e_cell;\n  }\n\nsub _check_edge_cell\n  {\n  # check a start/end edge cell and if nec. repair it\n  my ($self, $cell, $x, $y, $flag, $type, $match, $check, $where) = @_;\n\n  my $edge = $cell->{edge};\n  if (grep { exists $_->{cell_class} && $_->{cell_class} =~ $match } values %$check)\n    {\n    $cell->{type} &= ~ $flag;\t\t# delete the flag\n\n    $self->_new_edge_cell(\n\t$self->{cells}, $edge->{group}, $edge, $x, $y, $where, $type + $flag);\n    }\n  }\n\nsub _repair_group_edge\n  {\n  # repair an edges inside a group\n  my ($self, $cell, $rows, $cols, $group) = @_;\n\n  my $cells = $self->{cells};\n  my ($x,$y,$doit);\n\n  my $type = $cell->{type};\n\n  #########################################################################\n  # check for \" [ empty ] [ |---> ]\"\n  $x = $cell->{x} - 1; $y = $cell->{y};\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_START_W, EDGE_HOR, qr/g[rl]/, $cols->{$x}, 0)\n    if (($type & EDGE_START_MASK) == EDGE_START_W);\n\n  #########################################################################\n  # check for \" [ <--- ] [ empty ]\"\n  $x = $cell->{x} + 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_START_E, EDGE_HOR, qr/g[rl]/, $cols->{$x}, 0)\n    if (($type & EDGE_START_MASK) == EDGE_START_E);\n\n  #########################################################################\n  # check for \" [ --> ] [ empty ]\"\n  $x = $cell->{x} + 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_END_E, EDGE_HOR, qr/g[rl]/, $cols->{$x}, -1)\n    if (($type & EDGE_END_MASK) == EDGE_END_E);\n\n#  $self->_check_edge_cell($cell, $x, $y, EDGE_END_E, EDGE_E_N_S, qr/g[rl]/, $cols->{$x}, -1)\n#    if (($type & EDGE_END_MASK) == EDGE_END_E);\n\n  #########################################################################\n  # check for \" [ empty ] [ <-- ]\"\n  $x = $cell->{x} - 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_END_W, EDGE_HOR, qr/g[rl]/, $cols->{$x}, -1)\n    if (($type & EDGE_END_MASK) == EDGE_END_W);\n\n  #########################################################################\n  #########################################################################\n  # vertical cases\n\n  #########################################################################\n  # check for [empty] \n  #           [ | ]\n  $x = $cell->{x}; $y = $cell->{y} - 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_START_N, EDGE_VER, qr/g[tb]/, $rows->{$y}, 0)\n    if (($type & EDGE_START_MASK) == EDGE_START_N);\n\n  #########################################################################\n  # check for [ |] \n  #           [ empty ]\n  $y = $cell->{y} + 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_START_S, EDGE_VER, qr/g[tb]/, $rows->{$y}, 0)\n    if (($type & EDGE_START_MASK) == EDGE_START_S);\n\n  #########################################################################\n  # check for [ v ]\n  #           [empty] \n  $y = $cell->{y} + 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_END_S, EDGE_VER, qr/g[tb]/, $rows->{$y}, -1)\n    if (($type & EDGE_END_MASK) == EDGE_END_S);\n\n  #########################################################################\n  # check for [ empty ]\n  #           [ ^     ] \n  $y = $cell->{y} - 1;\n\n  $self->_check_edge_cell($cell, $x, $y, EDGE_END_N, EDGE_VER, qr/g[tb]/, $rows->{$y}, -1)\n    if (($type & EDGE_END_MASK) == EDGE_END_N);\n  }\n\nsub _repair_edge\n  {\n  # repair an edge outside a group\n  my ($self, $cell, $rows, $cols) = @_;\n\n  my $cells = $self->{cells};\n\n  #########################################################################\n  # check for [ |\\n|\\nv ]\n  #\t        [empty]\t... [non-empty]\n  #\t        [node]\n\n  my $x = $cell->{x}; my $y = $cell->{y} + 1;\n\n  my $below = $cells->{\"$x,$y\"}; \t\t# must be empty\n\n  if  (!ref($below) && (($cell->{type} & EDGE_END_MASK) == EDGE_END_S))\n    {\n    if (grep { exists $_->{cell_class} && $_->{cell_class} =~ /g[tb]/ } values %{$rows->{$y}})\n      {\n      # delete the start flag\n      $cell->{type} &= ~ EDGE_END_S;\n\n      $self->_new_edge_cell($cells, undef, $cell->{edge}, $x, $y, -1, \n          EDGE_VER() + EDGE_END_S() );\n      }\n    }\n  # XXX TODO: do the other ends (END_N, END_W, END_E), too\n\n  }\n\nsub _repair_edges\n  {\n  # fix edge end/start cells to be closer to the node cell they point at\n  my ($self, $rows, $cols) = @_;\n\n  my $cells = $self->{cells};\n\n  # go over all existing cells\n  for my $cell (sort { $a->{x} <=> $b->{x} || $a->{y} <=> $b->{y} } values %$cells)\n    {\n    next unless $cell->isa('Graph::Easy::Edge::Cell');\n\n    # skip odd positions\n    next unless ($cell->{x} & 1) == 0 && ($cell->{y} & 1) == 0; \n\n    my $group = $cell->group();\n\n    $self->_repair_edge($cell,$rows,$cols) unless $group;\n    $self->_repair_group_edge($cell,$rows,$cols,$group) if $group;\n\n    } # end for all cells\n  }\n\nsub _fill_group_cells\n  {\n  # after doing a layout(), we need to add the group to each cell based on\n  # what group the nearest node is in.\n  my ($self, $cells_layout) = @_;\n\n  print STDERR \"\\n# Padding with fill cells, have \", \n    scalar $self->groups(), \" groups.\\n\" if $self->{debug};\n\n  # take a shortcut if we do not have groups\n  return $self if $self->groups == 0;\n\n  $self->{padding_cells} = 1;\t\t# set to true\n\n  # We need to insert \"filler\" cells around each node/edge/cell:\n\n  # To \"insert\" the filler cells, we simple multiply each X and Y by 2, this\n  # is O(N) where N is the number of actually existing cells. Otherwise we\n  # would have to create the full table-layout, and then insert rows/columns.\n  my $cells = {};\n  for my $key (keys %$cells_layout)\n    {\n    my ($x,$y) = split /,/, $key;\n    my $cell = $cells_layout->{$key};\n\n    $x *= 2;\n    $y *= 2;\n    $cell->{x} = $x;\n    $cell->{y} = $y;\n\n    $cells->{\"$x,$y\"} = $cell; \n    }\n\n  $self->{cells} = $cells;\t\t# override with new cell layout\n\n  $self->_splice_edges();\t\t# repair edges\n  $self->_repair_nodes();\t\t# repair multi-celled nodes\n\n  my $c = 'Graph::Easy::Group::Cell';\n  for my $cell (values %{$self->{cells}})\n    {\n    # DO NOT MODIFY $cell IN THE LOOP BODY!\n\n    my ($x,$y) = ($cell->{x},$cell->{y});\n\n    # find the primary node for node cells, for group check\n    my $group = $cell->group();\n\n    # not part of group, so no group-cells nec.\n    next unless $group;\n\n    # now insert up to 8 filler cells around this cell\n    my $ofs = [ -1, 0,\n\t\t0, -1,\n\t\t+1, 0,\n\t\t+1, 0,\n\t\t0, +1,\n\t\t0, +1,\n\t\t-1, 0,\n\t\t-1, 0,  ];\n    while (@$ofs > 0)\n      {\n      $x += shift @$ofs;\n      $y += shift @$ofs;\n\n      $cells->{\"$x,$y\"} = $c->new ( graph => $self, group => $group, x => $x, y => $y )\n        unless exists $cells->{\"$x,$y\"};\n      }\n    }\n\n  # Nodes positioned two cols/rows apart (f.i. y == 0 and y == 2) will be\n  # three cells apart (y == 0 and y == 4) after the splicing, the step above\n  # will not be able to close that hole - it will create fillers at y == 1 and\n  # y == 3. So we close these holes now with an extra step.\n  for my $cell (values %{$self->{cells}})\n    {\n    # only for filler cells\n    next unless $cell->isa('Graph::Easy::Group::Cell');\n\n    my ($sx,$sy) = ($cell->{x},$cell->{y});\n    my $group = $cell->{group};\n\n    my $x = $sx; my $y2 = $sy + 2; my $y = $sy + 1;\n    # look for:\n    # [ group ]\n    # [ empty ]\n    # [ group ]\n    if (exists $cells->{\"$x,$y2\"} && !exists $cells->{\"$x,$y\"})\n      {\n      my $down = $cells->{\"$x,$y2\"};\n      if ($down->isa('Graph::Easy::Group::Cell') && $down->{group} == $group)\n        {\n\t$cells->{\"$x,$y\"} = $c->new ( graph => $self, group => $group, x => $x, y => $y );\n        }\n      }\n    $x = $sx+1; my $x2 = $sx + 2; $y = $sy;\n    # look for:\n    # [ group ]  [ empty ]  [ group ]\n    if (exists $cells->{\"$x2,$y\"} && !exists $cells->{\"$x,$y\"})\n      {\n      my $right = $cells->{\"$x2,$y\"};\n      if ($right->isa('Graph::Easy::Group::Cell') && $right->{group} == $group)\n        {\n\t$cells->{\"$x,$y\"} = $c->new ( graph => $self, group => $group, x => $x, y => $y );\n        }\n      }\n    }\n\n  # XXX TODO\n  # we should \"grow\" the group area to close holes\n\n  for my $group (values %{$self->{groups}})\n    {\n    $group->_set_cell_types($cells);\n    }\n\n  # create a mapping for each row/column so that we can repair edge starts/ends\n  my $rows = {};\n  my $cols = {};\n  for my $cell (values %$cells)\n    {\n    $rows->{$cell->{y}}->{$cell->{x}} = $cell;\n    $cols->{$cell->{x}}->{$cell->{y}} = $cell;\n    }\n  $self->_repair_edges($rows,$cols);\t# insert short edge cells on group\n\t\t\t\t\t# border rows/columns\n\n  # for all groups, set the cell carrying the label (top-left-most cell)\n  for my $group (values %{$self->{groups}})\n    {\n    $group->_find_label_cell();\n    }\n\n# DEBUG:\n# for my $cell (values %$cells)\n#   { \n#   $cell->_correct_size();\n#   }\n#\n# my $y = 0;\n# for my $cell (sort { $a->{y} <=> $b->{y} || $a->{x} <=> $b->{x} } values %$cells)\n#   {\n#  print STDERR \"\\n\" if $y != $cell->{y};\n#  print STDERR \"$cell->{x},$cell->{y}, $cell->{w},$cell->{h}, \", $cell->{group}->{name} || 'none', \"\\t\";\n#   $y = $cell->{y};\n#  }\n# print STDERR \"\\n\";\n\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout::Repair - Repair spliced layout with group cells\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\t$graph->layout();\n\n\tprint $graph->as_ascii( );\n\n\t# prints:\n\n\t# +------+     +--------+\n\t# | Bonn | --> | Berlin |\n\t# +------+     +--------+\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Layout::Repair> contains code that can splice in\ngroup cells into a layout, as well as repair the layout after that step.\n\nIt is part of L<Graph::Easy|Graph::Easy> and used automatically.\n\n=head1 METHODS\n\nC<Graph::Easy::Layout> injects the following methods into the C<Graph::Easy>\nnamespace:\n\n=head2 _edges_into_groups()\n\nPut the edges into the appropriate group and class.\n\n=head2 _assign_ranks()\n\n\t$graph->_assign_ranks();\n\n=head2 _repair_nodes()\n\nSplicing the rows/columns to add filler cells will have torn holes into\nmulti-edges nodes, so we insert additional filler cells to repair this.\n\n=head2 _splice_edges()\n\nSplicing the rows/columns to add filler cells might have torn holes into\nmulti-celled edges, so we splice these together again.\n\n=head2 _repair_edges()\n\nSplicing the rows/columns to add filler cells might have put \"holes\"\nbetween an edge start/end and the node cell it points to. This\nroutine fixes this problem by extending the edge by one cell if\nnecessary.\n\n=head2 _fill_group_cells()\n\nAfter doing a C<layout()>, we need to add the group to each cell based on\nwhat group the nearest node is in.\n\nThis routine will also find the label cell for each group, and repair\nedge/node damage done by the splicing.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Layout/Scout.pm": "#############################################################################\n# Find paths from node to node in a Manhattan-style grid via A*.\n#\n# (c) by Tels - part of Graph::Easy\n#############################################################################\n\npackage Graph::Easy::Layout::Scout;\n\n$VERSION = '0.25';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\nuse Graph::Easy::Node::Cell;\nuse Graph::Easy::Edge::Cell qw/\n  EDGE_SHORT_E EDGE_SHORT_W EDGE_SHORT_N EDGE_SHORT_S\n\n  EDGE_SHORT_BD_EW EDGE_SHORT_BD_NS\n  EDGE_SHORT_UN_EW EDGE_SHORT_UN_NS\n\n  EDGE_START_E EDGE_START_W EDGE_START_N EDGE_START_S\n\n  EDGE_END_E EDGE_END_W EDGE_END_N EDGE_END_S\n\n  EDGE_N_E EDGE_N_W EDGE_S_E EDGE_S_W\n\n  EDGE_N_W_S EDGE_S_W_N EDGE_E_S_W EDGE_W_S_E\n\n  EDGE_LOOP_NORTH EDGE_LOOP_SOUTH EDGE_LOOP_WEST EDGE_LOOP_EAST\n\n  EDGE_HOR EDGE_VER EDGE_HOLE\n\n  EDGE_S_E_W EDGE_N_E_W EDGE_E_N_S EDGE_W_N_S\n\n  EDGE_LABEL_CELL\n  EDGE_TYPE_MASK\n  EDGE_ARROW_MASK\n  EDGE_FLAG_MASK\n  EDGE_START_MASK\n  EDGE_END_MASK\n  EDGE_NO_M_MASK\n /;\n\n#############################################################################\n\n# mapping edge type (HOR, VER, NW etc) and dx/dy to startpoint flag\nmy $start_points = {\n#               [ dx == 1, \tdx == -1,     dy == 1,      dy == -1 ,\n#                 dx == 1, \tdx == -1,     dy == 1,      dy == -1 ]\n  EDGE_HOR() => [ EDGE_START_W, EDGE_START_E, 0,\t    0 \t\t\t,\n\t\t  EDGE_END_E,   EDGE_END_W,   0,\t    0,\t\t\t],\n  EDGE_VER() => [ 0,\t\t0, \t      EDGE_START_N, EDGE_START_S \t,\n\t\t  0,\t\t0,\t      EDGE_END_S,   EDGE_END_N,\t\t],\n  EDGE_N_E() => [ 0,\t\tEDGE_START_E, EDGE_START_N, 0\t\t \t,\n\t\t  EDGE_END_E,\t0,\t      0, \t    EDGE_END_N, \t],\n  EDGE_N_W() => [ EDGE_START_W,\t0, \t      EDGE_START_N, 0\t\t\t,\n\t\t  0,\t        EDGE_END_W,   0,\t    EDGE_END_N,\t\t],\n  EDGE_S_E() => [ 0,\t\tEDGE_START_E, 0,\t    EDGE_START_S \t,\n\t\t  EDGE_END_E,   0,            EDGE_END_S,   0,\t\t\t],\n  EDGE_S_W() => [ EDGE_START_W,\t0, \t      0,\t    EDGE_START_S\t,\n\t\t  0,\t\tEDGE_END_W,   EDGE_END_S,   0,\t\t\t],\n  };\n\nmy $start_to_end = {\n  EDGE_START_W() => EDGE_END_W(),\n  EDGE_START_E() => EDGE_END_E(),\n  EDGE_START_S() => EDGE_END_S(),\n  EDGE_START_N() => EDGE_END_N(),\n  };\n\nsub _end_points\n  {\n  # modify last field of path to be the correct endpoint; and the first field\n  # to be the correct startpoint:\n  my ($self, $edge, $coords, $dx, $dy) = @_;\n  \n  return $coords if $edge->undirected();\n\n  # there are two cases (for each dx and dy)\n  my $i = 0;\t\t\t\t\t# index 0,1\n  my $co = 2;\n  my $case;\n\n  for my $d ($dx,$dy,$dx,$dy)\n    {\n    next if $d == 0;\n\n    my $type = $coords->[$co] & EDGE_TYPE_MASK;\n\n    $case = 0; $case = 1 if $d == -1;\n\n    # modify first/last cell\n    my $t = $start_points->{ $type }->[ $case + $i ];\n    # on bidirectional edges, turn START_X into END_X\n    $t = $start_to_end->{$t} || $t if $edge->{bidirectional};\n\n    $coords->[$co] += $t;\n\n    } continue {\n    $i += 2; \t\t\t\t\t# index 2,3, 4,5 etc\n    $co = -1 if $i == 4;\t\t\t# modify now last cell\n    }\n  $coords;\n  }\n\nsub _find_path\n  {\n  # Try to find a path between two nodes. $options contains direction\n  # preferences. Returns a list of cells like:\n  # [ $x,$y,$type, $x1,$y1,$type1, ...]\n  my ($self, $src, $dst, $edge) = @_;\n\n  # one node pointing back to itself?\n  if ($src == $dst)\n    {\n    my $rc = $self->_find_path_loop($src,$edge);\n    return $rc unless scalar @$rc == 0;\n    }\n\n  # If one of the two nodes is bigger than 1 cell, use _find_path_astar(),\n  # because it automatically handles all the possibilities:\n  return $self->_find_path_astar($edge)\n    if ($src->is_multicelled() || $dst->is_multicelled() || $edge->has_ports());\n  \n  my ($x0, $y0) = ($src->{x}, $src->{y});\n  my ($x1, $y1) = ($dst->{x}, $dst->{y});\n  my $dx = ($x1 - $x0) <=> 0;\n  my $dy = ($y1 - $y0) <=> 0;\n    \n  my $cells = $self->{cells};\n  my @coords;\n  my ($x,$y) = ($x0,$y0);\t\t\t# starting pos\n\n  ###########################################################################\n  # below follow some shortcuts for easy things like straight paths:\n\n  print STDERR \"#  dx,dy: $dx,$dy\\n\" if $self->{debug};\n\n  if ($dx == 0 || $dy == 0)\n    {\n    # try straight path to target:\n \n    print STDERR \"#  $src->{x},$src->{y} => $dst->{x},$dst->{y} - trying short path\\n\" if $self->{debug};\n\n    # distance to node:\n    my $dx1 = ($x1 - $x0);\n    my $dy1 = ($y1 - $y0);\n    ($x,$y) = ($x0+$dx,$y0+$dy);\t\t\t# starting pos\n\n    if ((abs($dx1) == 2) || (abs($dy1) == 2))\n      {\n      if (!exists ($cells->{\"$x,$y\"}))\n        {\n        # a single step for this edge:\n        my $type = EDGE_LABEL_CELL;\n        # short path\n        if ($edge->bidirectional())\n\t  {\n          $type += EDGE_SHORT_BD_EW if $dy == 0;\n          $type += EDGE_SHORT_BD_NS if $dx == 0;\n          }\n        elsif ($edge->undirected())\n          {\n          $type += EDGE_SHORT_UN_EW if $dy == 0;\n          $type += EDGE_SHORT_UN_NS if $dx == 0;\n          }\n        else\n          {\n          $type += EDGE_SHORT_E if ($dx ==  1 && $dy ==  0);\n          $type += EDGE_SHORT_S if ($dx ==  0 && $dy ==  1);\n          $type += EDGE_SHORT_W if ($dx == -1 && $dy ==  0);\n          $type += EDGE_SHORT_N if ($dx ==  0 && $dy == -1);\n          }\n\t# if one of the end points of the edge is of shape 'edge'\n\t# remove end/start flag\n        if (($edge->{to}->attribute('shape') ||'') eq 'edge')\n\t  {\n\t  # we only need to remove one start point, namely the one at the \"end\"\n\t  if ($dx > 0)\n\t    {\n\t    $type &= ~EDGE_START_E;\n\t    }\n\t  elsif ($dx < 0)\n\t    {\n\t    $type &= ~EDGE_START_W;\n\t    }\n\t  }\n        if (($edge->{from}->attribute('shape') ||'') eq 'edge')\n\t  {\n\t  $type &= ~EDGE_START_MASK;\n\t  }\n\n        return [ $x, $y, $type ];\t\t\t# return a short EDGE\n        }\n      }\n\n    my $type = EDGE_HOR; $type = EDGE_VER if $dx == 0;\t# - or |\n    my $done = 0;\n    my $label_done = 0;\n    while (3 < 5)\t\t# endless loop\n      {\n      # Since we do not handle crossings here, A* will be tried if we hit an\n      # edge in this test.\n      $done = 1, last if exists $cells->{\"$x,$y\"};\t# cell already full\n\n      # the first cell gets the label\n      my $t = $type; $t += EDGE_LABEL_CELL if $label_done++ == 0;\n\n      push @coords, $x, $y, $t;\t\t\t\t# good one, is free\n      $x += $dx; $y += $dy;\t\t\t\t# next field\n      last if ($x == $x1) && ($y == $y1);\n      }\n\n    if ($done == 0)\n      {\n      print STDERR \"#  success for \", scalar @coords / 3, \" steps in path\\n\" if $self->{debug};\n      # return all fields of path\n      return $self->_end_points($edge, \\@coords, $dx, $dy);\n      }\n\n    } # end else straight path try\n\n  ###########################################################################\n  # Try paths with one bend:\n\n  # ($dx != 0 && $dy != 0) => path with one bend\n  # XXX TODO:\n  # This could be handled by A*, too, but it would be probably a bit slower.\n  else\n    {\n    # straight path not possible, since x0 != x1 AND y0 != y1\n\n    #           \"  |\"                        \"|   \"\n    # try first \"--+\" (aka hor => ver), then \"+---\" (aka ver => hor)\n    my $done = 0;\n\n    print STDERR \"#  bend path from $x,$y\\n\" if $self->{debug};\n\n    # try hor => ver\n    my $type = EDGE_HOR;\n\n    my $label = 0;\t\t\t\t\t\t# attach label?\n    $label = 1 if ref($edge) && ($edge->label()||'') eq '';\t# no label?\n    $x += $dx;\n    while ($x != $x1)\n      {\n      $done++, last if exists $cells->{\"$x,$y\"};\t# cell already full\n      print STDERR \"#  at $x,$y\\n\" if $self->{debug};\n      my $t = $type; $t += EDGE_LABEL_CELL if $label++ == 0;\n      push @coords, $x, $y, $t;\t\t\t\t# good one, is free\n      $x += $dx;\t\t\t\t\t# next field\n      };\n\n    # check the bend itself     \n    $done++ if exists $cells->{\"$x,$y\"};\t# cell already full\n\n    if ($done == 0)\n      {\n      my $type_bend = _astar_edge_type ($x-$dx,$y, $x,$y, $x,$y+$dy);\n \n      push @coords, $x, $y, $type_bend;\t\t\t# put in bend\n      print STDERR \"# at $x,$y\\n\" if $self->{debug};\n      $y += $dy;\n      $type = EDGE_VER;\n      while ($y != $y1)\n        {\n        $done++, last if exists $cells->{\"$x,$y\"};\t# cell already full\n\tprint STDERR \"# at $x,$y\\n\" if $self->{debug};\n        push @coords, $x, $y, $type;\t\t\t# good one, is free\n        $y += $dy;\n        } \n      }\n\n    if ($done != 0)\n      {\n      $done = 0;\n      # try ver => hor\n      print STDERR \"# hm, now trying first vertical, then horizontal\\n\" if $self->{debug};\n      $type = EDGE_VER;\n\n      @coords = ();\t\t\t\t\t# drop old version\n      ($x,$y) = ($x0, $y0 + $dy);\t\t\t# starting pos\n      while ($y != $y1)\n        {\n        $done++, last if exists $cells->{\"$x,$y\"};\t# cell already full\n        print STDERR \"# at $x,$y\\n\" if $self->{debug};\n        push @coords, $x, $y, $type;\t\t\t# good one, is free\n        $y += $dy;\t\t\t\t\t# next field\n        };\n\n      # check the bend itself     \n      $done++ if exists $cells->{\"$x,$y\"};\t\t# cell already full\n\n      if ($done == 0)\n        {\n        my $type_bend = _astar_edge_type ($x,$y-$dy, $x,$y, $x+$dx,$y);\n\n        push @coords, $x, $y, $type_bend;\t\t# put in bend\n        print STDERR \"# at $x,$y\\n\" if $self->{debug};\n        $x += $dx;\n        my $label = 0;\t\t\t\t\t# attach label?\n        $label = 1 if $edge->label() eq '';\t\t# no label?\n        $type = EDGE_HOR;\n        while ($x != $x1)\n          {\n          $done++, last if exists $cells->{\"$x,$y\"};\t# cell already full\n\t  print STDERR \"# at $x,$y\\n\" if $self->{debug};\n          my $t = $type; $t += EDGE_LABEL_CELL if $label++ == 0;\n          push @coords, $x, $y, $t;\t\t\t# good one, is free\n\t  $x += $dx;\n          } \n        }\n      }\n\n    if ($done == 0)\n      {\n      print STDERR \"# success for \", scalar @coords / 3, \" steps in path\\n\" if $self->{debug};\n      # return all fields of path\n      return $self->_end_points($edge, \\@coords, $dx, $dy);\n      }\n\n    print STDERR \"# no success\\n\" if $self->{debug};\n\n    } # end path with $dx and $dy\n\n  $self->_find_path_astar($edge);\t\t# try generic approach as last hope\n  }\n\nsub _find_path_loop\n  {\n  # find a path from one node back to itself\n  my ($self, $src, $edge) = @_;\n\n  print STDERR \"# Finding looping path from $src->{name} to $src->{name}\\n\" if $self->{debug};\n\n  my ($n, $cells, $d, $type, $loose) = @_;\n\n  # get a list of all places\n\n  my @places = $src->_near_places( \n    $self->{cells}, 1, [\n      EDGE_LOOP_EAST,\n      EDGE_LOOP_SOUTH,\n      EDGE_LOOP_WEST,\n      EDGE_LOOP_NORTH,\n    ], 0, 90);\n  \n  my $flow = $src->flow();\n\n  # We cannot use _shuffle_dir() here, because self-loops\n  # are tried in a different order:\n\n  # the default (east)\n  my $index = [\n    EDGE_LOOP_NORTH,\n    EDGE_LOOP_SOUTH,\n    EDGE_LOOP_WEST,\n    EDGE_LOOP_EAST,\n   ];\n\n  # west\n  $index = [\n    EDGE_LOOP_SOUTH,\n    EDGE_LOOP_NORTH,\n    EDGE_LOOP_EAST,\n    EDGE_LOOP_WEST,\n   ] if $flow == 270;\n\n  # north\n  $index = [\n    EDGE_LOOP_WEST,\n    EDGE_LOOP_EAST,\n    EDGE_LOOP_SOUTH,\n    EDGE_LOOP_NORTH,\n   ] if $flow == 0;\n  \n  # south\n  $index = [\n    EDGE_LOOP_EAST,\n    EDGE_LOOP_WEST,\n    EDGE_LOOP_NORTH,\n    EDGE_LOOP_SOUTH,\n   ] if $flow == 180;\n  \n  for my $this_try (@$index)\n    {\n    my $idx = 0;\n    while ($idx < @places)\n      {\n      print STDERR \"# Trying $places[$idx+0],$places[$idx+1]\\n\" if $self->{debug};\n      next unless $places[$idx+2] == $this_try;\n      \n      # build a path from the returned piece\n      my @rc = ($places[$idx], $places[$idx+1], $places[$idx+2]);\n\n      print STDERR \"# Trying $rc[0],$rc[1]\\n\" if $self->{debug};\n\n      next unless $self->_path_is_clear(\\@rc);\n\n      print STDERR \"# Found looping path\\n\" if $self->{debug};\n      return \\@rc;\n      } continue { $idx += 3; } \n    }\n\n  [];\t\t# no path found\n  }\n\n#############################################################################\n#############################################################################\n\n# This package represents a simple/cheap/fast heap:\npackage Graph::Easy::Heap;\n\nrequire Graph::Easy::Base;\nour @ISA = qw/Graph::Easy::Base/;\n\nuse strict;\n\nsub _init\n  {\n  my ($self,$args) = @_;\n\n  $self->{_heap} = [ ];\n\n  $self;\n  }\n\nsub add\n  {\n  # add one element to the heap\n  my ($self,$elem) = @_;\n\n  my $heap = $self->{_heap};\n\n  # heap empty?\n  if (@$heap == 0)\n    {\n    push @$heap, $elem;\n    }\n  # smaller than first elem?\n  elsif ($elem->[0] < $heap->[0]->[0])\n    {\n    #print STDERR \"# $elem->[0] is smaller then first elem $heap->[0]->[0] (with \", scalar @$heap,\" elems on heap)\\n\";\n    unshift @$heap, $elem;\n    }\n  # bigger than or equal to last elem?\n  elsif ($elem->[0] > $heap->[-1]->[0])\n    {\n    #print STDERR \"# $elem->[0] is bigger then last elem $heap->[-1]->[0] (with \", scalar @$heap,\" elems on heap)\\n\";\n    push @$heap, $elem;\n    }\n  else\n    {\n    # insert the elem at the right position\n\n    # if we have less than X elements, use linear search\n    my $el = $elem->[0];\n    if (scalar @$heap < 10)\n      {\n      my $i = 0;\n      for my $e (@$heap)\n        {\n        if ($e->[0] > $el)\n          {\n          splice (@$heap, $i, 0, $elem);\t\t# insert $elem\n          return undef;\n          }\n        $i++;\n        }\n      # else, append at the end\n      push @$heap, $elem;\n      }\n    else\n      {\n      # use binary search\n      my $l = 0; my $r = scalar @$heap;\n      while (($r - $l) > 2)\n        {\n        my $m = int((($r - $l) / 2) + $l);\n#        print \"l=$l r=$r m=$m el=$el heap=$heap->[$m]->[0]\\n\";\n        if ($heap->[$m]->[0] <= $el)\n          {\n          $l = $m;\n          }\n        else\n          {\n          $r = $m;\n          }\n        }\n      while ($l < @$heap)\n        {\n        if ($heap->[$l]->[0] > $el)\n          {\n          splice (@$heap, $l, 0, $elem);\t\t# insert $elem\n          return undef;\n          }\n        $l++;\n        }\n      # else, append at the end\n      push @$heap, $elem;\n      }\n    }\n  undef;\n  }\n\nsub elements\n  {\n  scalar @{$_[0]->{_heap}};\n  }\n\nsub extract_top\n  {\n  # remove and return the top elemt\n  shift @{$_[0]->{_heap}};\n  }\n\nsub delete\n  {\n  # Find an element by $x,$y and delete it\n  my ($self, $x, $y) = @_;\n\n  my $heap = $self->{_heap};\n  \n  my $i = 0;\n  for my $e (@$heap)\n    {\n    if ($e->[1] == $x && $e->[2] == $y)\n      {\n      splice (@$heap, $i, 1);\n      return;\n      }\n    $i++;\n    }\n\n  $self;\n  }\n\nsub sort_sub\n  {\n  my ($self) = shift;\n\n  $self->{_sort} = shift;\n  }\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\n# Generic pathfinding via the A* algorithm:\n# See http://bloodgate.com/perl/graph/astar.html for some background.\n\nsub _astar_modifier\n  {\n  # calculate the cost for the path at cell x1,y1 \n  my ($x1,$y1,$x,$y,$px,$py, $cells) = @_;\n\n  my $add = 1;\n\n  if (defined $x1)\n    {\n    my $xy = \"$x1,$y1\";\n    # add a harsh penalty for crossing an edge, meaning we can travel many\n    # fields to go around.\n    $add += 30 if ref($cells->{$xy}) && $cells->{$xy}->isa('Graph::Easy::Edge');\n    }\n \n  if (defined $px)\n    {\n    # see whether the new position $x1,$y1 is a continuation from $px,$py => $x,$y\n    # e.g. if from we go down from $px,$py to $x,$y, then anything else then $x,$y+1 will\n    # get a penalty\n    my $dx1 = ($px-$x) <=> 0;\n    my $dy1 = ($py-$y) <=> 0;\n    my $dx2 = ($x-$x1) <=> 0;\n    my $dy2 = ($y-$y1) <=> 0;\n    $add += 6 unless $dx1 == $dx2 || $dy1 == $dy2;\n    }\n  $add;\n  }\n\nsub _astar_distance\n  {\n  # calculate the manhattan distance between x1,y1 and x2,y2\n#  my ($x1,$y1,$x2,$y2) = @_;\n\n  my $dx = abs($_[2] - $_[0]);\n  my $dy = abs($_[3] - $_[1]);\n\n  # plus 1 because we need to go around one corner if $dx != 0 && $dx != 0\n  $dx++ if $dx != 0 && $dy != 0;\n\n  $dx + $dy;\n  }\n\nmy $edge_type = {\n    '0,1,-1,0' => EDGE_N_W,\n    '0,1,0,1' => EDGE_VER,\n    '0,1,1,0' => EDGE_N_E,\n\n    '-1,0,0,-1' => EDGE_N_E,\n    '-1,0,-1,0' => EDGE_HOR,\n    '-1,0,0,1' => EDGE_S_E,\n\n    '0,-1,-1,0' => EDGE_S_W,\n    '0,-1,0,-1' => EDGE_VER,\n    '0,-1,1,0' => EDGE_S_E,\n\n    '1,0,0,-1' => EDGE_N_W,\n    '1,0,1,0' => EDGE_HOR,\n    '1,0,0,1' => EDGE_S_W,\n\n    # loops (left-right-left etc)\n    '0,-1,0,1' => EDGE_N_W_S,\n    '0,1,0,-1' => EDGE_S_W_N,\n    '1,0,-1,0' => EDGE_E_S_W,\n    '-1,0,1,0' => EDGE_W_S_E,\n  };\n\nsub _astar_edge_type\n  {\n  # from three consecutive positions calculate the edge type (VER, HOR, N_W etc)\n  my ($x,$y, $x1,$y1, $x2, $y2) = @_;\n\n  my $dx1 = ($x1 - $x) <=> 0;\n  my $dy1 = ($y1 - $y) <=> 0;\n\n  my $dx2 = ($x2 - $x1) <=> 0;\n  my $dy2 = ($y2 - $y1) <=> 0;\n\n  # in some cases we get (0,-1,0,0), so set the missing parts\n  ($dx2,$dy2) = ($dx1,$dy1) if $dx2 == 0 && $dy2 == 0;\n  # can this case happen?\n  ($dx1,$dy1) = ($dx2,$dy2) if $dx1 == 0 && $dy1 == 0;\n\n  # return correct type depending on differences\n  $edge_type->{\"$dx1,$dy1,$dx2,$dy2\"} || EDGE_HOR;\n  }\n\nsub _astar_near_nodes\n  {\n  # return possible next nodes from $nx,$ny\n  my ($self, $nx, $ny, $cells, $closed, $min_x, $min_y, $max_x, $max_y) = @_;\n\n  my @places = ();\n\n  my @tries  = (\t# ordered E,S,W,N:\n    $nx + 1, $ny, \t# right\n    $nx, $ny + 1,\t# down\n    $nx - 1, $ny,\t# left\n    $nx, $ny - 1,\t# up\n    );\n\n  # on crossings, only allow one direction (NS or EW)\n  my $type = EDGE_CROSS;\n  # including flags, because only flagless edges may be crossed\n  $type = $cells->{\"$nx,$ny\"}->{type} if exists $cells->{\"$nx,$ny\"};\n  if ($type == EDGE_HOR)\n    {\n    @tries  = (\n      $nx, $ny + 1,\t# down\n      $nx, $ny - 1,\t# up\n    );\n    }\n  elsif ($type == EDGE_VER)\n    {\n    @tries  = (\n      $nx + 1, $ny, \t# right\n      $nx - 1, $ny,\t# left\n    );\n    }\n\n  # This loop does not check whether the position is already open or not,\n  # the caller will later check if the already-open position needs to be\n  # replaced by one with a lower cost.\n\n  my $i = 0;\n  while ($i < @tries)\n    {\n    my ($x,$y) = ($tries[$i], $tries[$i+1]);\n\n    print STDERR \"# $min_x,$min_y => $max_x,$max_y\\n\" if $self->{debug} > 2;\n\n    # drop cells outside our working space:\n    next if $x < $min_x || $x > $max_x || $y < $min_y || $y > $max_y;\n\n    my $p = \"$x,$y\";\n    print STDERR \"# examining pos $p\\n\" if $self->{debug} > 2;\n\n    next if exists $closed->{$p};\n\n    if (exists $cells->{$p} && ref($cells->{$p}) && $cells->{$p}->isa('Graph::Easy::Edge'))\n      {\n      # If the existing cell is an VER/HOR edge, then we may cross it\n      my $type = $cells->{$p}->{type};\t# including flags, because only flagless edges\n\t\t\t\t\t# may be crossed\n\n      push @places, $x, $y if ($type == EDGE_HOR) || ($type == EDGE_VER);\n      next;\n      }\n    next if exists $cells->{$p};\t# uncrossable cell\n\n    push @places, $x, $y;\n\n    } continue { $i += 2; }\n \n  @places;\n  }\n\nsub _astar_boundaries\n  {\n  # Calculate boundaries for area that A* should not leave.\n  my $self = shift;\n\n  my $cache = $self->{cache};\n\n  return ( $cache->{min_x}-1, $cache->{min_y}-1, \n\t   $cache->{max_x}+1, $cache->{max_y}+1 ) if defined $cache->{min_x};\n\n  my ($min_x, $min_y, $max_x, $max_y);\n\n  my $cells = $self->{cells};\n\n  $min_x = 10000000;\n  $min_y = 10000000;\n  $max_x = -10000000;\n  $max_y = -10000000;\n\n  for my $c (keys %$cells)\n    {\n    my ($x,$y) = split /,/, $c;\n    $min_x = $x if $x < $min_x;\n    $min_y = $y if $y < $min_y;\n    $max_x = $x if $x > $max_x;\n    $max_y = $y if $y > $max_y;\n    }\n\n  print STDERR \"# A* working space boundaries: $min_x, $min_y, $max_x, $max_y\\n\" if $self->{debug};\n\n  ( $cache->{min_x}, $cache->{min_y}, $cache->{max_x}, $cache->{max_y} ) = \n  ($min_x, $min_y, $max_x, $max_y);\n\n  # make the area one bigger in each direction\n  $min_x --; $min_y --; $max_x ++; $max_y ++;\n  ($min_x, $min_y, $max_x, $max_y);\n  }\n\n# on edge pieces, select start fields (left/right of a VER, above/below of a HOR etc)\n# contains also for each starting position the joint-type\nmy $next_fields =\n  {\n  EDGE_VER() => [ -1,0, EDGE_W_N_S, +1,0, EDGE_E_N_S ],\n  EDGE_HOR() => [ 0,-1, EDGE_N_E_W, 0,+1, EDGE_S_E_W ],\n  EDGE_N_E() => [ 0,+1, EDGE_E_N_S, -1,0, EDGE_N_E_W ],\t\t# |_\n  EDGE_N_W() => [ 0,+1, EDGE_W_N_S, +1,0, EDGE_N_E_W ],\t\t# _|\n  EDGE_S_E() => [ 0,-1, EDGE_E_N_S, -1,0, EDGE_S_E_W ],\n  EDGE_S_W() => [ 0,-1, EDGE_W_N_S, +1,0, EDGE_S_E_W ],\n  };\n\n# on edge pieces, select end fields (left/right of a VER, above/below of a HOR etc)\n# contains also for each end position the joint-type\nmy $prev_fields =\n  {\n  EDGE_VER() => [ -1,0, EDGE_W_N_S, +1,0, EDGE_E_N_S ],\n  EDGE_HOR() => [ 0,-1, EDGE_N_E_W, 0,+1, EDGE_S_E_W ],\n  EDGE_N_E() => [ 0,+1, EDGE_E_N_S, -1,0, EDGE_N_E_W ],\t\t# |_\n  EDGE_N_W() => [ 0,+1, EDGE_W_N_S, +1,0, EDGE_N_E_W ],\t\t# _|\n  EDGE_S_E() => [ 0,-1, EDGE_E_N_S, -1,0, EDGE_S_E_W ],\n  EDGE_S_W() => [ 0,-1, EDGE_W_N_S, +1,0, EDGE_S_E_W ],\n  };\n\nsub _get_joints\n  { \n  # from a list of shared, already placed edges, get possible start/end fields\n  my ($self, $shared, $mask, $types, $cells, $next_fields) = @_;\n\n  # XXX TODO: do not do this for edges with no free places for joints\n\n  # take each cell from all edges shared, already placed edges as start-point\n  for my $e (@$shared)\n    {\n    for my $c (@{$e->{cells}})\n      {\n      my $type = $c->{type} & EDGE_TYPE_MASK;\n\n      next unless exists $next_fields->{ $type };\n\n      # don't consider end/start (depending on $mask) cells\n\n      # do not join EDGE_HOR or EDGE_VER, but join corner pieces\n      next if ( ($type == EDGE_HOR()) || \n\t\t($type == EDGE_VER()) ) &&\n\t\t($c->{type} & $mask);\n\n      my $fields = $next_fields->{$type};\n\n      my ($px,$py) = ($c->{x},$c->{y});\n      my $i = 0;\n      while ($i < @$fields)\n\t{\n\tmy ($sx,$sy, $jt) = ($fields->[$i], $fields->[$i+1], $fields->[$i+2]);\n\t$sx += $px; $sy += $py; $i += 3;\n        my $sxsy = \"$sx,$sy\";\n        # don't add the field twice\n\tnext if exists $cells->{$sxsy};\n\t$cells->{$sxsy} = [ $sx, $sy, undef, $px, $py ];\n\t# keep eventually set start/end points on the original cell\n\t$types->{$sxsy} = $jt + ($c->{type} & EDGE_FLAG_MASK);\n\t} \n      }\n    }\n \n  my @R;\n  # convert hash to array\n  for my $s (values %{$cells})\n    {\n    push @R, @$s;\n    }\n  @R;\n  }\n\nsub _join_edge\n  {\n  # Find out whether an edge sharing an ending point with the source edge\n  # runs alongside the source node, if so, convert it to a joint:\n  my ($self, $node, $edge, $shared, $end) = @_;\n\n  # we check the sides B,C,D and E for HOR and VER edge pices:\n  #   --D--\n  # | +---+ |\n  # E | A | B\n  # | +---+ |\n  #   --C--\n\n  my $flags = \n   [ \n      EDGE_W_N_S + EDGE_START_W,\n      EDGE_N_E_W + EDGE_START_N,\n      EDGE_E_N_S + EDGE_START_E,\n      EDGE_S_E_W + EDGE_START_S,\n   ];\n  $flags = \n   [ \n      EDGE_W_N_S + EDGE_END_W,\n      EDGE_N_E_W + EDGE_END_N,\n      EDGE_E_N_S + EDGE_END_E,\n      EDGE_S_E_W + EDGE_END_S,\n   ] if $end || $edge->{bidirectional};\n  \n  my $cells = $self->{cells};\n  my @places = $node->_near_places($cells, 1, # distance 1\n   $flags, 'loose'); \n\n  my $i = 0;\n  while ($i < @places)\n    {\n    my ($x,$y) = ($places[$i], $places[$i+1]); $i += 3;\n    \n    next unless exists $cells->{\"$x,$y\"};\t\t# empty space?\n    # found some cell, check that it is a EDGE_HOR or EDGE_VER\n    my $cell = $cells->{\"$x,$y\"};\n    next unless $cell->isa('Graph::Easy::Edge::Cell');\n\n    my $cell_type = $cell->{type} & EDGE_TYPE_MASK;\n\n    next unless $cell_type == EDGE_HOR || $cell_type == EDGE_VER;\n\n    # the cell must belong to one of the shared edges\n    my $e = $cell->{edge}; local $_;\n    next unless scalar grep { $e == $_ } @$shared;\n\n    # make the cell at the current pos a joint\n    $cell->_make_joint($edge,$places[$i-1]);\n\n    # The layouter will check that each edge has a cell, so add a dummy one to\n    # $edge to make it happy:\n    Graph::Easy::Edge::Cell->new( type => EDGE_HOLE, edge => $edge, x => $x, y => $y );\n\n    return [];\t\t\t\t\t# path is empty\n    }\n\n  undef;\t\t# did not find an edge cell that can be used as joint\n  }\n\nsub _find_path_astar\n  {\n  # Find a path with the A* algorithm for the given edge (from node A to B)\n  my ($self,$edge) = @_;\n\n  my $cells = $self->{cells};\n  my $src = $edge->{from};\n  my $dst = $edge->{to};\n\n  print STDERR \"# A* from $src->{x},$src->{y} to $dst->{x},$dst->{y}\\n\" if $self->{debug};\n\n  my $start_flags = [\n    EDGE_START_W,\n    EDGE_START_N,\n    EDGE_START_E,\n    EDGE_START_S,\n  ]; \n\n  my $end_flags = [\n    EDGE_END_W,\n    EDGE_END_N,\n    EDGE_END_E,\n    EDGE_END_S,\n  ]; \n\n  # if the target/source node is of shape \"edge\", remove the endpoint\n  if ( ($edge->{to}->attribute('shape')) eq 'edge')\n    {\n    $end_flags = [ 0,0,0,0 ];\n    }\n  if ( ($edge->{from}->attribute('shape')) eq 'edge')\n    {\n    $start_flags = [ 0,0,0,0 ];\n    }\n\n  my ($s_p,@ss_p) = $edge->port('start');\n  my ($e_p,@ee_p) = $edge->port('end');\n  my (@A, @B);\t\t\t\t\t# Start/Stop positions\n  my @shared_start;\n  my @shared_end;\n\n  my $joint_type = {};\n  my $joint_type_end = {};\n\n  my $start_cells = {};\n  my $end_cells = {};\n\n  ###########################################################################\n  # end fields first (because maybe an edge runs alongside the node)\n\n  # has a end point restriction\n  @shared_end = $edge->{to}->edges_at_port('end', $e_p, $ee_p[0]) if defined $e_p && @ee_p == 1;\n\n  my @shared = ();\n  # filter out all non-placed edges (this will also filter out $edge)\n  for my $s (@shared_end)\n    {\n    push @shared, $s if @{$s->{cells}} > 0;\n    }\n\n  my $per_field = 5;\t\t\t# for shared: x,y,undef, px,py\n  if (@shared > 0)\n    {\n    # more than one edge share the same end port, and one of the others was\n    # already placed\n\n    print STDERR \"#  edge from '$edge->{from}->{name}' to '$edge->{to}->{name}' shares end port with \",\n\tscalar @shared, \" other edge(s)\\n\" if $self->{debug};\n\n    # if there is one of the already-placed edges running alongside the src\n    # node, we can just convert the field to a joint and be done\n    my $path = $self->_join_edge($src,$edge,\\@shared);\n    return $path if $path;\t\t\t\t# already done?\n\n    @B = $self->_get_joints(\\@shared, EDGE_START_MASK, $joint_type_end, $end_cells, $prev_fields);\n    }\n  else\n    {\n    # potential stop positions\n    @B = $dst->_near_places($cells, 1, $end_flags, 1);\t# distance = 1: slots\n\n    # the edge has a port description, limiting the end places\n    @B = $dst->_allowed_places( \\@B, $dst->_allow( $e_p, @ee_p ), 3)\n      if defined $e_p;\n\n    $per_field = 3;\t\t\t# x,y,type\n    }\n\n  return unless scalar @B > 0;\t\t\t# no free slots on target node?\n\n  ###########################################################################\n  # start fields\n\n  # has a starting point restriction:\n  @shared_start = $edge->{from}->edges_at_port('start', $s_p, $ss_p[0]) if defined $s_p && @ss_p == 1;\n\n  @shared = ();\n  # filter out all non-placed edges (this will also filter out $edge)\n  for my $s (@shared_start)\n    {\n    push @shared, $s if @{$s->{cells}} > 0;\n    }\n\n  if (@shared > 0)\n    {\n    # More than one edge share the same start port, and one of the others was\n    # already placed, so we just run along until we catch it up with a joint:\n\n    print STDERR \"#  edge from '$edge->{from}->{name}' to '$edge->{to}->{name}' shares start port with \",\n\tscalar @shared, \" other edge(s)\\n\" if $self->{debug};\n\n    # if there is one of the already-placed edges running alongside the src\n    # node, we can just convert the field to a joint and be done\n    my $path = $self->_join_edge($dst, $edge, \\@shared, 'end');\n    return $path if $path;\t\t\t\t# already done?\n\n    @A = $self->_get_joints(\\@shared, EDGE_END_MASK, $joint_type, $start_cells, $next_fields);\n    }\n  else\n    {\n    # from SRC to DST\n\n    # get all the starting positions\n    # distance = 1: slots, generate starting types, the direction is shifted\n    # by 90° counter-clockwise\n\n    my $s = $start_flags; $s = $end_flags if $edge->{bidirectional};\n    my @start = $src->_near_places($cells, 1, $s, 1, $src->_shift(-90) );\n\n    # the edge has a port description, limiting the start places\n    @start = $src->_allowed_places( \\@start, $src->_allow( $s_p, @ss_p ), 3)\n      if defined $s_p;\n\n    return unless @start > 0;\t\t\t# no free slots on start node?\n\n    my $i = 0;\n    while ($i < scalar @start)\n      {\n      my $sx = $start[$i]; my $sy = $start[$i+1]; my $type = $start[$i+2]; $i += 3;\n\n      # compute the field inside the node from where $sx,$sy is reached:\n      my $px = $sx; my $py = $sy;\n      if ($sy < $src->{y} || $sy >= $src->{y} + $src->{cy})\n        {\n        $py = $sy + 1 if $sy < $src->{y};\t\t# above\n        $py = $sy - 1 if $sy > $src->{y};\t\t# below\n        }\n      else\n        {\n        $px = $sx + 1 if $sx < $src->{x};\t\t# right\n        $px = $sx - 1 if $sx > $src->{x};\t\t# left\n        }\n\n      push @A, ($sx, $sy, $type, $px, $py);\n      }\n    }\n\n  ###########################################################################\n  # use A* to finally find the path:\n\n  my $path = $self->_astar(\\@A,\\@B,$edge, $per_field);\n\n  if (@$path > 0 && keys %$start_cells > 0)\n    {\n    # convert the edge piece of the starting edge-cell to a joint\n    my ($x, $y) = ($path->[0],$path->[1]);\n    my $xy = \"$x,$y\";\n    my ($sx,$sy,$t,$px,$py) = @{$start_cells->{$xy}};\n\n    my $jt = $joint_type->{\"$sx,$sy\"};\n    $cells->{\"$px,$py\"}->_make_joint($edge,$jt);\n    }\n\n  if (@$path > 0 && keys %$end_cells > 0)\n    {\n    # convert the edge piece of the starting edge-cell to a joint\n    my ($x, $y) = ($path->[-3],$path->[-2]);\n    my $xy = \"$x,$y\";\n    my ($sx,$sy,$t,$px,$py) = @{$end_cells->{$xy}};\n\n    my $jt = $joint_type_end->{\"$sx,$sy\"};\n    $cells->{\"$px,$py\"}->_make_joint($edge,$jt);\n    }\n\n  $path;\n  }\n\nsub _astar\n  {\n  # The core A* algorithm, finds a path from a given list of start\n  # positions @A to and of the given stop positions @B.\n  my ($self, $A, $B, $edge, $per_field) = @_;\n\n  my @start = @$A;\n  my @stop = @$B;\n  my $stop = scalar @stop;\n\n  my $src = $edge->{from};\n  my $dst = $edge->{to};\n  my $cells = $self->{cells};\n\n  my $open = Graph::Easy::Heap->new();\t# to find smallest elem fast\n  my $open_by_pos = {};\t\t\t# to find open nodes by pos\n  my $closed = {};\t\t\t# to find closed nodes by pos\n\n  my $elem;\n\n  # The boundaries of objects in $cell, e.g. the area that the algorithm shall\n  # never leave.\n  my ($min_x, $min_y, $max_x, $max_y) = $self->_astar_boundaries();\n\n  # Max. steps to prevent endless searching in case of bugs like endless loops.\n  my $tries = 0; my $max_tries = 2000000;\n\n  # count how many times we did A*\n  $self->{stats}->{astar}++;\n\n  ###########################################################################\n  ###########################################################################\n  # put the start positions into OPEN\n\n  my $i = 0; my $bias = 0;\n  while ($i < scalar @start)\n    {\n    my ($sx,$sy,$type,$px,$py) = \n     ($start[$i],$start[$i+1],$start[$i+2],$start[$i+3],$start[$i+4]);\n    $i += 5;\n\n    my $cell = $cells->{\"$sx,$sy\"}; my $rcell = ref($cell);\n    next if $rcell && $rcell !~ /::Edge/;\n\n    my $t = 0; $t = $cell->{type} & EDGE_NO_M_MASK if $rcell =~ /::Edge/;\n    next if $t != 0 && $t != EDGE_HOR && $t != EDGE_VER;\n\n    # For each start point, calculate the distance to each stop point, then use\n    # the smallest as value:\n    my $lowest_x = $stop[0]; my $lowest_y = $stop[1];\n    my $lowest = _astar_distance($sx,$sy, $stop[0], $stop[1]);\n    for (my $u = $per_field; $u < $stop; $u += $per_field)\n      {\n      my $dist = _astar_distance($sx,$sy, $stop[$u], $stop[$u+1]);\n      ($lowest_x, $lowest_y) = ($stop[$u],$stop[$u+1]) if $dist < $lowest;\n      $lowest = $dist if $dist < $lowest;\n      }\n\n\n    # add a penalty for crossings\n    my $malus = 0; $malus = 30 if $t != 0;\n    $malus += _astar_modifier($px,$py, $sx, $sy, $sx, $sy);\n    $open->add( [ $lowest, $sx, $sy, $px, $py, $type, 1 ] );\n\n    my $o = $malus + $bias + $lowest;\n    print STDERR \"#   adding open pos $sx,$sy ($o = $malus + $bias + $lowest) at ($lowest_x,$lowest_y)\\n\"\n\t if $self->{debug} > 1;\n\n    # The cost to reach the starting node is obviously 0. That means that there is\n    # a tie between going down/up if both possibilities are equal likely. We insert\n    # a small bias here that makes the prefered order east/south/west/north. Instead\n    # the algorithmn exploring both way and terminating arbitrarily on the one that\n    # first hits the target, it will explore only one.\n    $open_by_pos->{\"$sx,$sy\"} = $o;\n\n    $bias += $self->{_astar_bias} || 0;\n    } \n\n  ###########################################################################\n  ###########################################################################\n  # main A* loop\n\n  my $stats = $self->{stats};\n\n  STEP:\n  while( defined( $elem = $open->extract_top() ) )\n    {\n    $stats->{astar_steps}++ if $self->{debug};\n\n    # hard limit on number of steps todo\n    if ($tries++ > $max_tries)\n      {\n      $self->warn(\"A* reached maximum number of tries ($max_tries), giving up.\"); \n      return [];\n      }\n\n    print STDERR \"#  Smallest elem from \", $open->elements(), \n\t\" elems is: weight=\", $elem->[0], \" at $elem->[1],$elem->[2]\\n\" if $self->{debug} > 1;\n    my ($val, $x,$y, $px,$py, $type, $do_stop) = @$elem;\n\n    my $key = \"$x,$y\";\n    # move node into CLOSE and remove from OPEN\n    my $g = $open_by_pos->{$key} || 0;\n    $closed->{$key} = [ $px, $py, $val - $g, $g, $type, $do_stop ];\n    delete $open_by_pos->{$key};\n\n    # we are done when we hit one of the potential stop positions\n    for (my $i = 0; $i < $stop; $i += $per_field)\n      {\n      # reached one stop position?\n      if ($x == $stop[$i] && $y == $stop[$i+1])\n        {\n        $closed->{$key}->[4] += $stop[$i+2] if defined $stop[$i+2];\n\t# store the reached stop position if it is known\n\tif ($per_field > 3)\n\t  {\n\t  $closed->{$key}->[6] = $stop[$i+3];\n\t  $closed->{$key}->[7] = $stop[$i+4];\n          print STDERR \"#  Reached stop position $x,$y (lx,ly $stop[$i+3], $stop[$i+4])\\n\" if $self->{debug} > 1;\n\t  }\n        elsif ($self->{debug} > 1) {\n          print STDERR \"#  Reached stop position $x,$y\\n\";\n          }\n        last STEP;\n        }\n      } # end test for stop postion(s)\n\n    $self->_croak(\"On of '$x,$y' is not defined\")\n      unless defined $x && defined $y;\n      \n    # get list of potential positions we need to explore from the current one\n    my @p = $self->_astar_near_nodes($x,$y, $cells, $closed, $min_x, $min_y, $max_x, $max_y);\n\n    my $n = 0;\n    while ($n < scalar @p)\n      {\n      my $nx = $p[$n]; my $ny = $p[$n+1]; $n += 2;\n\n      if (!defined $nx || !defined $ny)\n        {\n        require Carp;\n        Carp::confess(\"On of '$nx,$ny' is not defined\");\n        }\n      my $lg = $g;\n      $lg += _astar_modifier($px,$py,$x,$y,$nx,$ny,$cells) if defined $px && defined $py;\n\n      my $n = \"$nx,$ny\";\n\n      # was already open?\n      next if (exists $open_by_pos->{$n});\n\n#      print STDERR \"#   Already open pos $nx,$ny with $open_by_pos->{$n} (would be $lg)\\n\"\n#\t if $self->{debug} && exists $open_by_pos->{$n};\n#\n#      next if exists $open_by_pos->{$n} && $open_by_pos->{$n} <= $lg; \n#\n#      if (exists $open_by_pos->{$n})\n#        {\n#        $open->delete($nx, $ny);\n#        }\n\n      # calculate distance to each possible stop position, and\n      # use the lowest one\n      my $lowest_distance = _astar_distance($nx, $ny, $stop[0], $stop[1]);\n      for (my $i = $per_field; $i < $stop; $i += $per_field)\n        {\n        my $d = _astar_distance($nx, $ny, $stop[$i], $stop[$i+1]);\n        $lowest_distance = $d if $d < $lowest_distance; \n        }\n\n      print STDERR \"#   Opening pos $nx,$ny ($lowest_distance + $lg)\\n\" if $self->{debug} > 1;\n\n      # open new position into OPEN\n      $open->add( [ $lowest_distance + $lg, $nx, $ny, $x, $y, undef ] );\n      $open_by_pos->{$n} = $lg;\n      }\n    }\n\n  ###########################################################################\n  # A* is done, now build a path from the information we computed above:\n\n  # count how many steps we did in A*\n  $self->{stats}->{astar_steps} += $tries;\n\n  # no more nodes to follow, so we couldn't find a path\n  if (!defined $elem)\n    {\n    print STDERR \"# A* couldn't find a path after $max_tries steps.\\n\" if $self->{debug};\n    return [];\n    }\n\n  my $path = [];\n  my ($cx,$cy) = ($elem->[1],$elem->[2]);\n  # the \"last\" cell in the path. Since we follow it backwards, it\n  # becomes actually the next cell\n  my ($lx,$ly);\n  my $type;\n\n  my $label_cell = 0;\t\t# found a cell to attach the label to?\n\n  my @bends;\t\t\t# record all bends in the path to straighten it out\n\n  my $idx = 0;\n  # follow $elem back to the source to find the path\n  while (defined $cx)\n    {\n    last unless exists $closed->{\"$cx,$cy\"};\n    my $xy = \"$cx,$cy\";\n\n    $type = $closed->{$xy}->[ 4 ];\n\n    my ($px,$py) = @{ $closed->{$xy} };\t\t# get X,Y of parent cell\n\n    my $edge_type = ($type||0) & EDGE_TYPE_MASK;\n    if ($edge_type == 0)\n      {\n      my $edge_flags = ($type||0) & EDGE_FLAG_MASK;\n\n      # either a start or a stop cell\n      if (!defined $px)\n\t{\n\t# We can figure it out from the flag of the position of cx,cy\n\t#        ................\n\t#         : EDGE_START_S :\n\t# .......................................\n\t# START_E :    px,py     : EDGE_START_W :\n\t# .......................................\n\t#         : EDGE_START_N :\n\t#         ................\n\t($px,$py) = ($cx, $cy);\t\t# start with same cell\n\t$py ++ if ($edge_flags & EDGE_START_S) != 0; \n\t$py -- if ($edge_flags & EDGE_START_N) != 0; \n\n\t$px ++ if ($edge_flags & EDGE_START_E) != 0; \n\t$px -- if ($edge_flags & EDGE_START_W) != 0; \n\t}\n\n      # if lx, ly is undefined because px,py is a joint, get it via the stored\n      # x,y pos of the very last cell in the path\n      if (!defined $lx)\n     \t{ \n\t$lx = $closed->{$xy}->[6];\n\t$ly = $closed->{$xy}->[7];\n\t}\n\n      # still not known?\n      if (!defined $lx)\n\t{\n\n\t# If lx,ly is undefined because we are at the end of the path,\n   \t# we can figure out from the flag of the position of cx,cy.\n\t#       ..............\n\t#       : EDGE_END_S :\n\t# .................................\n\t# END_E :    lx,ly   : EDGE_END_W :\n\t# .................................\n\t#       : EDGE_END_N :\n\t#       ..............\n\t($lx,$ly) = ($cx, $cy);\t\t# start with same cell\n\n\t$ly ++ if ($edge_flags & EDGE_END_S) != 0; \n\t$ly -- if ($edge_flags & EDGE_END_N) != 0; \n\n\t$lx ++ if ($edge_flags & EDGE_END_E) != 0; \n\t$lx -- if ($edge_flags & EDGE_END_W) != 0; \n\t}\n\n      # now figure out correct type for this cell from positions of\n      # parent/following cell\n      $type += _astar_edge_type($px, $py, $cx, $cy, $lx,$ly);\n      }\n\n    print STDERR \"#  Following back from $lx,$ly over $cx,$cy to $px,$py\\n\" if $self->{debug} > 1;\n\n    if ($px == $lx && $py == $ly && ($cx != $lx || $cy != $ly))\n      {\n      print STDERR \n       \"# Warning: A* detected loop in path-backtracking at $px,$py, $cx,$cy, $lx,$ly\\n\"\n       if $self->{debug};\n      last;\n      }\n\n    $type = EDGE_HOR if ($type & EDGE_TYPE_MASK) == 0;\t\t# last resort\n\n    # if this is the first hor edge, attach the label to it\n    # XXX TODO: This clearly is not optimal. Look for left-most HOR CELL\n    my $t = $type & EDGE_TYPE_MASK;\n\n    # Do not put the label on crossings:\n    if ($label_cell == 0 && (!exists $cells->{\"$cx,$cy\"}) && ($t == EDGE_HOR || $t == EDGE_VER))\n      {\n      $label_cell++;\n      $type += EDGE_LABEL_CELL;\n      }\n\n    push @bends, [ $type, $cx, $cy, -$idx ]\n\tif ($type == EDGE_S_E || $t == EDGE_S_W || $t == EDGE_N_E || $t == EDGE_N_W);\n\n    unshift @$path, $cx, $cy, $type;\t\t# unshift to reverse the path\n\n    last if $closed->{\"$cx,$cy\"}->[ 5 ];\t# stop here?\n\n    ($lx,$ly) = ($cx,$cy);\n    ($cx,$cy) = @{ $closed->{\"$cx,$cy\"} };\t# get X,Y of next cell\n\n    $idx += 3;\t\t\t\t\t# index into $path (for bends)\n    }\n\n  print STDERR \"# Trying to straighten path\\n\" if @bends >= 3 && $self->{debug};\n\n  # try to straighten unnec. inward bends\n  $self->_straighten_path($path, \\@bends, $edge) if @bends >= 3;\n\n  return ($path,$closed,$open_by_pos) if wantarray;\n  $path;\n  }\n\n  # 1:\n  #           |             |\n  #      +----+   =>        |\n  #      |                  |\n  #  ----+            ------+\n\n  # 2:\n  #      +---         +------\n  #      |            |\n  #  +---+        =>  |\n  #  |                |\n\n  # 3:\n  #  ----+            ------+\n  #      |        =>        |\n  #      +----+             |\n  #           |             |\n\n  # 4:\n  #  |                |\n  #  +---+            |\n  #      |        =>  |\n  #      +----+       +------\n\nmy $bend_patterns = [\n\n  # The patterns are duplicated to catch both directions of the path:\n\n  # First five entries must match\n  #\t\t\t\t dx, dy,\n  #\t\t\t\t        coordinates for new edge\n  #\t\t\t\t        (2 == y, 1 == x, first is\n  #\t\t\t\t        taken from A, second from B)\n  # \t\t\t\t\t\t  these replace the first & last bend\n  # 1:\n  [ EDGE_N_W, EDGE_S_E, EDGE_N_W, 0, -1, 2, 1, EDGE_HOR, EDGE_VER, 1,0,  0,-1 ],\t# 0\n  [ EDGE_N_W, EDGE_S_E, EDGE_N_W, -1, 0, 1, 2, EDGE_VER, EDGE_HOR, 0,1,  -1,0 ],\t# 1\n\n  # 2:\n  [ EDGE_S_E, EDGE_N_W, EDGE_S_E, 0, -1, 1, 2, EDGE_VER, EDGE_HOR, 0,-1, 1,0 ],\t\t# 2\n  [ EDGE_S_E, EDGE_N_W, EDGE_S_E, -1, 0, 2, 1, EDGE_HOR, EDGE_VER, -1,0, 0,1 ],\t\t# 3\n\n  # 3:\n  [ EDGE_S_W, EDGE_N_E, EDGE_S_W, 0,  1, 2, 1, EDGE_HOR, EDGE_VER, 1,0, 0,1 ],\t\t# 4\n  [ EDGE_S_W, EDGE_N_E, EDGE_S_W, -1, 0, 1, 2, EDGE_VER, EDGE_HOR, 0,-1, -1,0 ],\t# 5\n\n  # 4:\n  [ EDGE_N_E, EDGE_S_W, EDGE_N_E, 1,  0, 1, 2, EDGE_VER, EDGE_HOR, 0,1, 1,0 ],\t\t# 6\n  [ EDGE_N_E, EDGE_S_W, EDGE_N_E, 0, -1, 2, 1, EDGE_HOR, EDGE_VER, -1,0, 0,-1 ],\t# 7\n\n  ];\n\nsub _straighten_path\n  {\n  my ($self, $path, $bends, $edge) = @_;\n\n  # XXX TODO:\n  # in case of multiple bends, removes only one of them due to overlap\n\n  my $cells = $self->{cells};\n\n  my $i = 0;\n  BEND:\n  while ($i < (scalar @$bends - 2))\n    {\n    # for each bend, check it and the next two bends\n\n#   print STDERR \"Checking bend $i at $bends->[$i], $bends->[$i+1], $bends->[$i+2]\\n\";\n\n    my ($a,$b,$c) = ($bends->[$i],\n\t\t     $bends->[$i+1],\n\t\t     $bends->[$i+2]);\n\n    my $dx = ($b->[1] - $a->[1]);\n    my $dy = ($b->[2] - $a->[2]);\n\n    my $p = 0;\n    for my $pattern (@$bend_patterns)\n      {\n      $p++;\n      next if ($a->[0] != $pattern->[0]) ||\n\t      ($b->[0] != $pattern->[1]) ||\n\t      ($c->[0] != $pattern->[2]) ||\n\t      ($dx != $pattern->[3]) ||\n\t      ($dy != $pattern->[4]);\n\n      # pattern matched\n#      print STDERR \"# Got bends for pattern \", $p-1,\" (@$pattern):\\n\";\n#      print STDERR \"# type x,y,\\n# @$a\\n# @$b\\n# @$c\\n\";\n\n      # check that the alternative path is empty\n\n      # new corner:\n      my $cx = $a->[$pattern->[5]];\n      my $cy = $c->[$pattern->[6]];\n      ($cx,$cy) = ($cy,$cx) if $pattern->[5] == 2;\t# need to swap?\n\n      next BEND if exists $cells->{\"$cx,$cy\"};\n\n#      print STDERR \"# new corner at $cx,$cy (swap: $pattern->[5])\\n\";\n\n      # check from A to new corner\n      my $x = $a->[1];\n      my $y = $a->[2];\n\n      my @replace = ();\n      push @replace, $cx, $cy, $pattern->[0] if ($x == $cx && $y == $cy);\n\n      my $ddx = $pattern->[9];\n      my $ddy = $pattern->[10];\n#      print STDERR \"# dx,dy: $ddx,$ddy\\n\";\n      while ($x != $cx || $y != $cy)\n\t{\n\tnext BEND if exists $cells->{\"$x,$y\"};\n#        print STDERR \"# at $x $y (go to $cx,$cy)\\n\"; sleep(1);\n\tpush @replace, $x, $y, $pattern->[7];\n\t$x += $ddx;\n\t$y += $ddy;\n\t}\n\n      $x = $cx; $y = $cy;\n\n      # check from new corner to C\n      $ddx = $pattern->[11];\n      $ddy = $pattern->[12];\n      while ($x != $c->[1] || $y != $c->[2])\n\t{\n\tnext BEND if exists $cells->{\"$x,$y\"};\n#        print STDERR \"# at $x $y (go to $cx,$cy)\\n\"; sleep(1);\n\tpush @replace, $x, $y, $pattern->[8];\n\t\n\t# set the correct type on the corner\n\t$replace[-1] = $pattern->[0] if ($x == $cx && $y == $cy);\n\t$x += $ddx;\n\t$y += $ddy;\n        }\n      # insert Corner\n      push @replace, $x, $y, $pattern->[8];\n\n#\tuse Data::Dumper; print STDERR Dumper(@replace);\n#\tprint STDERR \"# generated \", scalar @replace, \" entries\\n\";\n#\tprint STDERR \"# idx A $a->[3] C $c->[3]\\n\";\n\n      # the path is clear, so replace the inward bend with the new one\n      my $diff = $a->[3] - $c->[3] ? -3 : 3;\n\n      my $idx = 0; my $p_idx = $a->[3] + $diff;\n      while ($idx < @replace)\n\t{\n#\t print STDERR \"# replace $p_idx .. $p_idx + 2\\n\";\n#\t print STDERR \"# replace $path->[$p_idx] with $replace[$idx]\\n\";\n#\t print STDERR \"# replace $path->[$p_idx+1] with $replace[$idx+1]\\n\";\n#\t print STDERR \"# replace $path->[$p_idx+2] with $replace[$idx+2]\\n\";\n\n\t$path->[$p_idx] = $replace[$idx];\n\t$path->[$p_idx+1] = $replace[$idx+1];\n\t$path->[$p_idx+2] = $replace[$idx+2];\n\t$p_idx += $diff;\n\t$idx += 3;\n \t}\n      } # end for this pattern\n\n    } continue { $i++; };\n  }\n\nsub _map_as_html\n  {\n  my ($self, $cells, $p, $closed, $open, $w, $h) = @_;\n\n  $w ||= 20;\n  $h ||= 20;\n\n  my $html = <<EOF\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n <head>\n <style type=\"text/css\">\n <!--\n td {\n   background: #a0a0a0;\n   border: #606060 solid 1px;\n   font-size: 0.75em;\n }\n td.b, td.b, td.c {\n   background: #404040;\n   border: #606060 solid 1px;\n   }\n td.c {\n   background: #ffffff;\n   }\n table.map {\n   border-collapse: collapse;\n   border: black solid 1px;\n }\n -->\n </style>\n</head>\n<body>\n\n<h1>A* Map</h1>\n\n<p>\nNodes examined: <b>##closed##</b> <br>\nNodes still to do (open): <b>##open##</b> <br>\nNodes in path: <b>##path##</b>\n</p>\nEOF\n;\n\n  $html =~ s/##closed##/keys %$closed /eg;\n  $html =~ s/##open##/keys %$open /eg;\n  my $path = {};\n  while (@$p)\n    {\n    my $x = shift @$p;\n    my $y = shift @$p;\n    my $t = shift @$p;\n    $path->{\"$x,$y\"} = undef;\n    }\n  $html =~ s/##path##/keys %$path /eg;\n  $html .= '<table class=\"map\">' . \"\\n\";\n\n  for my $y (0..$h)\n    {\n    $html .= \" <tr>\\n\";\n    for my $x (0..$w)\n      {\n      my $xy = \"$x,$y\";\n      my $c = '&nbsp;' x 4;\n      $html .= \"  <td class='c'>$c</td>\\n\" and next if\n        exists $cells->{$xy} and ref($cells->{$xy}) =~ /Node/;\n      $html .= \"  <td class='b'>$c</td>\\n\" and next if\n        exists $cells->{$xy} && !exists $path->{$xy};\n\n      $html .= \"  <td>$c</td>\\n\" and next unless\n        exists $closed->{$xy} ||\n        exists $open->{$xy};\n\n      my $clr = '#a0a0a0';\n      if (exists $closed->{$xy})\n        {\n        $c =  ($closed->{$xy}->[3] || '0') . '+' . ($closed->{$xy}->[2] || '0');\n        my $color = 0x10 + 8 * (($closed->{$xy}->[2] || 0));\n        my $color2 = 0x10 + 8 * (($closed->{$xy}->[3] || 0));\n        $clr = sprintf(\"%02x%02x\",$color,$color2) . 'a0';\n        }\n      elsif (exists $open->{$xy})\n        {\n        $c = '&nbsp;' . $open->{$xy} || '0';\n        my $color = 0xff - 8 * ($open->{$xy} || 0);\n        $clr = 'a0' . sprintf(\"%02x\",$color) . '00';\n        }\n      my $b = '';\n      $b = 'border: 2px white solid;' if exists $path->{$xy};\n      $html .= \"  <td style='background: #$clr;$b'>$c</td>\\n\";\n      }\n    $html .= \" </tr>\\n\";\n    }\n \n  $html .= \"\\n</table>\\n\";\n\n  $html;\n  }\n \n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout::Scout - Find paths in a Manhattan-style grid\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\t$graph->layout();\n\n\tprint $graph->as_ascii( );\n\n\t# prints:\n\n\t# +------+     +--------+\n\t# | Bonn | --> | Berlin |\n\t# +------+     +--------+\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Layout::Scout> contains just the actual pathfinding code for\nL<Graph::Easy|Graph::Easy>. It should not be used directly.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 METHODS\n\nThis package inserts a few methods into C<Graph::Easy> and\nC<Graph::Easy::Node> to enable path-finding for graphs. It should not\nbe used directly.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for information.\n\n=cut\n\n",
  "Graph/Easy/Layout.pm": "#############################################################################\n# Layout directed graphs on a flat plane. Part of Graph::Easy.\n#\n# (c) by Tels 2004-2008.\n#############################################################################\n\npackage Graph::Easy::Layout;\n\n$VERSION = '0.29';\n\n#############################################################################\n#############################################################################\n\npackage Graph::Easy;\n\nuse strict;\nrequire Graph::Easy::Node::Cell;\nuse Graph::Easy::Edge::Cell qw/\n  EDGE_HOR EDGE_VER\n  EDGE_CROSS\n  EDGE_TYPE_MASK EDGE_MISC_MASK EDGE_NO_M_MASK\n  EDGE_SHORT_CELL\n /;\n\nuse constant {\n  ACTION_NODE\t=> 0,\t# place node somewhere\n  ACTION_TRACE\t=> 1,\t# trace path from src to dest\n  ACTION_CHAIN\t=> 2,\t# place node in chain (with parent)\n  ACTION_EDGES\t=> 3,\t# trace all edges (shortes connect. first)\n  ACTION_SPLICE\t=> 4,\t# splice in the group fillers\n  };\n\nrequire Graph::Easy::Layout::Chain;\t\t# chain management\nuse Graph::Easy::Layout::Scout;\t\t\t# pathfinding\nuse Graph::Easy::Layout::Repair;\t\t# group cells and splicing/repair\nuse Graph::Easy::Layout::Path;\t\t\t# path management\n\n#############################################################################\n\nsub _assign_ranks\n  {\n  # Assign a rank to each node/group.\n\n  # Afterwards, every node has a rank, these range from 1..infinite for\n  # user supplied ranks, and -1..-infinite for automatically found ranks.\n  # This lets us later distinguish between autoranks and userranks, while\n  # still being able to sort nodes based on their (absolute) rank.\n  my $self = shift;\n\n  # a Heap to keep the todo-nodes (aka rank auto or explicit)\n  my $todo = Graph::Easy::Heap->new();\n  # sort entries based on absolute value\n  $todo->sort_sub( sub ($$) { abs($_[0]) <=> abs($_[1]) } );\n\n  # a list of all other nodes\n  my @also;\n\n  # XXX TODO:\n  # gather elements todo:\n  # graph: contained groups, plus non-grouped nodes\n  # groups: contained groups, contained nodes\n\n  # sort nodes on their ID to get some basic order\n  my @N = $self->sorted_nodes('id');\n  push @N, $self->groups();\n\n  my $root = $self->root_node();\n\n  $todo->add([$root->{rank} = -1,$root]) if ref $root;\n\n  # Gather all nodes that have outgoing connections, but no incoming:\n  for my $n (@N)\n    {\n    # we already handled the root node above\n    next if $root && $n == $root;\n\n    # if no rank set, use 0 as default\n    my $rank_att = $n->raw_attribute('rank');\n\n    $rank_att = undef if defined $rank_att && $rank_att eq 'auto';\n    # XXX TODO: this should not happen, the parser should assign an\n    # automatic rank ID\n    $rank_att = 0 if defined $rank_att && $rank_att eq 'same';\n\n    # user defined ranks range from 1..inf\n    $rank_att++ if defined $rank_att;\n\n    # assign undef or 0, 1 etc\n    $n->{rank} = $rank_att;\n\n    # user defined ranks are \"1..inf\", while auto ranks are -1..-inf\n    $n->{rank} = -1 if !defined $n->{rank} && $n->predecessors() == 0;\n\n    # push \"rank: X;\" nodes, or nodes without predecessors\n    $todo->add([$n->{rank},$n]) if defined $n->{rank};\n    push @also, $n unless defined $n->{rank};\n    }\n\n#  print STDERR \"# Ranking:\\n\";\n#  for my $n (@{$todo->{_heap}})\n#    {\n#    print STDERR \"# $n->[1]->{name} $n->[0] $n->[1]->{rank}:\\n\";\n#    }\n#  print STDERR \"# Leftovers in \\@also:\\n\";\n#  for my $n (@also)\n#    {\n#    print STDERR \"# $n->{name}:\\n\";\n#    }\n\n  # The above step will create a list of todo nodes that start a chain, but\n  # it will miss circular chains like CDEC (e.g. only A appears in todo):\n  # A -> B;  C -> D -> E -> C;\n  # We fix this as last step\n\n  while ((@also != 0) || $todo->elements() != 0)\n    {\n    # while we still have nodes to follow\n    while (my $elem = $todo->extract_top())\n      {\n      my ($rank,$n) = @$elem;\n\n      my $l = $n->{rank};\n\n      # If the rank comes from a user-supplied rank, make the next node\n      # have an automatic rank (e.g. 4 => -4)\n      $l = -$l if $l > 0; \n      # -4 > -5\n      $l--;\n\n      for my $o ($n->successors())\n        {\n        if (!defined $o->{rank})\n          {\n#\t  print STDERR \"# set rank $l for $o->{name}\\n\";\n          $o->{rank} = $l;\n\t  $todo->add([$l,$o]);\n          }\n        }\n      }\n\n    last unless @also;\n\n    while (@also)\n      {\n      my $n = shift @also;\n      # already done? so skip it\n      next if defined $n->{rank};\n\n      $n->{rank} = -1; \n      $todo->add([-1, $n]);\n      # leave the others for later\n      last;\n      }\n\n    } # while still something todo\n\n#  print STDERR \"# Final ranking:\\n\";\n#  for my $n (@N)\n#    {\n#    print STDERR \"# $n->{name} $n->{rank}:\\n\";\n#    }\n\n  $self;\n  }\n\nsub _follow_chain\n  {\n  # follow the chain from the node\n  my ($node) = @_;\n\n  my $self = $node->{graph};\n\n  no warnings 'recursion';\n\n  my $indent = ' ' x (($node->{_chain}->{id} || 0) + 1);\n  print STDERR \"#$indent Tracking chain from $node->{name}\\n\" if $self->{debug};\n\n  # create a new chain and point it to the start node\n  my $chain = Graph::Easy::Layout::Chain->new( start => $node, graph => $self );\n  $self->{chains}->{ $chain->{id} } = $chain;\n\n  my $first_node = $node;\n  my $done = 1;\t\t\t\t# how many nodes did we process?\n NODE:\n  while (3 < 5)\n    {\n    # Count \"unique\" successsors, ignoring selfloops, multiedges and nodes\n    # in the same chain.\n\n    my $c = $node->{_chain};\n\n    local $node->{_c} = 1;\t\t# stop back-ward loops\n\n    my %suc;\n\n    for my $e (values %{$node->{edges}})\n      {\n      my $to = $e->{to};\n\n      # ignore self-loops\n      next if $e->{from} == $e->{to};\n\n      # XXX TODO\n      # skip links from/to groups\n      next if $e->{to}->isa('Graph::Easy::Group') ||\n              $e->{from}->isa('Graph::Easy::Group');\n\n#      print STDERR \"# bidi $e->{from}->{name} to $e->{to}->{name}\\n\" if $e->{bidirectional} && $to == $node;\n\n      # if it is bidirectional, and points the \"wrong\" way, turn it around\n      $to = $e->{from} if $e->{bidirectional} && $to == $node;\n\n      # edge leads to this node instead from it?\n      next if $to == $node;\n\n#      print STDERR \"# edge_flow for edge $e\", $e->edge_flow() || 'undef' ,\"\\n\";\n#      print STDERR \"# flow for edge $e\", $e->flow() ,\"\\n\";\n\n      # If any of the leading out edges has a flow, stop the chain here\n      # This prevents a chain on an edge w/o a flow to be longer and thus\n      # come first instead of a flow-edge. But don't stop if there is only\n      # one edge:\n\n      if (defined $e->edge_flow())\n\t{\n        %suc = ( $to->{name} => $to );\t\t# empy any possible chain info\n        last;\n        }\n\n      next if exists $to->{_c};\t\t# backloop into current branch?\n\n      next if defined $to->{_chain} &&\t# ignore if it points to the same\n\t\t$to->{_chain} == $c; \t# chain (backloop)\n\n      # if the next node's grandparent is the same as ours, it depends on us\n      next if $to->find_grandparent() == $node->find_grandparent();\n\n\t\t\t\t\t# ignore multi-edges by dropping\n      $suc{$to->{name}} = $to;\t\t# duplicates\n      }\n\n    last if keys %suc == 0;\t\t# the chain stopped here\n\n    if (scalar keys %suc == 1)\t\t# have only one unique successor?\n      {\n      my $s = $suc{ each %suc };\n\n      if (!defined $s->{_chain})\t# chain already done?\n        {\n        $c->add_node( $s );\n\n        $node = $s;\t\t\t# next node\n\n        print STDERR \"#$indent Skipping ahead to $node->{name}\\n\" if $self->{debug};\n\n        $done++;\t\t\t# one more\n        next NODE;\t\t\t# skip recursion\n        }\n      }\n\n    # Select the longest chain from the list of successors\n    # and join it with the current one:\n\n    my $max = -1;\n    my $next;\t\t\t\t# successor\n    my $next_chain = undef;\n\n    print STDERR \"#$indent $node->{name} successors: \\n\" if $self->{debug};\n\n    my @rc;\n\n    # for all successors\n    #for my $s (sort { $a->{name} cmp $b->{name} || $a->{id} <=> $b->{id} }  values %suc)\n    for my $s (values %suc)\n      {\n      print STDERR \"# suc $s->{name} chain \", $s->{_chain} || 'undef',\"\\n\" if $self->{debug};\n\n      $done += _follow_chain($s) \t# track chain\n       if !defined $s->{_chain};\t# if not already done\n\n      next if $s->{_chain} == $c;\t# skip backlinks\n\n      my $ch = $s->{_chain};\n\n      push @rc, [ $ch, $s ];\n      # point node to new next node\n      ($next_chain, $max, $next) = \n\t($ch, $ch->{len}, $s) if $ch->{len} > $max;\n      }\n\n    if (defined $next_chain && $self->{debug})\n      {\n      print STDERR \"#   results of tracking successors:\\n\";\n      for my $ch (@rc)\n        {\n        my ($c,$s) = @$ch;\n        my $len = $c->length($s);\n        print STDERR \"#    chain $c->{id} starting at $c->{start}->{name} (len $c->{len}) \".\n                     \" pointing to node $s->{name} (len from there: $len)\\n\";\n        }\n      print STDERR \"# Max chain length is $max (chain id $next_chain->{id})\\n\";\n      }\n\n    if (defined $next_chain)\n      {\n      print STDERR \"#$indent $node->{name} next: \" . $next_chain->start()->{name} . \"\\n\" if $self->{debug};\n\n      if ($self->{debug})\n\t{\n\tprint STDERR \"# merging chains\\n\";\n\t$c->dump(); $next_chain->dump();\n\t}\n\n      $c->merge($next_chain, $next)\t\t# merge the two chains\n\tunless $next == $self->{_root}\t\t# except if the next chain starts with\n\t\t\t\t\t\t# the root node (bug until v0.46)\n;#\t || $next_chain->{start} == $self->{_root}; # or the first chain already starts\n\t\t\t\t\t\t# with the root node (bug until v0.47)\n\n      delete $self->{chains}->{$next_chain->{id}} if $next_chain->{len} == 0;\n      }\n\n    last;\n    }\n  \n  print STDERR \"#$indent Chain $node->{_chain} ended at $node->{name}\\n\" if $self->{debug};\n\n  $done;\t\t\t\t# return nr of done nodes\n  }\n\nsub _find_chains\n  {\n  # Track all node chains (A->B->C etc), trying to find the longest possible\n  # node chain. Returns (one of) the root node(s) of the graph.\n  my $self = shift;\n\n  print STDERR \"# Tracking chains\\n\" if $self->{debug};\n\n  # drop all old chain info\n  $self->{_chains} = { };\n  $self->{_chain} = 0;\t\t\t\t\t# new chain ID\n\n  # For all not-done-yet nodes, track the chain starting with that node.\n\n  # compute predecessors for all nodes: O(1)\n  my $p;\n  my $has_origin = 0;\n  foreach my $n (values %{$self->{nodes}}, values %{$self->{groups}})\n#  for my $n (values %{$self->{nodes}})\n    {\n    $n->{_chain} = undef;\t\t\t\t# reset chain info\n    $has_origin = 0;\n    $has_origin = 1 if defined $n->{origin} && $n->{origin} != $n;\n    $p->{$n->{name}} = [ $n->has_predecessors(), $has_origin, abs($n->{rank}) ];\n    }\n\n  my $done = 0; my $todo = scalar keys %{$self->{nodes}};\n\n  # the node where the layout should start, as name\n  my $root_name = $self->{attr}->{root};\n  $self->{_root} = undef;\t\t\t\t# as ref to a Node object\n\n  # Start at nodes with no predecessors (starting points) and then do the rest:\n  for my $name ($root_name, sort {\n    my $aa = $p->{$a};\n    my $bb = $p->{$b};\n\n    # sort first on rank\n    $aa->[2] <=> $bb->[2] ||\n    # nodes that have an origin come last\n    $aa->[1] <=> $bb->[1] ||\n    # nodes with no predecessorts are to be prefered \n    $aa->[0] <=> $bb->[0] ||\n    # last resort, alphabetically sorted\n    $a cmp $b \n   } keys %$p)\n    {\n    next unless defined $name;\t\t# in case no root was set, first entry\n\t\t\t\t\t# will be undef and must be skipped\n    my $n = $self->{nodes}->{$name};\n\n#    print STDERR \"# tracing chain from $name (\", join(\", \", @{$p->{$name}}),\")\\n\";\n\n    # store root node unless already found, is accessed in _follow_chain()\n    $self->{_root} = $n unless defined $self->{_root};\n\n    last if $done == $todo;\t\t\t# already processed all nodes?\n\n    # track the chain unless already done and count number of nodes done\n    $done += _follow_chain($n) unless defined $n->{_chain};\n    }\n\n  print STDERR \"# Oops - done only $done nodes, but should have done $todo.\\n\" if $done != $todo && $self->{debug};\n  print STDERR \"# Done all $todo nodes.\\n\" if $done == $todo && $self->{debug};\n\n  $self->{_root};\n  }\n\n#############################################################################\n# debug\n\nsub _dump_stack\n  {\n  my ($self, @todo) = @_;\n\n  print STDERR \"# Action stack contains \", scalar @todo, \" steps:\\n\";\n  for my $action (@todo)\n    {\n    my $action_type = $action->[0];\n    if ($action_type == ACTION_NODE)\n      {\n      my ($at,$node,$try,$edge) = @$action;\n      my $e = ''; $e = \" on edge $edge->{id}\" if defined $edge;\n      print STDERR \"#  place '$node->{name}' with try $try$e\\n\";\n      }\n    elsif ($action_type == ACTION_CHAIN)\n      {\n      my ($at, $node, $try, $parent, $edge) = @$action;\n      my $id = 'unknown'; $id = $edge->{id} if ref($edge);\n      print STDERR\n       \"#  chain '$node->{name}' from parent '$parent->{name}' with try $try (for edge id $id)'\\n\";\n      }\n    elsif ($action_type == ACTION_TRACE)\n      {\n      my ($at,$edge) = @$action;\n      my ($src,$dst) = ($edge->{from}, $edge->{to});\n      print STDERR\n       \"#  trace '$src->{name}' to '$dst->{name}' via edge $edge->{id}\\n\";\n      }\n    elsif ($action_type == ACTION_EDGES)\n      {\n      my $at = shift @$action;\n      print STDERR\n       \"#  tracing the following edges, shortest and with flow first:\\n\";\n\n      }\n    elsif ($action_type == ACTION_SPLICE)\n      {\n      my ($at) = @$action;\n      print STDERR\n       \"#  splicing in group filler cells\\n\";\n      }\n    }\n  }\n\nsub _action\n  {\n  # generate an action for the action stack toplace a node\n  my ($self, $action, $node, @params) = @_;\n\n  # mark the node as already done\n  delete $node->{_todo};\n\n  # mark all children of $node as processed, too, because they will be\n  # placed at the same time:\n  $node->_mark_as_placed() if keys %{$node->{children}} > 0;\n\n  [ $action, $node, @params ];\n  }\n\n#############################################################################\n# layout the graph\n\n# The general layout routine for the entire graph:\n\nsub layout\n  {\n  my $self = shift;\n\n  # ( { type => 'force' } )\n  my $args = $_[0];\n  # ( type => 'force' )\n  $args = { @_ } if @_ > 1;\n\n  my $type = 'adhoc';\n  $type = 'force' if $args->{type} && $args->{type} eq 'force';\n\n  # protect the layout with a timeout, unless run under the debugger:\n  eval {\n    local $SIG{ALRM} = sub { die \"layout did not finish in time\\n\" };\n    alarm(abs( $args->{timeout} || $self->{timeout} || 5))\n\tunless defined $DB::single; # no timeout under the debugger\n\n    print STDERR \"#\\n# Starting $type-based layout.\\n\" if $self->{debug};\n\n    # Reset the sequence of the random generator, so that for the same\n    # seed, the same layout will occur. Both for testing and repeatable\n    # layouts based on max score.\n    srand($self->{seed});\n\n    if ($type eq 'force')\n      {\n      require Graph::Easy::Layout::Force;\n      $self->error(\"Force-directed layouts are not yet implemented.\");\n      $self->_layout_force();\n      }\n    else\n      {\n      $self->_edges_into_groups();\n\n      $self->_layout();\n      }\n\n    };\t\t\t\t\t# eval {}; -- end of timeout protected code\n\n  alarm(0);\t\t\t\t# disable alarm\n\n  # cleanup\n  $self->{chains} = undef;\t\t# drop chain info\n  foreach my $n (values %{$self->{nodes}}, values %{$self->{groups}})\n    {\n    # drop old chain info\n    $n->{_next} = undef;\n    delete $n->{_chain};\n    delete $n->{_c};\n    }\n\n  delete $self->{_root};\n\n  die $@ if $@;\t\t\t\t# propagate errors\n  }\n\nsub _drop_caches\n  {\n  # before the layout phase, we drop cached information from the last run\n  my $self = shift;\n\n  for my $n (values %{$self->{nodes}})\n    {\n    # XXX after we laid out the individual groups:    \n    # skip nodes that are not part of the current group\n    #next if $n->{group} && !$self->{graph};\n\n    # empty the cache of computed values (flow, label, border etc)\n    $n->{cache} = {};\n\n    $n->{x} = undef; $n->{y} = undef;\t# mark every node as not placed yet\n    $n->{w} = undef;\t\t\t# force size recalculation\n    $n->{_todo} = undef;\t\t# mark as todo\n    }\n  for my $g (values %{$self->{groups}})\n    {\n    $g->{x} = undef; $g->{y} = undef;\t# mark every group as not placed yet\n    $g->{_todo} = undef;\t\t# mark as todo\n    }\n  }\n\nsub _layout\n  {\n  my $self = shift;\n\n  ###########################################################################\n  # do some assorted stuff beforehand\n\n  print STDERR \"# Doing layout for \", \n\t(defined $self->{name} ? 'group ' . $self->{name} : 'main graph'),\n\t\"\\n\" if $self->{debug};\n\n  # XXX TODO: \n  # for each primary group\n#  my @groups = $self->groups_within(0);\n#\n#  if (@groups > 0 && $self->{debug})\n#    {\n#    print STDERR \"# Found the following top-level groups:\\n\";\n#    for my $g (@groups)\n#      {\n#      print STDERR \"# $g $g->{name}\\n\";\n#      }\n#    }\n#\n#  # layout each group on its own, recursively:\n#  foreach my $g (@groups)\n#    {\n#    $g->_layout();\n#    }\n\n  # finally assembly everything together\n\n  $self->_drop_caches();\n\n  local $_; $_->_grow() for values %{$self->{nodes}};\n\n  $self->_assign_ranks();\n\n  # find (longest possible) chains of nodes to \"straighten\" graph\n  my $root = $self->_find_chains();\n\n  ###########################################################################\n  # prepare our stack of things we need to do before we are finished\n\n  # action stack, place root 1st if it is known\n  my @todo = $self->_action( ACTION_NODE, $root, 0 ) if ref $root;\n\n  if ($self->{debug})\n    {\n    print STDERR \"#  Generated the following chains:\\n\";\n    for my $chain (\n     sort { $a->{len} <=> $b->{len} || $a->{start}->{name} cmp $b->{start}->{name} }\n      values %{$self->{chains}})\n      {\n      $chain->dump('  ');\n      }\n    }\n\n  # mark all edges as unprocessed, so that we do not process them twice\n  for my $edge (values %{$self->{edges}})\n    { \n    $edge->_clear_cells();\n    $edge->{_todo} = undef;\t\t# mark as todo\n    }\n\n  # XXX TODO:\n  # put all chains on heap (based on their len)\n  # take longest chain, resolve it and all \"connected\" chains, repeat until\n  # heap is empty\n\n  for my $chain (sort { \n\n     # chain starting at root first\n     (($b->{start} == $root) <=> ($a->{start} == $root)) ||\n\n     # longest chains first\n     ($b->{len} <=> $a->{len}) ||\n\n     # chains on nodes that do have an origin come later\n     (defined($a->{start}->{origin}) <=> defined ($b->{start}->{origin})) ||\n\n     # last resort, sort on name of the first node in chain\n     ($a->{start}->{name} cmp $b->{start}->{name}) \n\n     } values %{$self->{chains}})\n    {\n    print STDERR \"# laying out chain $chain->{id} (len $chain->{len})\\n\" if $self->{debug};\n\n    # layout the chain nodes, then resolve inter-chain links, then traverse\n    # chains recursively\n    push @todo, @{ $chain->layout() } unless $chain->{_done};\n    }\n\n  print STDERR \"# Done laying out all chains, doing left-overs:\\n\" if $self->{debug};\n\n  $self->_dump_stack(@todo) if $self->{debug};\n\n  # After laying out all chained nodes and their links, we need to resolve\n  # left-over edges and links. We do this for each node, and then for each of\n  # its edges, but do the edges shortest-first.\n \n  for my $n (values %{$self->{nodes}})\n    {\n    push @todo, $self->_action( ACTION_NODE, $n, 0 ); # if exists $n->{_todo};\n\n    # gather to-do edges\n    my @edges = ();\n    for my $e (sort { $a->{to}->{name} cmp $b->{to}->{name} } values %{$n->{edges}})\n#    for my $e (values %{$n->{edges}})\n      {\n      # edge already done?\n      next unless exists $e->{_todo};\n\n      # skip links from/to groups\n      next if $e->{to}->isa('Graph::Easy::Group') ||\n              $e->{from}->isa('Graph::Easy::Group');\n\n      push @edges, $e;\n      delete $e->{_todo};\n      }\n    # XXX TODO: This does not work, since the nodes are not yet laid out\n    # sort them on their shortest distances\n#    @edges = sort { $b->_distance() <=> $a->_distance() } @edges;\n\n    # put them on the action stack in that order\n    for my $e (@edges)\n      {\n      push @todo, [ ACTION_TRACE, $e ];\n#      print STDERR \"do $e->{from}->{name} to $e->{to}->{name} ($e->{id} \" . $e->_distance().\")\\n\";\n#      push @todo, [ ACTION_CHAIN, $e->{to}, 0, $n, $e ];\n      }\n    }\n\n  print STDERR \"# Done laying out left-overs.\\n\" if $self->{debug};\n\n  # after laying out all inter-group nodes and their edges, we need to splice in the\n  # group cells\n  if (scalar $self->groups() > 0)\n    {\n    push @todo, [ ACTION_SPLICE ] if scalar $self->groups();\n\n    # now do all group-to-group and node-to-group and group-to-node links:\n    for my $n (values %{$self->{groups}})\n      {\n      }\n    }\n\n  $self->_dump_stack(@todo) if $self->{debug};\n\n  ###########################################################################\n  # prepare main backtracking-loop\n\n  my $score = 0;\t\t\t# overall score\n  $self->{cells} = { };\t\t\t# cell array (0..x,0..y)\n  my $cells = $self->{cells};\n\n  print STDERR \"# Start\\n\" if $self->{debug};\n\n  $self->{padding_cells} = 0;\t\t# set to false (no filler cells yet)\n\n  my @done = ();\t\t\t# stack with already done actions\n  my $step = 0;\n  my $tries = 16;\n\n  # store for each rank the initial row/coluumn\n  $self->{_rank_pos} = {};\n  # does rank_pos store rows or columns?\n  $self->{_rank_coord} = 'y';\n  my $flow = $self->flow();\n  $self->{_rank_coord} = 'x' if $flow == 0 || $flow == 180;\n\n  TRY:\n  while (@todo > 0)\t\t\t# all actions on stack done?\n    {\n    $step ++;\n\n    if ($self->{debug} && ($step % 1)==0)\n      {\n      my ($nodes,$e_nodes,$edges,$e_edges) = $self->_count_done_things();\n      print STDERR \"# Done $nodes nodes and $edges edges.\\n\";\n      #$self->{debug} = 2 if $nodes > 243;\n      return if ($nodes > 230);\n      }\n\n    # pop one action and mark it as done\n    my $action = shift @todo; push @done, $action;\n\n    # get the action type (ACTION_NODE etc)\n    my $action_type = $action->[0];\n\n    my ($src, $dst, $mod, $edge);\n\n    if ($action_type == ACTION_NODE)\n      {\n      my (undef, $node,$try,$edge) = @$action;\n      print STDERR \"# step $step: action place '$node->{name}' (try $try)\\n\" if $self->{debug};\n\n      $mod = 0 if defined $node->{x};\n      # $action is node to be placed, generic placement at \"random\" location\n      $mod = $self->_find_node_place( $node, $try, undef, $edge) unless defined $node->{x};\n      }\n    elsif ($action_type == ACTION_CHAIN)\n      {\n      my (undef, $node,$try,$parent, $edge) = @$action;\n      print STDERR \"# step $step: action chain '$node->{name}' from parent '$parent->{name}'\\n\" if $self->{debug};\n\n      $mod = 0 if defined $node->{x};\n      $mod = $self->_find_node_place( $node, $try, $parent, $edge ) unless defined $node->{x};\n      }\n    elsif ($action_type == ACTION_TRACE)\n      {\n      # find a path to the target node\n      ($action_type,$edge) = @$action;\n\n      $src = $edge->{from}; $dst = $edge->{to};\n\n      print STDERR \"# step $step: action trace '$src->{name}' => '$dst->{name}'\\n\" if $self->{debug};\n\n      if (!defined $dst->{x})\n        {\n#\twarn (\"Target node $dst->{name} not yet placed\");\n        $mod = $self->_find_node_place( $dst, 0, undef, $edge );\n\t}        \n      if (!defined $src->{x})\n        {\n#\twarn (\"Source node $src->{name} not yet placed\");\n        $mod = $self->_find_node_place( $src, 0, undef, $edge );\n\t}        \n\n      # find path (mod is score modifier, or undef if no path exists)\n      $mod = $self->_trace_path( $src, $dst, $edge );\n      }\n    elsif ($action_type == ACTION_SPLICE)\n      {\n      # fill in group info and return\n      $self->_fill_group_cells($cells) unless $self->{error};\n      $mod = 0;\n      }\n    else\n      {\n      require Carp;\n      Carp::confess (\"Illegal action $action->[0] on TODO stack\");\n      }\n\n    if (!defined $mod)\n      {\n      # rewind stack\n      if (($action_type == ACTION_NODE || $action_type == ACTION_CHAIN))\n        { \n        print STDERR \"# Step $step: Rewind stack for $action->[1]->{name}\\n\" if $self->{debug};\n\n        # undo node placement and free all cells\n        $action->[1]->_unplace() if defined $action->[1]->{x};\n        $action->[2]++;\t\t# increment try for placing\n        $tries--;\n\tlast TRY if $tries == 0;\n        }\n      else\n        {\n        print STDERR \"# Step $step: Rewind stack for path from $src->{name} to $dst->{name}\\n\" if $self->{debug};\n    \n        # if we couldn't find a path, we need to rewind one more action (just\n\t# redoing the path would would fail again!)\n\n#        unshift @todo, pop @done;\n#        unshift @todo, pop @done;\n\n#        $action = $todo[0];\n#        $action_type = $action->[0];\n\n#        $self->_dump_stack(@todo);\n#\n#        if (($action_type == ACTION_NODE || $action_type == ACTION_CHAIN))\n#          {\n#          # undo node placement\n#          $action->[1]->_unplace();\n#          $action->[2]++;\t\t# increment try for placing\n#          }\n  \t$tries--;\n\tlast TRY if $tries == 0;\n        next TRY;\n        } \n      unshift @todo, $action;\n      next TRY;\n      } \n\n    $score += $mod;\n    print STDERR \"# Step $step: Score is $score\\n\\n\" if $self->{debug};\n    }\n\n    $self->{score} = $score;\t\t\t# overall score\n\n#  if ($tries == 0)\n    {\n    my ($nodes,$e_nodes,$edges,$e_edges) = $self->_count_done_things();\n    if  ( ($nodes != $e_nodes) ||\n          ($edges != $e_edges) )\n      {\n      $self->warn( \"Layouter could only place $nodes nodes/$edges edges out of $e_nodes/$e_edges - giving up\");\n      }\n     else\n      {\n      $self->_optimize_layout();\n      }\n    }\n    # all things on the stack were done, or we encountered an error\n  }\n\nsub _count_done_things\n  {\n  my $self = shift;\n\n  # count placed nodes\n  my $nodes = 0;\n  my $i = 1;\n  for my $n (values %{$self->{nodes}})\n    {\n    $nodes++ if defined $n->{x};\n    }\n  my $edges = 0;\n  $i = 1;\n  # count fully routed edges\n  for my $e (values %{$self->{edges}})\n    {\n    $edges++ if scalar @{$e->{cells}} > 0 && !exists $e->{_todo};\n    }\n  my $e_nodes = scalar keys %{$self->{nodes}};\n  my $e_edges = scalar keys %{$self->{edges}};\n  return ($nodes,$e_nodes,$edges,$e_edges);\n  }\n\nmy $size_name = {\n  EDGE_HOR() => [ 'cx', 'x' ],\n  EDGE_VER() => [ 'cy', 'y' ]\n  };\n\nsub _optimize_layout\n  {\n  my $self = shift;\n\n  # optimize the finished layout\n\n  my $all_cells = $self->{cells};\n\n  ###########################################################################\n  # for each edge, compact HOR and VER stretches of cells\n  for my $e (values %{$self->{edges}})\n    {\n    my $cells = $e->{cells};\n\n    # there need to be at least two cells for us to be able to combine them\n    next if @$cells < 2;\n\n    print STDERR \"# Compacting edge $e->{from}->{name} to $e->{to}->{name}\\n\"\n      if $self->{debug};\n\n    my $f = $cells->[0]; my $i = 1;\n    my ($px, $py);\t\t# coordinates of the placeholder cell\n    while ($i < @$cells)\n      {\n      my $c = $cells->[$i++];\n\n#      print STDERR \"#  at $f->{type} $f->{x},$f->{y}  (next: $c->{type} $c->{x},$c->{y})\\n\";\n\n      my $t1 = $f->{type} & EDGE_NO_M_MASK;\n      my $t2 = $c->{type} & EDGE_NO_M_MASK;\n\n      # > 0: delete that cell: 1 => reverse order, 2 => with hole\n      my $delete = 0;\n\n      # compare $first to $c\n      if ($t1 == $t2 && ($t1 == EDGE_HOR || $t1 == EDGE_VER))\n        {\n#\tprint STDERR \"#  $i: Combining them.\\n\";\n\n\t# check that both pieces are continues (e.g. with a cross section,\n\t# the other edge has a hole in the cell array)\n\n\t# if the second cell has a misc (label, short) flag, carry it over\n        $f->{type} += $c->{type} & EDGE_MISC_MASK;\n\n        # which size/coordinate to modify\n\tmy ($m,$co) = @{ $size_name->{$t1} };\n\n#\tprint STDERR \"# Combining edge cells $f->{x},$f->{y} and $c->{x},$c->{y}\\n\";\n\n\t# new width/height is the combined size\n\t$f->{$m} = ($f->{$m} || 1) + ($c->{$m} || 1);\n\n#\tprint STDERR \"# Result $f->{x},$f->{y} \",$f->{cx}||1,\" \", $f->{cy}||1,\"\\n\";\n\n\t# drop the reference from the $cells array for $c\n\tdelete $all_cells->{ \"$c->{x},$c->{y}\" };\n\n        ($px, $py) = ($c->{x}, $c->{y});\n\tif ($f->{$co} > $c->{$co})\n\t  {\n\t  # remember coordinate of the moved cell for the placeholder\n          ($px, $py) = ($f->{x}, $f->{y});\n\n\t  # move $f to the new place if it was modified\n\t  delete $all_cells->{ \"$f->{x},$f->{y}\" };\n\t  # correct start coordinate for reversed order\n\t  $f->{$co} -= ($c->{$m} || 1);\n\n\t  $all_cells->{ \"$f->{x},$f->{y}\" } = $f;\n\t  }\n\n\t$delete = 1;\t\t\t\t# delete $c\n\t}\n\n      # remove that cell, but start combining at next\n#      print STDERR \"# found hole at $i\\n\" if $c->{type} == EDGE_HOLE;\n\n      $delete = 2 if $c->{type} == EDGE_HOLE;\n      if ($delete)\n\t{\n        splice (@{$e->{cells}}, $i-1, 1);\t\t# remove from the edge\n\tif ($delete == 1)\n\t  {\n\t  my $xy = \"$px,$py\";\n\t  # replace with placeholder (important for HTML output)\n\t  $all_cells->{$xy} = Graph::Easy::Edge::Cell::Empty->new (\n\t    x => $px, y => $py,\n\t  ) unless $all_cells->{$xy};\t\n\n          $i--; $c = $f;\t\t\t\t# for the next statement\n\t  }\n\telse { $c = $cells->[$i-1]; }\n        }\n      $f = $c;\n      }\n\n#   $i = 0;\n#   while ($i < @$cells)\n#     {\n#     my $c = $cells->[$i];\n#     print STDERR \"#   $i: At $c->{type} $c->{x},$c->{y}  \", $c->{cx}||1, \" \", $c->{cy} || 1,\"\\n\";\n#     $i++;\n#     }\n\n    }\n  print STDERR \"# Done compacting edges.\\n\" if $self->{debug};\n\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Layout - Layout the graph from Graph::Easy\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = Graph::Easy::Node->new(\n\t\tname => 'Bonn',\n\t);\n\tmy $berlin = Graph::Easy::Node->new(\n\t\tname => 'Berlin',\n\t);\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\t$graph->layout();\n\n\tprint $graph->as_ascii( );\n\n\t# prints:\n\n\t# +------+     +--------+\n\t# | Bonn | --> | Berlin |\n\t# +------+     +--------+\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Layout> contains just the actual layout code for\nL<Graph::Easy|Graph::Easy>.\n\n=head1 METHODS\n\nC<Graph::Easy::Layout> injects the following methods into the C<Graph::Easy>\nnamespace:\n\n=head2 layout()\n\n\t$graph->layout();\n\nLayout the actual graph.\n\n=head2 _assign_ranks()\n\n\t$graph->_assign_ranks();\n\nUsed by C<layout()> to assign each node a rank, so they can be sorted\nand grouped on these.\n\n=head2 _optimize_layout\n\nUsed by C<layout()> to optimize the layout as a last step.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Node/Anon.pm": "#############################################################################\n# (c) by Tels 2004. Part of Graph::Easy. An anonymous (invisible) node.\n#\n#############################################################################\n\npackage Graph::Easy::Node::Anon;\n\nuse Graph::Easy::Node;\n\n@ISA = qw/Graph::Easy::Node/;\n$VERSION = '0.11';\n\nuse strict;\n\nsub _init\n  {\n  my $self = shift;\n\n  $self->SUPER::_init(@_);\n\n  $self->{name} = '#' . $self->{id};\n  $self->{class} = 'node.anon';\n\n  $self->{att}->{label} = ' ';\n\n  $self;\n  }\n\nsub _correct_size\n  {\n  my $self = shift;\n\n  $self->{w} = 3;\n  $self->{h} = 3;\n\n  $self;\n  }\n\nsub attributes_as_txt\n  {\n  my $self = shift;\n\n  $self->SUPER::attributes_as_txt( {\n     node => {\n       label => undef,\n       shape => undef,\n       class => undef,\n       } } );\n  }\n\nsub as_pure_txt\n  {\n  '[ ]';\n  }\n\nsub _as_part_txt\n  {\n  '[ ]';\n  }\n\nsub as_txt\n  {\n  my $self = shift;\n\n  '[ ]' . $self->attributes_as_txt();\n  }\n\nsub text_styles_as_css\n  {\n  '';\n  }\n\nsub is_anon\n  {\n  # is an anon node\n  1;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Node::Anon - An anonymous, invisible node in Graph::Easy\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy::Node::Anon;\n\n\tmy $anon = Graph::Easy::Node::Anon->new();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Node::Anon> represents an anonymous, invisible node.\nThese can be used to let edges start and end \"nowhere\".\n\nThe syntax in the Graph::Easy textual description language looks like this:\n\n\t[ ] -> [ Bonn ] -> [ ]\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy::Node>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2006 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Node/Cell.pm": "#############################################################################\n# (c) by Tels 2004 - 2005. An empty filler cell. Part of Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Node::Cell;\n\nuse Graph::Easy::Node;\n\n@ISA = qw/Graph::Easy::Node/;\n$VERSION = '0.10';\n\nuse strict;\n\n#############################################################################\n\nsub _init\n  {\n  # generic init, override in subclasses\n  my ($self,$args) = @_;\n  \n  $self->{class} = '';\n  $self->{name} = '';\n  \n  $self->{x} = 0;\n  $self->{y} = 0;\n\n  # default: belongs to no node\n  $self->{node} = undef;\n\n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(node|graph|x|y)\\z/)\n      {\n      require Carp;\n      Carp::confess (\"Invalid argument '$k' passed to Graph::Easy::Node::Cell->new()\");\n      }\n    $self->{$k} = $args->{$k};\n    }\n \n  $self;\n  }\n\nsub _correct_size\n  {\n  my $self = shift;\n\n  $self->{w} = 0;\n  $self->{h} = 0;\n\n  $self;\n  }\n\nsub node\n  {\n  # return the node this cell belongs to\n  my $self = shift;\n\n  $self->{node};\n  }\n\nsub as_ascii\n  {\n  '';\n  }\n\nsub as_html\n  {\n  '';\n  }\n\nsub group\n  {\n  my $self = shift;\n\n  $self->{node}->group();\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Node::Cell - An empty filler cell\n\n=head1 SYNOPSIS\n\n        use Graph::Easy;\n        use Graph::Easy::Edge;\n\n\tmy $graph = Graph::Easy->new();\n\n\tmy $node = $graph->add_node('A');\n\n\tmy $path = Graph::Easy::Node::Cell->new(\n\t  graph => $graph, node => $node,\n\t);\n\n\t...\n\n\tprint $graph->as_ascii();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Node::Cell> is used to reserve a cell in the grid for nodes\nthat occupy more than one cell.\n\nYou should not need to use this class directly.\n\n=head1 METHODS\n\n=head2 error()\n\n\t$last_error = $cell->error();\n\n\t$cvt->error($error);\t\t\t# set new messags\n\t$cvt->error('');\t\t\t# clear error\n\nReturns the last error message, or '' for no error.\n\n=head2 node()\n\n\tmy $node = $cell->node();\n\nReturns the node this filler cell belongs to.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2005 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Node/Empty.pm": "#############################################################################\n# An empty, borderless cell. Part of Graph::Easy.\n#\n#############################################################################\n\npackage Graph::Easy::Node::Empty;\n\nuse Graph::Easy::Node;\n\n@ISA = qw/Graph::Easy::Node/;\n$VERSION = '0.06';\n\nuse strict;\n\n#############################################################################\n\nsub _init\n  {\n  # generic init, override in subclasses\n  my ($self,$args) = @_;\n\n  $self->SUPER::_init($args);\n  \n  $self->{class} = 'node.empty';\n\n  $self;\n  }\n\nsub _correct_size\n  {\n  my $self = shift;\n\n  $self->{w} = 3;\n  $self->{h} = 3;\n\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Node::Empty - An empty, borderless cell in a node cluster\n\n=head1 SYNOPSIS\n\n\tmy $cell = Graph::Easy::Node::Empty->new();\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Node::Empty> represents a borderless, empty cell in\na node cluster. It is mainly used to have an object to render collapsed\nborders in ASCII output.\n\nYou should not need to use this class directly.\n\n=head1 SEE ALSO\n\nL<Graph::Easy::Node>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Node.pm": "#############################################################################\n# Represents one node in a Graph::Easy graph.\n#\n# (c) by Tels 2004-2008. Part of Graph::Easy.\n#############################################################################\n\npackage Graph::Easy::Node;\n\n$VERSION = '0.38';\n\nuse Graph::Easy::Base;\nuse Graph::Easy::Attributes;\n@ISA = qw/Graph::Easy::Base/;\n\n# to map \"arrow-shape\" to \"arrowshape\"\nmy $att_aliases;\n\nuse strict;\nuse constant isa_cell => 0;\n\nsub _init\n  {\n  # Generic init routine, to be overridden in subclasses.\n  my ($self,$args) = @_;\n  \n  $self->{name} = 'Node #' . $self->{id};\n  \n  $self->{att} = { };\n  $self->{class} = 'node';\t\t# default class\n\n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(label|name)\\z/)\n      {\n      require Carp;\n      Carp::confess (\"Invalid argument '$k' passed to Graph::Easy::Node->new()\");\n      }\n    $self->{$k} = $args->{$k} if $k eq 'name';\n    $self->{att}->{$k} = $args->{$k} if $k eq 'label';\n    }\n\n  # These are undef (to save memory) until needed: \n  #  $self->{children} = {};\n  #  $self->{dx} = 0;\t\t# relative to no other node\n  #  $self->{dy} = 0;\n  #  $self->{origin} = undef;\t# parent node (for relative placement)\n  #  $self->{group} = undef;\n  #  $self->{parent} = $graph or $group;\n  # Mark as not yet laid out: \n  #  $self->{x} = 0;\n  #  $self->{y} = 0;\n  \n  $self;\n  }\n\nmy $merged_borders = \n  {\n    'dotteddashed' => 'dot-dash',\n    'dasheddotted' => 'dot-dash',\n    'double-dashdouble' => 'double',\n    'doubledouble-dash' => 'double',\n    'doublesolid' => 'double',\n    'soliddouble' => 'double',\n    'dotteddot-dash' => 'dot-dash',\n    'dot-dashdotted' => 'dot-dash',\n  };\n\nsub _collapse_borders\n  {\n  # Given a right border from node one, and the left border of node two,\n  # return what border we need to draw on node two:\n  my ($self, $one, $two, $swapem) = @_;\n\n  ($one,$two) = ($two,$one) if $swapem;\n\n  $one = 'none' unless $one;\n  $two = 'none' unless $two;\n\n  # If the border of the left/top node is defined, we don't draw the\n  # border of the right/bottom node.\n  return 'none' if $one ne 'none' || $two ne 'none';\n\n  # otherwise, we draw simple the right border\n  $two;\n  }\n\nsub _merge_borders\n  {\n  my ($self, $one, $two) = @_;\n\n  $one = 'none' unless $one;\n  $two = 'none' unless $two;\n  \n  # \"nonenone\" => \"none\" or \"dotteddotted\" => \"dotted\"\n  return $one if $one eq $two;\n\n  # none + solid == solid + none == solid\n  return $one if $two eq 'none';\n  return $two if $one eq 'none';\n\n  for my $b (qw/broad wide bold double solid/)\n    {\n    # the stronger one overrides the weaker one\n    return $b if $one eq $b || $two eq $b;\n    }\n\n  my $both = $one . $two;\n  return $merged_borders->{$both} if exists $merged_borders->{$both};\n\n  # fallback\n  $two;\n  }\n\nsub _border_to_draw\n  {\n  # Return the border style we need to draw, taking the shape (none) into\n  # account\n  my ($self, $shape) = @_;\n\n  my $cache = $self->{cache};\n\n  return $cache->{border_style} if defined $cache->{border_style};\n\n  $shape = $self->{att}->{shape} unless defined $shape;\n  $shape = $self->attribute('shape') unless defined $shape;\n\n  $cache->{border_style} = $self->{att}->{borderstyle};\n  $cache->{border_style} = $self->attribute('borderstyle') unless defined $cache->{border_style};\n  $cache->{border_style} = 'none' if $shape =~ /^(none|invisible)\\z/;\n  $cache->{border_style};\n  }\n\nsub _border_styles\n  {\n  # Return the four border styles (right, bottom, left, top). This takes\n  # into account the neighbouring nodes and their borders, so that on\n  # ASCII output the borders can be properly collapsed.\n  my ($self, $border, $collapse) = @_;\n\n  my $cache = $self->{cache};\n\n  # already computed values?\n  return if defined $cache->{left_border};\n\n  $cache->{left_border} = $border; \n  $cache->{top_border} = $border;\n  $cache->{right_border} = $border; \n  $cache->{bottom_border} = $border;\n\n  return unless $collapse;\n\n#  print STDERR \" border_styles: $self->{name} border=$border\\n\";\n\n  my $EM = 14;\n  my $border_width = Graph::Easy::_border_width_in_pixels($self,$EM);\n\n  # convert overly broad borders to the correct style\n  $border = 'bold' if $border_width > 2;\n  $border = 'broad' if $border_width > $EM * 0.2 && $border_width < $EM * 0.75;\n  $border = 'wide' if $border_width >= $EM * 0.75;\n\n#  XXX TODO\n#  handle different colors, too:\n#  my $color = $self->color_attribute('bordercolor');\n\n  # Draw border on A (left), and C (left):\n  #\n  #    +---+\n  #  B | A | C \n  #    +---+\n\n  # Ditto, plus C's border:\n  #\n  #    +---+---+\n  #  B | A | C |\n  #    +---+---+\n  #\n\n  # If no left neighbour, draw border normally\n\n  # XXX TODO: ->{parent} ?\n  my $parent = $self->{parent} || $self->{graph};\n  return unless ref $parent;\n\n  my $cells = $parent->{cells};\n  return unless ref $cells;\n\n  my $x = $self->{x}; my $y = $self->{y};\n\n  $x -= 1; my $left = $cells->{\"$x,$y\"};\n  $x += 1; $y-= 1; my $top = $cells->{\"$x,$y\"};\n  $x += 1; $y += 1; my $right = $cells->{\"$x,$y\"};\n  $x -= 1; $y += 1; my $bottom = $cells->{\"$x,$y\"};\n\n  # where to store the result\n  my @where = ('left', 'top', 'right', 'bottom');\n  # need to swap arguments to _collapse_borders()?\n  my @swapem = (0, 0, 1, 1);\n \n  for my $other ($left, $top, $right, $bottom)\n    {\n    my $side = shift @where;\n    my $swap = shift @swapem;\n  \n    # see if we have a (visible) neighbour on the left side\n    if (ref($other) && \n      !$other->isa('Graph::Easy::Edge') &&\n      !$other->isa_cell() &&\n      !$other->isa('Graph::Easy::Node::Empty'))\n      {\n      $other = $other->{node} if ref($other->{node});\n\n#      print STDERR \"$side node $other \", $other->_border_to_draw(), \" vs. $border (swap $swap)\\n\";\n\n      if ($other->attribute('shape') ne 'invisible')\n        {\n        # yes, so take its border style\n        my $result;\n        if ($swap)\n\t  {\n          $result = $self->_merge_borders($other->_border_to_draw(), $border);\n\t  }\n        else\n\t  {\n\t  $result = $self->_collapse_borders($border, $other->_border_to_draw());\n\t  }\n        $cache->{$side . '_border'} = $result;\n\n#\tprint STDERR \"# result: $result\\n\";\n        }\n      }\n    }\n  }\n\nsub _correct_size\n  {\n  # Correct {w} and {h} after parsing. This is a fallback in case\n  # the output specific routines (_correct_site_ascii() etc) do\n  # not exist.\n  my $self = shift;\n\n  return if defined $self->{w};\n\n  my $shape = $self->attribute('shape');\n\n  if ($shape eq 'point')\n    {\n    $self->{w} = 5;\n    $self->{h} = 3;\n    my $style = $self->attribute('pointstyle');\n    my $shape = $self->attribute('pointshape');\n    if ($style eq 'invisible' || $shape eq 'invisible')\n      {\n      $self->{w} = 0; $self->{h} = 0; return; \n      }\n    }\n  elsif ($shape eq 'invisible')\n    {\n    $self->{w} = 3;\n    $self->{h} = 3;\n    }\n  else\n    {\n    my ($w,$h) = $self->dimensions();\n    $self->{h} = $h;\n    $self->{w} = $w + 2;\n    }\n\n  my $border = $self->_border_to_draw($shape);\n\n  $self->_border_styles($border, 'collapse');\n\n#  print STDERR \"# $self->{name} $self->{w} $self->{h} $shape\\n\";\n#  use Data::Dumper; print Dumper($self->{cache});\n\n  if ($shape !~ /^(invisible|point)/)\n    {\n    $self->{w} ++ if $self->{cache}->{right_border} ne 'none';\n    $self->{w} ++ if $self->{cache}->{left_border} ne 'none';\n    $self->{h} ++ if $self->{cache}->{top_border} ne 'none';\n    $self->{h} ++ if $self->{cache}->{bottom_border} ne 'none';\n\n    $self->{h} += 2 if $border eq 'none' && $shape !~ /^(invisible|point)/;\n    }\n\n  $self;\n  }\n\nsub _unplace\n  {\n  # free the cells this node occupies from $cells\n  my ($self,$cells) = @_;\n\n  my $x = $self->{x}; my $y = $self->{y};\n  delete $cells->{\"$x,$y\"};\n  $self->{x} = undef;\n  $self->{y} = undef;\n  $self->{cache} = {};\n\n  $self->_calc_size() unless defined $self->{cx};\n\n  if ($self->{cx} + $self->{cy} > 2)\t# one of them > 1!\n    {\n    for my $ax (1..$self->{cx})\n      {\n      my $sx = $x + $ax - 1;\n      for my $ay (1..$self->{cy})\n        {\n        my $sy = $y + $ay - 1;\n        # free cell\n        delete $cells->{\"$sx,$sy\"};\n        }\n      }\n    } # end handling multi-celled node\n\n  # unplace all edges leading to/from this node, too:\n  for my $e (values %{$self->{edges}})\n    {\n    $e->_unplace($cells);\n    }\n\n  $self;\n  }\n\nsub _mark_as_placed\n  {\n  # for creating an action on the action stack we also need to recursively\n  # mark all our children as already placed:\n  my ($self) = @_;\n\n  no warnings 'recursion';\n\n  delete $self->{_todo};\n\n  for my $child (values %{$self->{children}})\n    {\n    $child->_mark_as_placed();\n    }\n  $self;\n  }\n\nsub _place_children\n  {\n  # recursively place node and its children\n  my ($self, $x, $y, $parent) = @_;\n\n  no warnings 'recursion';\n\n  return 0 unless $self->_check_place($x,$y,$parent);\n\n  print STDERR \"# placing children of $self->{name} based on $x,$y\\n\" if $self->{debug};\n\n  for my $child (values %{$self->{children}})\n    {\n    # compute place of children (depending on whether we are multicelled or not)\n\n    my $dx = $child->{dx} > 0 ? $self->{cx} - 1 : 0;\n    my $dy = $child->{dy} > 0 ? $self->{cy} - 1 : 0;\n\n    my $rc = $child->_place_children($x + $dx + $child->{dx},$y + $dy + $child->{dy},$parent);\n    return $rc if $rc == 0;\n    }\n  $self->_place($x,$y,$parent);\n  }\n\nsub _place\n  {\n  # place this node at the requested position (without checking)\n  my ($self, $x, $y, $parent) = @_;\n\n  my $cells = $parent->{cells};\n  $self->{x} = $x;\n  $self->{y} = $y;\n  $cells->{\"$x,$y\"} = $self;\n\n  # store our position if we are the first node in that rank\n  my $r = abs($self->{rank} || 0);\n  my $what = $parent->{_rank_coord} || 'x';\t# 'x' or 'y'\n  $parent->{_rank_pos}->{ $r } = $self->{$what} \n    unless defined $parent->{_rank_pos}->{ $r };\n\n  # a multi-celled node will be stored like this:\n  # [ node   ] [ filler ]\n  # [ filler ] [ filler ]\n  # [ filler ] [ filler ] etc.\n\n#  $self->_calc_size() unless defined $self->{cx};\n\n  if ($self->{cx} + $self->{cy} > 2)    # one of them > 1!\n    {\n    for my $ax (1..$self->{cx})\n      {\n      my $sx = $x + $ax - 1;\n      for my $ay (1..$self->{cy})\n        {\n        next if $ax == 1 && $ay == 1;   # skip left-upper most cell\n        my $sy = $y + $ay - 1;\n\n        # We might even get away with creating only one filler cell\n        # although then its \"x\" and \"y\" values would be \"wrong\".\n\n        my $filler = \n\t  Graph::Easy::Node::Cell->new ( node => $self, x => $sx, y => $sy );\n        $cells->{\"$sx,$sy\"} = $filler;\n        }\n      }\n    } # end handling of multi-celled node\n\n  $self->_update_boundaries($parent);\n\n  1;\t\t\t\t\t# did place us\n  } \n\nsub _check_place\n  {\n  # chack that a node can be placed at $x,$y (w/o checking its children)\n  my ($self,$x,$y,$parent) = @_;\n\n  my $cells = $parent->{cells};\n\n  # node cannot be placed here\n  return 0 if exists $cells->{\"$x,$y\"};\n\n  $self->_calc_size() unless defined $self->{cx};\n\n  if ($self->{cx} + $self->{cy} > 2)\t# one of them > 1!\n    {\n    for my $ax (1..$self->{cx})\n      {\n      my $sx = $x + $ax - 1;\n      for my $ay (1..$self->{cy})\n        {\n        my $sy = $y + $ay - 1;\n        # node cannot be placed here\n        return 0 if exists $cells->{\"$sx,$sy\"};\n        }\n      }\n    }\n  1;\t\t\t\t\t# can place it here\n  }\n\nsub _do_place\n  {\n  # Tries to place the node at position ($x,$y) by checking that\n  # $cells->{\"$x,$y\"} is still free. If the node belongs to a cluster,\n  # checks all nodes of the cluster (and when all of them can be\n  # placed simultanously, does so).\n  # Returns true if the operation succeeded, otherwise false.\n  my ($self,$x,$y,$parent) = @_;\n\n  my $cells = $parent->{cells};\n\n  # inlined from _check() for speed reasons:\n\n  # node cannot be placed here\n  return 0 if exists $cells->{\"$x,$y\"};\n\n  $self->_calc_size() unless defined $self->{cx};\n\n  if ($self->{cx} + $self->{cy} > 2)\t# one of them > 1!\n    {\n    for my $ax (1..$self->{cx})\n      {\n      my $sx = $x + $ax - 1;\n      for my $ay (1..$self->{cy})\n        {\n        my $sy = $y + $ay - 1;\n        # node cannot be placed here\n        return 0 if exists $cells->{\"$sx,$sy\"};\n        }\n      }\n    }\n\n  my $children = 0;\n  $children = scalar keys %{$self->{children}} if $self->{children};\n\n  # relativ to another, or has children (relativ to us)\n  if (defined $self->{origin} || $children > 0)\n    {\n    # The coordinates of the origin node. Because 'dx' and 'dy' give\n    # our distance from the origin, we can compute the origin by doing\n    # \"$x - $dx\"\n\n    my $grandpa = $self; my $ox = 0; my $oy = 0;\n    # Find our grandparent (e.g. the root of origin chain), and the distance\n    # from $x,$y to it:\n    ($grandpa,$ox,$oy) = $self->find_grandparent() if $self->{origin};\n\n    # Traverse all children and check their places, place them if poss.\n    # This will also place ourselves, because we are a grandchild of $grandpa\n    return $grandpa->_place_children($x + $ox,$y + $oy,$parent);\n    }\n\n  # finally place this node at the requested position\n  $self->_place($x,$y,$parent);\n  }\n\n#############################################################################\n\nsub _wrapped_label\n  {\n  # returns the label wrapped automatically to use the least space\n  my ($self, $label, $align, $wrap) = @_;\n\n  return (@{$self->{cache}->{label}}) if $self->{cache}->{label};\n\n  # XXX TODO: handle \"paragraphs\"\n  $label =~ s/\\\\(n|r|l|c)/ /g;\t\t# replace line splits by spaces\n\n  # collapse multiple spaces\n  $label =~ s/\\s+/ /g;\n\n  # find out where to wrap\n  if ($wrap eq 'auto')\n    {\n    $wrap = int(sqrt(length($label)) * 1.4);\n    }\n  $wrap = 2 if $wrap < 2;\n\n  # run through the text and insert linebreaks\n  my $i = 0;\n  my $line_len = 0;\n  my $last_space = 0;\n  my $last_hyphen = 0;\n  my @lines;\n  while ($i < length($label))\n    {\n    my $c = substr($label,$i,1);\n    $last_space = $i if $c eq ' ';\n    $last_hyphen = $i if $c eq '-';\n    $line_len ++;\n    if ($line_len >= $wrap && ($last_space != 0 || $last_hyphen != 0))\n      {\n#      print STDERR \"# wrap at $line_len\\n\";\n\n      my $w = $last_space; my $replace = '';\n      if ($last_hyphen > $last_space)\n\t{\n        $w = $last_hyphen; $replace = '-';\n\t}\n\n#      print STDERR \"# wrap at $w\\n\";\n\n      # \"foo bar-baz\" => \"foo bar\" (lines[0]) and \"baz\" (label afterwards)\n\n#      print STDERR \"# first part '\". substr($label, 0, $w) . \"'\\n\";\n\n      push @lines, substr($label, 0, $w) . $replace;\n      substr($label, 0, $w+1) = '';\n      # reset counters\n      $line_len = 0;\n      $i = 0;\n      $last_space = 0;\n      $last_hyphen = 0;\n      next;\n      }\n    $i++;\n    }\n  # handle what is left over\n  push @lines, $label if $label ne '';\n\n  # generate the align array\n  my @aligns;\n  my $al = substr($align,0,1); \n  for my $i (0.. scalar @lines)\n    {\n    push @aligns, $al; \n    }\n  # cache the result to avoid costly recomputation\n  $self->{cache}->{label} = [ \\@lines, \\@aligns ];\n  (\\@lines, \\@aligns);\n  }\n\nsub _aligned_label\n  {\n  # returns the label lines and for each one the alignment l/r/c\n  my ($self, $align, $wrap) = @_;\n\n  $align = 'center' unless $align;\n  $wrap = $self->attribute('textwrap') unless defined $wrap;\n\n  my $name = $self->label();\n\n  return $self->_wrapped_label($name,$align,$wrap) unless $wrap eq 'none';\n\n  my (@lines,@aligns);\n  my $al = substr($align,0,1);\n  my $last_align = $al;\n\n  # split up each line from the front\n  while ($name ne '')\n    {\n    $name =~ s/^(.*?([^\\\\]|))(\\z|\\\\(n|r|l|c))//;\n    my $part = $1;\n    my $a = $3 || '\\n';\n\n    $part =~ s/\\\\\\|/\\|/g;\t\t# \\| => |\n    $part =~ s/\\\\\\\\/\\\\/g;\t\t# '\\\\' to '\\'\n    $part =~ s/^\\s+//;\t\t\t# remove spaces at front\n    $part =~ s/\\s+\\z//;\t\t\t# remove spaces at end\n    $a =~ s/\\\\//;\t\t\t# \\n => n\n    $a = $al if $a eq 'n';\n    \n    push @lines, $part;\n    push @aligns, $last_align;\n\n    $last_align = $a;\n    }\n\n  # XXX TODO: should remove empty lines at start/end?\n  (\\@lines, \\@aligns);\n  }\n\n#############################################################################\n# as_html conversion and helper functions related to that\n\nmy $remap = {\n  node => {\n    align => undef,\n    background => undef,\n    basename => undef,\n    border => undef,\n    borderstyle => undef,\n    borderwidth => undef,\n    bordercolor => undef,\n    columns => undef,\n    fill => 'background',\n    origin => undef,\n    offset => undef, \n    pointstyle => undef,\n    pointshape => undef,\n    rows => undef, \n    size => undef,\n    shape => undef,\n    },\n  edge => {\n    fill => undef,\n    border => undef,\n    },\n  all => {\n    align => 'text-align',\n    autolink => undef,\n    autotitle => undef,\n    comment => undef,\n    fontsize => undef,\n    font => 'font-family',\n    flow => undef,\n    format => undef,\n    label => undef,\n    link => undef,\n    linkbase => undef,\n    style => undef,\n    textstyle => undef,\n    title => undef,\n    textwrap => \\&Graph::Easy::_remap_text_wrap,\n    group => undef,\n    },\n  };\n\nsub _extra_params\n  {\n  # return text with a leading \" \", that will be appended to \"td\" when\n  # generating HTML\n  '';\n  }\n\n# XXX TODO: <span class=\"o\">?\nmy $pod = {\n  B => [ '<b>', '</b>' ],\n  O => [ '<span style=\"text-decoration: overline\">', '</span>' ],\n  S => [ '<span style=\"text-decoration: line-through\">', '</span>' ],\n  U => [ '<span style=\"text-decoration: underline\">', '</span>' ],\n  C => [ '<code>', '</code>' ],\n  I => [ '<i>', '</i>' ],\n  };\n\nsub _convert_pod\n  {\n  my ($self, $type, $text) = @_;\n\n  my $t = $pod->{$type} or return $text;\n\n  # \"<b>\" . \"text\" . \"</b>\"\n  $t->[0] . $text . $t->[1];\n  }\n\nsub _label_as_html\n  {\n  # Build the text from the lines, by inserting <b> for each break\n  # Also align each line, and if nec., convert B<bold> to <b>bold</b>.\n  my ($self) = @_;\n\n  my $align = $self->attribute('align');\n  my $text_wrap = $self->attribute('textwrap');\n\n  my ($lines,$aligns);\n  if ($text_wrap eq 'auto')\n    {\n    # set \"white-space: nowrap;\" in CSS and ignore linebreaks in label\n    $lines = [ $self->label() ];\n    $aligns = [ substr($align,0,1) ];\n    }\n  else\n    {\n    ($lines,$aligns) = $self->_aligned_label($align,$text_wrap);\n    }\n\n  # Since there is no \"float: center;\" in CSS, we must set the general\n  # text-align to center when we encounter any \\c and the default is\n  # left or right:\n\n  my $switch_to_center = 0;\n  if ($align ne 'center')\n    {\n    local $_;\n    $switch_to_center = grep /^c/, @$aligns;\n    }\n\n  $align = 'center' if $switch_to_center;\n  my $a = substr($align,0,1);\t\t\t# center => c\n\n  my $format = $self->attribute('format');\n\n  my $name = '';\n  my $i = 0;\n  while ($i < @$lines)\n    {\n    my $line = $lines->[$i];\n    my $al = $aligns->[$i];\n\n    # This code below will not handle B<bold\\n and bolder> due to the\n    # line break. Also, nesting does not work due to returned \"<\" and \">\".\n\n    if ($format eq 'pod')\n      {\n      # first inner-most, then go outer until there are none left\n      $line =~ s/([BOSUCI])<([^<>]+)>/ $self->_convert_pod($1,$2);/eg\n        while ($line =~ /[BOSUCI]<[^<>]+>/)\n      }\n    else\n      { \n      $line =~ s/&/&amp;/g;\t\t\t# quote &\n      $line =~ s/>/&gt;/g;\t\t\t# quote >\n      $line =~ s/</&lt;/g;\t\t\t# quote <\n      $line =~ s/\\\\\\\\/\\\\/g;\t\t\t# \"\\\\\" to \"\\\"\n      }\n\n    # insert a span to align the line unless the default already covers it\n    $line = '<span class=\"' . $al . '\">' . $line . '</span>'\n      if $a ne $al;\n    $name .= '<br>' . $line;\n\n    $i++;\t\t\t\t\t# next line\n    }\n  $name =~ s/^<br>//;\t\t\t\t# remove first <br> \n\n  ($name, $switch_to_center);\n  }\n\nsub quoted_comment\n  {\n  # Comment of this object, quoted suitable as to be embedded into HTML/SVG\n  my $self = shift;\n\n  my $cmt = $self->attribute('comment');\n  if ($cmt ne '')\n    {\n    $cmt =~ s/&/&amp;/g;\n    $cmt =~ s/</&lt;/g;\n    $cmt =~ s/>/&gt;/g;\n    $cmt = '<!-- ' . $cmt . \" -->\\n\";\n    }\n\n  $cmt;\n  }\n\nsub as_html\n  {\n  # return node as HTML\n  my ($self) = @_;\n\n  my $shape = 'rect';\n  $shape = $self->attribute('shape') unless $self->isa_cell();\n\n  if ($shape eq 'edge')\n    {\n    my $edge = Graph::Easy::Edge->new();\n    my $cell = Graph::Easy::Edge::Cell->new( edge => $edge );\n    $cell->{w} = $self->{w};\n    $cell->{h} = $self->{h};\n    $cell->{att}->{label} = $self->label();\n    $cell->{type} =\n     Graph::Easy::Edge::Cell->EDGE_HOR +\n     Graph::Easy::Edge::Cell->EDGE_LABEL_CELL;\n    return $cell->as_html();\n    }\n\n  my $extra = $self->_extra_params();\n  my $taga = \"td$extra\";\n  my $tagb = 'td';\n\n  my $id = $self->{graph}->{id};\n  my $a = $self->{att};\n  my $g = $self->{graph};\n\n  my $class = $self->class();\n\n  # how many rows/columns will this node span?\n  my $rs = ($self->{cy} || 1) * 4;\n  my $cs = ($self->{cx} || 1) * 4;\n\n  # shape: invisible; must result in an empty cell\n  if ($shape eq 'invisible' && $class ne 'node.anon')\n    {\n    return \" <$taga colspan=$cs rowspan=$rs style=\\\"border: none; background: inherit;\\\"></$tagb>\\n\";\n    }\n\n  my $c = $class; $c =~ s/\\./_/g;\t# node.city => node_city\n\n  my $html = \" <$taga colspan=$cs rowspan=$rs##class####style##\";\n   \n  my $title = $self->title();\n  $title =~ s/'/&#27;/g;\t\t\t# replace quotation marks\n\n  $html .= \" title='$title'\" if $title ne '' && $shape ne 'img';\t# add mouse-over title\n\n  my ($name, $switch_to_center);\n\n  if ($shape eq 'point')\n    {\n    require Graph::Easy::As_ascii;\t\t# for _u8 and point-style\n\n    local $self->{graph}->{_ascii_style} = 1;\t# use utf-8\n    $name = $self->_point_style( $self->attribute('pointshape'), $self->attribute('pointstyle') );\n    }\n  elsif ($shape eq 'img')\n    {\n    # take the label as the URL, but escape critical characters\n    $name = $self->label();\n    $name =~ s/\\s/\\+/g;\t\t\t\t# space\n    $name =~ s/'/%27/g;\t\t\t\t# replace quotation marks\n    $name =~ s/[\\x0d\\x0a]//g;\t\t\t# remove 0x0d0x0a and similiar\n    my $t = $title; $t = $name if $t eq ''; \n    $name = \"<img src='$name' alt='$t' title='$t' border='0' />\";\n    }\n  else\n    {\n    ($name,$switch_to_center) = $self->_label_as_html(); \n    }\n\n  # if the label is \"\", the link wouldn't be clickable\n  my $link = ''; $link = $self->link() unless $name eq '';\n\n  # the attributes in $out will be applied to either the TD, or the inner DIV,\n  # unless if we have a link, then most of them will be moved to the A HREF\n  my $att = $self->raw_attributes();\n  my $out = $self->{graph}->_remap_attributes( $self, $att, $remap, 'noquote', 'encode', 'remap_colors');\n\n  $out->{'text-align'} = 'center' if $switch_to_center;\n\n  # only for nodes, not for edges\n  if (!$self->isa('Graph::Easy::Edge'))\n    {\n    my $bc = $self->attribute('bordercolor');\n    my $bw = $self->attribute('borderwidth');\n    my $bs = $self->attribute('borderstyle');\n\n    $out->{border} = Graph::Easy::_border_attribute_as_html( $bs, $bw, $bc );\n\n    # we need to specify the border again for the inner div\n    if ($shape !~ /(rounded|ellipse|circle)/)\n      {\n      my $DEF = $self->default_attribute('border');\n\n      delete $out->{border} if $out->{border} =~ /^\\s*\\z/ || $out->{border} eq $DEF;\n      }\n\n    delete $out->{border} if $class eq 'node.anon' && $out->{border} && $out->{border} eq 'none';\n    }\n\n  # we compose the inner part as $inner_start . $label . $inner_end:\n  my $inner_start = '';\n  my $inner_end = '';\n\n  if ($shape =~ /(rounded|ellipse|circle)/)\n    {\n    # set the fill on the inner part, but the background and no border on the <td>:\n    my $inner_style = '';\n    my $fill = $self->color_attribute('fill');\n    $inner_style = 'background:' . $fill if $fill; \n    $inner_style .= ';border:' . $out->{border} if $out->{border};\n    $inner_style =~ s/;\\s?\\z$//;\t\t\t\t# remove '; ' at end\n\n    delete $out->{background};\n    delete $out->{border};\n\n    my $td_style = '';\n    $td_style = ' style=\"border: none;';\n    my $bg = $self->color_attribute('background');\n    $td_style .= \"background: $bg\\\"\";\n\n    $html =~ s/##style##/$td_style/;\n\n    $inner_end = '</span></div>';\n    my $c = substr($shape, 0, 1); $c = 'c' if $c eq 'e';\t# 'r' or 'c'\n\n    my ($w,$h) = $self->dimensions();\n\n    if ($shape eq 'circle')\n      {\n      # set both to the biggest size to enforce a circle shape\n      my $r = $w;\n      $r = $h if $h > $w;\n      $w = $r; $h = $r;\n      }\n\n    $out->{top} = ($h / 2 + 0.5) . 'em'; delete $out->{top} if $out->{top} eq '1.5em';\n    $h = ($h + 2) . 'em';\n    $w = ($w + 2) . 'em';\n\n    $inner_style .= \";width: $w; height: $h\";\n\n    $inner_style = \" style='$inner_style'\";\n    $inner_start = \"<div class='$c'$inner_style><span class='c'##style##>\";\n    }\n\n  if ($class =~ /^group/)\n    {\n    delete $out->{border};\n    delete $out->{background};\n    my $group_class = $class; $group_class =~ s/\\s.*//;\t\t# \"group gt\" => \"group\"\n    my @atr = qw/bordercolor borderwidth fill/;\n\n    # transform \"group_foo gr\" to \"group_foo\" if border eq 'none' (for anon groups)\n    my $border_style = $self->attribute('borderstyle');\n    $c =~ s/\\s+.*// if $border_style eq 'none';\n\n    # only need the color for the label cell\n    push @atr, 'color' if $self->{has_label};\n    $name = '&nbsp;' unless $self->{has_label};\n    for my $b (@atr)\n      {\n      my $def = $g->attribute($group_class,$b);\n      my $v = $self->attribute($b);\n\n      my $n = $b; $n = 'background' if $b eq 'fill';\n      $out->{$n} = $v unless $v eq '' || $v eq $def;\n      }\n    $name = '&nbsp;' unless $name ne '';\n    }\n\n  # \"shape: none;\" or point means no border, and background instead fill color\n  if ($shape =~ /^(point|none)\\z/)\n    {\n    $out->{background} = $self->color_attribute('background'); \n    $out->{border} = 'none';\n    }\n\n  my $style = '';\n  for my $atr (sort keys %$out)\n    {\n    if ($link ne '')\n      {\n      # put certain styles on the outer container, and not on the link\n      next if $atr =~ /^(background|border)\\z/;\n      }\n    $style .= \"$atr: $out->{$atr}; \";\n    }\n\n  # bold, italic, underline etc. (but not for empty cells)\n  $style .= $self->text_styles_as_css(1,1) if $name !~ /^(|&nbsp;)\\z/;\n\n  $style =~ s/;\\s?\\z$//;\t\t\t# remove '; ' at end\n  $style =~ s/\\s+/ /g;\t\t\t\t# '  ' => ' '\n  $style =~ s/^\\s+//;\t\t\t\t# remove ' ' at front\n  $style = \" style=\\\"$style\\\"\" if $style;\n\n  my $end_tag = \"</$tagb>\\n\";\n\n  if ($link ne '')\n    {\n    # encode critical entities\n    $link =~ s/\\s/\\+/g;\t\t\t\t# space\n    $link =~ s/'/%27/g;\t\t\t\t# replace quotation marks\n\n    my $outer_style = '';\n    # put certain styles like border and background on the table cell:\n    for my $s (qw/background border/)\n      {\n      $outer_style .= \"$s: $out->{$s};\" if exists $out->{$s};\n      }\n    $outer_style =~ s/;\\s?\\z$//;\t\t\t# remove '; ' at end\n    $outer_style = ' style=\"'.$outer_style.'\"' if $outer_style;\n\n    $inner_start =~ s/##style##/$outer_style/;\t# remove from inner_start\n\n    $html =~ s/##style##/$outer_style/;\t\t\t# or HTML, depending\n    $inner_start .= \"<a href='$link'##style##>\";\t# and put on link\n    $inner_end = '</a>'.$inner_end;\n    }\n\n  $c = \" class='$c'\" if $c ne '';\n  $html .= \">$inner_start$name$inner_end$end_tag\";\n  $html =~ s/##class##/$c/;\n  $html =~ s/##style##/$style/;\n\n  $self->quoted_comment() . $html;\n  }\n\nsub angle\n  {\n  # return the rotation of the node, dependend on the rotate attribute\n  # (and if relative, on the flow)\n  my $self = shift;\n\n  my $angle = $self->{att}->{rotate} || 0;\n\n  $angle = 180 if $angle =~ /^(south|down)\\z/;\n  $angle = 0 if $angle =~ /^(north|up)\\z/;\n  $angle = 270 if $angle eq 'west';\n  $angle = 90 if $angle eq 'east';\n\n  # convert relative angles\n  if ($angle =~ /^([+-]\\d+|left|right|back|front|forward)\\z/)\n    {\n    my $base_rot = $self->flow();\n    $angle = 0 if $angle =~ /^(front|forward)\\z/;\n    $angle = 180 if $angle eq 'back';\n    $angle = -90 if $angle eq 'left';\n    $angle = 90 if $angle eq 'right';\n    $angle = $base_rot + $angle + 0;\t# 0 points up, so front points right\n    $angle += 360 while $angle < 0;\n    }\n\n  $self->_croak(\"Illegal node angle $angle\") if $angle !~ /^\\d+\\z/;\n\n  $angle %= 360 if $angle > 359;\n\n  $angle;\n  }\n\n# for determining the absolute parent flow\nmy $p_flow =\n  {\n  'east' => 90,\n  'west' => 270,\n  'north' => 0,\n  'south' => 180,\n  'up' => 0,\n  'down' => 180,\n  'back' => 270,\n  'left' => 270,\n  'right' => 90,\n  'front' => 90,\n  'forward' => 90,\n  };\n\nsub _parent_flow_absolute\n  {\n  # make parent flow absolute\n  my ($self, $def)  = @_;\n\n  return '90' if ref($self) eq 'Graph::Easy';\n\n  my $flow = $self->parent()->raw_attribute('flow') || $def;\n\n  return unless defined $flow;\n\n  # in case of relative flow at parent, convert to absolute (right: east, left: west etc) \n  # so that \"graph { flow: left; }\" results in a westward flow\n  my $f = $p_flow->{$flow}; $f = $flow unless defined $f;\n  $f;\n  }\n\nsub flow\n  {\n  # Calculate the outgoing flow from the incoming flow and the flow at this\n  # node (either from edge(s) or general flow). Returns an absolute flow:\n  # See the online manual about flow for a reference and details.\n  my $self = shift;\n\n  no warnings 'recursion';\n\n  my $cache = $self->{cache};\n  return $cache->{flow} if exists $cache->{flow};\n\n  # detected cycle, so break it\n  return $cache->{flow} = $self->_parent_flow_absolute('90') if exists $self->{_flow};\n\n  local $self->{_flow} = undef;\t\t# endless loops really ruin our day\n\n  my $in;\n  my $flow = $self->{att}->{flow};\n\n  $flow = $self->_parent_flow_absolute() if !defined $flow || $flow eq 'inherit';\n\n  # if flow is absolute, return it early\n  return $cache->{flow} = $flow if defined $flow && $flow =~ /^(0|90|180|270)\\z/;\n  return $cache->{flow} = Graph::Easy->_direction_as_number($flow)\n    if defined $flow && $flow =~ /^(south|north|east|west|up|down)\\z/;\n  \n  # for relative flows, compute the incoming flow as base flow\n\n  # check all edges\n  for my $e (values %{$self->{edges}})\n    {\n    # only count incoming edges\n    next unless $e->{from} != $self && $e->{to} == $self;\n\n    # if incoming edge has flow, we take this\n    $in = $e->flow();\n    # take the first match\n    last if defined $in;\n    }\n\n  if (!defined $in)\n    {\n    # check all predecessors\n    for my $e (values %{$self->{edges}})\n      {\n      my $pre = $e->{from};\n      $pre = $e->{to} if $e->{bidirectional};\n      if ($pre != $self)\n        {\n        $in = $pre->flow();\n        # take the first match\n        last if defined $in;\n        }\n      }\n    }\n\n  $in = $self->_parent_flow_absolute('90') unless defined $in;\n\n  $flow = Graph::Easy->_direction_as_number($in) unless defined $flow;\n\n  $cache->{flow} = Graph::Easy->_flow_as_direction($in,$flow);\n  }\n\n#############################################################################\n# multi-celled nodes\n\nsub _calc_size\n  {\n  # Calculate the base size in cells from the attributes (before grow())\n  # Will return a hash that denotes in which direction the node should grow.\n  my $self = shift;\n\n  # If specified only one of \"rows\" or \"columns\", then grow the node\n  # only in the unspecified direction. Default is grow both.\n  my $grow_sides = { cx => 1, cy => 1 };\n\n  my $r = $self->{att}->{rows};\n  my $c = $self->{att}->{columns};\n  delete $grow_sides->{cy} if defined $r && !defined $c;\n  delete $grow_sides->{cx} if defined $c && !defined $r;\n\n  $r = $self->attribute('rows') unless defined $r;\n  $c = $self->attribute('columns') unless defined $c;\n\n  $self->{cy} = abs($r || 1);\n  $self->{cx} = abs($c || 1);\n\n  $grow_sides;\n  }\n\nsub _grow\n  {\n  # Grows the node until it has sufficient cells for all incoming/outgoing\n  # edges. The initial size will be based upon the attributes 'size' (or\n  # 'rows' or 'columns', depending on which is set)\n  my $self = shift;\n\n  # XXX TODO: grow the node based on its label dimensions\n#  my ($w,$h) = $self->dimensions();\n#\n#  my $cx = int(($w+2) / 5) || 1;\n#  my $cy = int(($h) / 3) || 1;\n#\n#  $self->{cx} = $cx if $cx > $self->{cx};\n#  $self->{cy} = $cy if $cy > $self->{cy};\n\n  # satisfy the edge start/end port constraints:\n\n  # We calculate a bitmap (vector) for each side, and mark each\n  # used port. Edges that have an unspecified port will just be\n  # counted.\n\n  # bitmap for each side:\n  my $vec = { north => '', south => '', east => '', west => '' };\n  # number of edges constrained to one side, but without port number\n  my $cnt = { north => 0, south => 0, east => 0, west => 0 };\n  # number of edges constrained to one side, with port number\n  my $portnr = { north => 0, south => 0, east => 0, west => 0 };\n  # max number of ports for each side\n  my $max = { north => 0, south => 0, east => 0, west => 0 };\n\n  my @idx = ( [ 'start', 'from' ], [ 'end', 'to' ] );\n  # number of slots we need to edges without port restrictions\n  my $unspecified = 0;\n\n  # count of outgoing edges\n  my $outgoing = 0;\n\n  for my $e (values %{$self->{edges}})\n    {\n    # count outgoing edges\n    $outgoing++ if $e->{from} == $self;\n\n    # do always both ends, because self-loops can start AND end at this node:\n    for my $end (0..1)\n      {\n      # if the edge starts/ends here\n      if ($e->{$idx[$end]->[1]} == $self)\t\t# from/to\n\t{\n\tmy ($side, $nr) = $e->port($idx[$end]->[0]);\t# start/end\n\n\tif (defined $side)\n\t  {\n\t  if (!defined $nr || $nr eq '')\n\t    {\n\t    # no port number specified, so just count\n\t    $cnt->{$side}++;\n\t    }\n\t  else\n\t    {\n\t    # mark the bit in the vector\n\t    # limit to four digits\n\t    $nr = 9999 if abs($nr) > 9999; \n\n\t    # if slot was not used yet, count it\n\t    $portnr->{$side} ++ if vec($vec->{$side}, $nr, 1) == 0x0;\n\n\t    # calculate max number of ports\n            $nr = abs($nr) - 1 if $nr < 0;\t\t# 3 => 3, -3 => 2\n            $nr++;\t\t\t\t\t# 3 => 4, -3 => 3\n\n\t    # mark as used\n\t    vec($vec->{$side}, $nr - 1, 1) = 0x01;\n\n\t    $max->{$side} = $nr if $nr > $max->{$side};\n\t    }\n          }\n        else\n          {\n          $unspecified ++;\n          }\n        } # end if port is constrained\n      } # end for start/end port\n    } # end for all edges\n\n  for my $e (values %{$self->{edges}})\n    {\n    # the loop above will count all self-loops twice when they are\n    # unrestricted. So subtract these again. Restricted self-loops\n    # might start at one port and end at another, and this case is\n    # covered correctly by the code above.\n    $unspecified -- if $e->{to} == $e->{from};\n    }\n\n  # Shortcut, if the number of edges is < 4 and we have not restrictions,\n  # then a 1x1 node suffices\n  if ($unspecified < 4 && ($unspecified == keys %{$self->{edges}}))\n    {\n    $self->_calc_size();\n    return $self;\n    }\n \n  my $need = {};\n  my $free = {};\n  for my $side (qw/north south east west/)\n    {\n    # maximum number of ports we need to reserve, minus edges constrained\n    # to unique ports: free ports on that side\n    $free->{$side} = $max->{$side} - $portnr->{$side};\n    $need->{$side} = $max->{$side};\n    if ($free->{$side} < 2 * $cnt->{$side})\n      {\n      $need->{$side} += 2 * $cnt->{$side} - $free->{$side} - 1;\n      }\n    }\n  # now $need contains for each side the absolute min. number of ports we need\n\n#  use Data::Dumper; \n#  print STDERR \"# port contraints for $self->{name}:\\n\";\n#  print STDERR \"# count: \", Dumper($cnt), \"# max: \", Dumper($max),\"\\n\";\n#  print STDERR \"# ports: \", Dumper($portnr),\"\\n\";\n#  print STDERR \"# need : \", Dumper($need),\"\\n\";\n#  print STDERR \"# free : \", Dumper($free),\"\\n\";\n \n  # calculate min. size in X and Y direction\n  my $min_x = $need->{north}; $min_x = $need->{south} if $need->{south} > $min_x;\n  my $min_y = $need->{west}; $min_y = $need->{east} if $need->{east} > $min_y;\n\n  my $grow_sides = $self->_calc_size();\n\n  # increase the size if the minimum required size is not met\n  $self->{cx} = $min_x if $min_x > $self->{cx};\n  $self->{cy} = $min_y if $min_y > $self->{cy};\n\n  my $flow = $self->flow();\n\n  # if this is a sink node, grow it more by ignoring free ports on the front side\n  my $front_side = 'east';\n  $front_side = 'west' if $flow == 270;\n  $front_side = 'south' if $flow == 180;\n  $front_side = 'north' if $flow == 0;\n\n  # now grow the node based on the general flow first VER, then HOR\n  my $grow = 0;\t\t\t\t\t# index into @grow_what\n  my @grow_what = sort keys %$grow_sides;\t# 'cx', 'cy' or 'cx' or 'cy'\n\n  if (keys %$grow_sides > 1)\n    {\n    # for left/right flow, swap the growing around\n    @grow_what = ( 'cy', 'cx' ) if $flow == 90 || $flow == 270;\n    }\n\n  # fake a non-sink node for nodes with an offset/children\n  $outgoing = 1 if ref($self->{origin}) || keys %{$self->{children}} > 0;\n\n  while ( 3 < 5 )\n    {\n    # calculate whether we already found a space for all edges\n    my $free_ports = 0;\n    for my $side (qw/north south/)\n      {\n      # if this is a sink node, grow it more by ignoring free ports on the front side\n      next if $outgoing == 0 && $front_side eq $side;\n      $free_ports += 1 + int(($self->{cx} - $cnt->{$side} - $portnr->{$side}) / 2);\n      }     \n    for my $side (qw/east west/)\n      {\n      # if this is a sink node, grow it more by ignoring free ports on the front side\n      next if $outgoing == 0 && $front_side eq $side;\n      $free_ports += 1 + int(($self->{cy} - $cnt->{$side} - $portnr->{$side}) / 2);\n      }\n    last if $free_ports >= $unspecified;\n\n    $self->{ $grow_what[$grow] } += 2;\n\n    $grow ++; $grow = 0 if $grow >= @grow_what;\n    }\n\n  $self;\n  }\n\nsub is_multicelled\n  {\n  # return true if node consist of more than one cell\n  my $self = shift;\n\n  $self->_calc_size() unless defined $self->{cx};\n\n  $self->{cx} + $self->{cy} <=> 2;\t# 1 + 1 == 2: no, cx + xy != 2: yes\n  }\n\nsub is_anon\n  {\n  # normal nodes are not anon nodes (but \"::Anon\" are)\n  0;\n  }\n\n#############################################################################\n# accessor methods\n\nsub _un_escape\n  {\n  # replace \\N, \\G, \\T, \\H and \\E (depending on type)\n  # if $label is false, also replace \\L with the label\n  my ($self, $txt, $do_label) = @_;\n \n  # for edges:\n  if (exists $self->{edge})\n    {\n    my $e = $self->{edge};\n    $txt =~ s/\\\\E/$e->{from}->{name}\\->$e->{to}->{name}/g;\n    $txt =~ s/\\\\T/$e->{from}->{name}/g;\n    $txt =~ s/\\\\H/$e->{to}->{name}/g;\n    # \\N for edges is the label of the edge\n    if ($txt =~ /\\\\N/)\n      {\n      my $l = $self->label();\n      $txt =~ s/\\\\N/$l/g;\n      }\n    }\n  else\n    {\n    # \\N for nodes\n    $txt =~ s/\\\\N/$self->{name}/g;\n    }\n  # \\L with the label\n  if ($txt =~ /\\\\L/ && $do_label)\n    {\n    my $l = $self->label();\n    $txt =~ s/\\\\L/$l/g;\n    }\n\n  # \\G for edges and nodes\n  if ($txt =~ /\\\\G/)\n    {\n    my $g = '';\n    # the graph itself\n    $g = $self->attribute('title') unless ref($self->{graph});\n    # any nodes/edges/groups in it\n    $g = $self->{graph}->label() if ref($self->{graph});\n    $txt =~ s/\\\\G/$g/g;\n    }\n  $txt;\n  }\n\nsub title\n  {\n  # Returns a title of the node (or '', if none was set), which can be\n  # used for mouse-over titles\n\n  my $self = shift;\n\n  my $title = $self->attribute('title');\n  if ($title eq '')\n    {\n    my $autotitle = $self->attribute('autotitle');\n    if (defined $autotitle)\n      {\n      $title = '';\t\t\t\t\t# default is none\n\n      if ($autotitle eq 'name')\t\t\t\t# use name\n\t{\n        $title = $self->{name};\n\t# edges do not have a name and fall back on their label\n        $title = $self->{att}->{label} unless defined $title;\n\t}\n\n      if ($autotitle eq 'label')\n        {\n        $title = $self->{name};\t\t\t\t# fallback to name\n        # defined to avoid overriding \"name\" with the non-existant label attribute\n\t# do not use label() here, but the \"raw\" label of the edge:\n        my $label = $self->label(); $title = $label if defined $label;\n        }\n\n      $title = $self->link() if $autotitle eq 'link';\n      }\n    $title = '' unless defined $title;\n    }\n\n  $title = $self->_un_escape($title, 1) if !$_[0] && $title =~ /\\\\[EGHNTL]/;\n\n  $title;\n  }\n\nsub background\n  {\n  # get the background for this group/edge cell, honouring group membership.\n  my $self = shift;\n\n  $self->color_attribute('background');\n  }\n\nsub label\n  {\n  my $self = shift;\n\n  # shortcut to speed it up a bit:\n  my $label = $self->{att}->{label};\n  $label = $self->attribute('label') unless defined $label;\n\n  # for autosplit nodes, use their auto-label first (unless already got \n  # a label from the class):\n  $label = $self->{autosplit_label} unless defined $label;\n  $label = $self->{name} unless defined $label;\n\n  return '' unless defined $label;\n\n  if ($label ne '')\n    {\n    my $len = $self->attribute('autolabel');\n    if ($len ne '')\n      {\n      # allow the old format (pre v0.49), too: \"name,12\" => 12\n      $len =~ s/^name\\s*,\\s*//;\t\t\t\n      # restrict to sane values\n      $len = abs($len || 0); $len = 99999 if $len > 99999;\n      if (length($label) > $len)\n        {\n        my $g = $self->{graph} || {};\n\tif ((($g->{_ascii_style}) || 0) == 0)\n\t  {\n\t  # ASCII output\n\t  $len = int($len / 2) - 3; $len = 0 if $len < 0;\n\t  $label = substr($label, 0, $len) . ' ... ' . substr($label, -$len, $len);\n\t  }\n\telse\n\t  {\n\t  $len = int($len / 2) - 2; $len = 0 if $len < 0;\n\t  $label = substr($label, 0, $len) . ' … ' . substr($label, -$len, $len);\n\t  }\n        }\n      }\n    }\n\n  $label = $self->_un_escape($label) if !$_[0] && $label =~ /\\\\[EGHNT]/;\n\n  $label;\n  }\n\nsub name\n  {\n  my $self = shift;\n\n  $self->{name};\n  }\n\nsub x\n  {\n  my $self = shift;\n\n  $self->{x};\n  }\n\nsub y\n  {\n  my $self = shift;\n\n  $self->{y};\n  }\n\nsub width\n  {\n  my $self = shift;\n\n  $self->{w};\n  }\n\nsub height\n  {\n  my $self = shift;\n\n  $self->{h};\n  }\n\nsub origin\n  {\n  # Returns node that this node is relative to or undef, if not.\n  my $self = shift;\n\n  $self->{origin};\n  }\n\nsub pos\n  {\n  my $self = shift;\n\n  ($self->{x} || 0, $self->{y} || 0);\n  }\n\nsub offset\n  {\n  my $self = shift;\n\n  ($self->{dx} || 0, $self->{dy} || 0);\n  }\n\nsub columns\n  {\n  my $self = shift;\n\n  $self->_calc_size() unless defined $self->{cx};\n\n  $self->{cx};\n  }\n\nsub rows\n  {\n  my $self = shift;\n\n  $self->_calc_size() unless defined $self->{cy};\n\n  $self->{cy};\n  }\n\nsub size\n  {\n  my $self = shift;\n\n  $self->_calc_size() unless defined $self->{cx};\n\n  ($self->{cx}, $self->{cy});\n  }\n\nsub shape\n  {\n  my $self = shift;\n\n  my $shape;\n  $shape = $self->{att}->{shape} if exists $self->{att}->{shape};\n  $shape = $self->attribute('shape') unless defined $shape;\n  $shape;\n  }\n\nsub dimensions\n  {\n  # Returns the minimum dimensions of the node/cell derived from the\n  # label or name, in characters.\n  my $self = shift;\n\n  my $align = $self->attribute('align');\n  my ($lines,$aligns) = $self->_aligned_label($align);\n\n  my $w = 0; my $h = scalar @$lines;\n  foreach my $line (@$lines)\n    {\n    $w = length($line) if length($line) > $w;\n    }\n  ($w,$h);\n  }\n\n#############################################################################\n# edges and connections\n\nsub edges_to\n  {\n  # Return all the edge objects that start at this vertex and go to $other.\n  my ($self, $other) = @_;\n\n  # no graph, no dice\n  return unless ref $self->{graph};\n\n  my @edges;\n  for my $edge (values %{$self->{edges}})\n    {\n    push @edges, $edge if $edge->{from} == $self && $edge->{to} == $other;\n    }\n  @edges;\n  }\n\nsub edges_at_port\n  {\n  # return all edges that share the same given port\n  my ($self, $attr, $side, $port) = @_;\n\n  # Must be \"start\" or \"end\"\n  return () unless $attr =~ /^(start|end)\\z/;\n\n  $self->_croak('side not defined') unless defined $side;\n  $self->_croak('port not defined') unless defined $port;\n\n  my @edges;\n  for my $e (values %{$self->{edges}})\n    {\n    # skip edges ending here if we look at start\n    next if $e->{to} eq $self && $attr eq 'start';\n    # skip edges starting here if we look at end\n    next if $e->{from} eq $self && $attr eq 'end';\n\n    my ($s_p,@ss_p) = $e->port($attr);\t\n    next unless defined $s_p;\n\n    # same side and same port number?\n    push @edges, $e \n      if $s_p eq $side && @ss_p == 1 && $ss_p[0] eq $port;\n    }\n\n  @edges;\n  }\n\nsub shared_edges\n  {\n  # return all edges that share one port with another edge\n  my ($self) = @_;\n\n  my @edges;\n  for my $e (values %{$self->{edges}})\n    {\n    my ($s_p,@ss_p) = $e->port('start');\n    push @edges, $e if defined $s_p;\n    my ($e_p,@ee_p) = $e->port('end');\n    push @edges, $e if defined $e_p;\n    }\n  @edges;\n  }\n\nsub nodes_sharing_start\n  {\n  # return all nodes that share an edge start with an\n  # edge from that node\n  my ($self, $side, @port) = @_;\n\n  my @edges = $self->edges_at_port('start',$side,@port);\n\n  my $nodes;\n  for my $e (@edges)\n    {\n    # ignore self-loops\n    my $to = $e->{to};\n    next if $to == $self;\n\n    # remove duplicates\n    $nodes->{ $to->{name} } = $to;\n    }\n\n  (values %$nodes);\n  }\n\nsub nodes_sharing_end\n  {\n  # return all nodes that share an edge end with an\n  # edge from that node\n  my ($self, $side, @port) = @_;\n\n  my @edges = $self->edges_at_port('end',$side,@port);\n\n  my $nodes;\n  for my $e (@edges)\n    {\n    # ignore self-loops\n    my $from = $e->{from};\n    next if $from == $self;\n\n    # remove duplicates\n    $nodes->{ $from->{name} } = $from;\n    }\n\n  (values %$nodes);\n  }\n\nsub incoming\n  {\n  # return all edges that end at this node\n  my $self = shift;\n\n  # no graph, no dice\n  return unless ref $self->{graph};\n\n  if (!wantarray)\n    {\n    my $count = 0;\n    for my $edge (values %{$self->{edges}})\n      {\n      $count++ if $edge->{to} == $self;\n      }\n    return $count;\n    }\n\n  my @edges;\n  for my $edge (values %{$self->{edges}})\n    {\n    push @edges, $edge if $edge->{to} == $self;\n    }\n  @edges;\n  }\n\nsub outgoing\n  {\n  # return all edges that start at this node\n  my $self = shift;\n\n  # no graph, no dice\n  return unless ref $self->{graph};\n\n  if (!wantarray)\n    {\n    my $count = 0;\n    for my $edge (values %{$self->{edges}})\n      {\n      $count++ if $edge->{from} == $self;\n      }\n    return $count;\n    }\n\n  my @edges;\n  for my $edge (values %{$self->{edges}})\n    {\n    push @edges, $edge if $edge->{from} == $self;\n    }\n  @edges;\n  }\n\nsub connections\n  {\n  # return number of connections (incoming+outgoing)\n  my $self = shift;\n\n  return 0 unless defined $self->{graph};\n\n  # We need to count the connections, because \"[A]->[A]\" creates\n  # two connections on \"A\", but only one edge! \n  my $con = 0;\n  for my $edge (values %{$self->{edges}})\n    {\n    $con ++ if $edge->{to} == $self;\n    $con ++ if $edge->{from} == $self;\n    }\n  $con;\n  }\n\nsub edges\n  {\n  # return all the edges\n  my $self = shift;\n\n  # no graph, no dice\n  return unless ref $self->{graph};\n\n  wantarray ? values %{$self->{edges}} : scalar keys %{$self->{edges}};\n  }\n\nsub sorted_successors\n  {\n  # return successors of the node sorted by their chain value\n  # (e.g. successors with more successors first) \n  my $self = shift;\n\n  my @suc = sort {\n       scalar $b->successors() <=> scalar $a->successors() ||\n       scalar $a->{name} cmp scalar $b->{name}\n       } $self->successors();\n  @suc;\n  }\n\nsub successors\n  {\n  # return all nodes (as objects) we are linked to\n  my $self = shift;\n\n  return () unless defined $self->{graph};\n\n  my %suc;\n  for my $edge (values %{$self->{edges}})\n    {\n    next unless $edge->{from} == $self;\n    $suc{$edge->{to}->{id}} = $edge->{to};\t# weed out doubles\n    }\n  values %suc;\n  }\n\nsub predecessors\n  {\n  # return all nodes (as objects) that link to us\n  my $self = shift;\n\n  return () unless defined $self->{graph};\n\n  my %pre;\n  for my $edge (values %{$self->{edges}})\n    {\n    next unless $edge->{to} == $self;\n    $pre{$edge->{from}->{id}} = $edge->{from};\t# weed out doubles\n    }\n  values %pre;\n  }\n\nsub has_predecessors\n  {\n  # return true if node has incoming edges (even from itself)\n  my $self = shift;\n\n  return undef unless defined $self->{graph};\n\n  for my $edge (values %{$self->{edges}})\n    {\n    return 1 if $edge->{to} == $self;\t\t# found one\n    }\n  0;\t\t\t\t\t\t# found none\n  }\n\nsub has_as_predecessor\n  {\n  # return true if other is a predecessor of node\n  my ($self,$other) = @_;\n\n  return () unless defined $self->{graph};\n\n  for my $edge (values %{$self->{edges}})\n    {\n    return 1 if \n\t$edge->{to} == $self && $edge->{from} == $other;\t# found one\n    }\n  0;\t\t\t\t\t\t# found none\n  }\n\nsub has_as_successor\n  {\n  # return true if other is a successor of node\n  my ($self,$other) = @_;\n\n  return () unless defined $self->{graph};\n\n  for my $edge (values %{$self->{edges}})\n    {\n    return 1 if\n\t$edge->{from} == $self && $edge->{to} == $other;\t# found one\n\n    }\n  0;\t\t\t\t\t\t# found none\n  }\n\n#############################################################################\n# relatively placed nodes\n\nsub relative_to\n  {\n  # Sets the new origin if passed a Graph::Easy::Node object.\n  my ($self,$parent,$dx,$dy) = @_;\n\n  if (!ref($parent) || !$parent->isa('Graph::Easy::Node'))\n    {\n    require Carp;\n    Carp::confess(\"Can't set origin to non-node object $parent\");\n    }\n\n  my $grandpa = $parent->find_grandparent();\n  if ($grandpa == $self)\n    {\n    require Carp;\n    Carp::confess( \"Detected loop in origin-chain:\"\n                  .\" tried to set origin of '$self->{name}' to my own grandchild $parent->{name}\");\n    }\n\n  # unregister us with our old parent\n  delete $self->{origin}->{children}->{$self->{id}} if defined $self->{origin};\n\n  $self->{origin} = $parent;\n  $self->{dx} = $dx if defined $dx;\n  $self->{dy} = $dy if defined $dy;\n  $self->{dx} = 0 unless defined $self->{dx};\n  $self->{dy} = 0 unless defined $self->{dy};\n\n  # register us as a new child\n  $parent->{children}->{$self->{id}} = $self;\n\n  $self;\n  }\n\nsub find_grandparent\n  {\n  # For a node that has no origin (is not relative to another), returns\n  # $self. For all others, follows the chain of origin back until we\n  # hit a node without a parent. This code assumes there are no loops,\n  # which origin() prevents from happening.\n  my $cur = shift;\n\n  if (wantarray)\n    {\n    my $ox = 0;\n    my $oy = 0;\n    while (defined($cur->{origin}))\n      {\n      $ox -= $cur->{dx};\n      $oy -= $cur->{dy};\n      $cur = $cur->{origin};\n      }\n    return ($cur,$ox,$oy);\n    }\n\n  while (defined($cur->{origin}))\n    {\n    $cur = $cur->{origin};\n    }\n  \n  $cur;\n  }\n\n#############################################################################\n# attributes\n\nsub del_attribute\n  {\n  my ($self, $name) = @_;\n\n  # font-size => fontsize\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  $self->{cache} = {};\n\n  my $a = $self->{att};\n  delete $a->{$name};\n  if ($name eq 'size')\n    {\n    delete $a->{rows};\n    delete $a->{columns};\n    }\n  if ($name eq 'border')\n    {\n    delete $a->{borderstyle};\n    delete $a->{borderwidth};\n    delete $a->{bordercolor};\n    }\n  $self;\n  }\n\nsub set_attribute\n  {\n  my ($self, $name, $v, $class) = @_;\n\n  $self->{cache} = {};\n\n  $name = 'undef' unless defined $name;\n  $v = 'undef' unless defined $v;\n\n  # font-size => fontsize\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  # edge.cities => edge\n  $class = $self->main_class() unless defined $class;\n\n  # remove quotation marks, but not for titles, labels etc\n  my $val = Graph::Easy->unquote_attribute($class,$name,$v);\n\n  my $g = $self->{graph};\n  \n  $g->{score} = undef if $g;\t# invalidate layout to force a new layout\n\n  my $strict = 0; $strict = $g->{strict} if $g;\n  if ($strict)\n    {\n    my ($rc, $newname, $v) = $g->validate_attribute($name,$val,$class);\n\n    return if defined $rc;\t\t# error?\n\n    $val = $v;\n    }\n\n  if ($name eq 'class')\n    {\n    $self->sub_class($val);\n    return $val;\n    }\n  elsif ($name eq 'group')\n    {\n    $self->add_to_group($val);\n    return $val;\n    }\n  elsif ($name eq 'border')\n    {\n    my $c = $self->{att};\n\n    ($c->{borderstyle}, $c->{borderwidth}, $c->{bordercolor}) =\n\t$g->split_border_attributes( $val );\n\n    return $val;\n    }\n\n  if ($name =~ /^(columns|rows|size)\\z/)\n    {\n    if ($name eq 'size')\n      {\n      $val =~ /^(\\d+)\\s*,\\s*(\\d+)\\z/;\n      my ($cx, $cy) = (abs(int($1)),abs(int($2)));\n      ($self->{att}->{columns}, $self->{att}->{rows}) = ($cx, $cy);\n      }\n    else\n      {\n      $self->{att}->{$name} = abs(int($val));\n      }\n    return $self;\n    }\n\n  if ($name =~ /^(origin|offset)\\z/)\n    {\n    # Only the first autosplit node get the offset/origin\n    return $self if exists $self->{autosplit} && !defined $self->{autosplit};\n\n    if ($name eq 'origin')\n      {\n      # if it doesn't exist, add it\n      my $org = $self->{graph}->add_node($val);\n      $self->relative_to($org);\n  \n      # set the attributes, too, so get_attribute('origin') works, too:\n      $self->{att}->{origin} = $org->{name};\n      }\n    else\n      {\n      # offset\n      # if it doesn't exist, add it\n      my ($x,$y) = split/\\s*,\\s*/, $val;\n      $x = int($x);\n      $y = int($y);\n      if ($x == 0 && $y == 0)\n        {\n        $g->error(\"Error in attribute: 'offset' is 0,0 in node $self->{name} with class '$class'\");\n        return;\n        }\n      $self->{dx} = $x;\n      $self->{dy} = $y;\n\n      # set the attributes, too, so get_attribute('origin') works, too:\n      $self->{att}->{offset} = \"$self->{dx},$self->{dy}\";\n      }\n    return $self;\n    }\n\n  $self->{att}->{$name} = $val;\n  }\n\nsub set_attributes\n  {\n  my ($self, $atr, $index) = @_;\n\n  foreach my $n (keys %$atr)\n    {\n    my $val = $atr->{$n};\n    $val = $val->[$index] if ref($val) eq 'ARRAY' && defined $index;\n\n    next if !defined $val || $val eq '';\n\n    $n eq 'class' ? $self->sub_class($val) : $self->set_attribute($n, $val);\n    }\n  $self;\n  }\n\nBEGIN\n  {\n  # some handy aliases\n  *text_styles_as_css = \\&Graph::Easy::text_styles_as_css;\n  *text_styles = \\&Graph::Easy::text_styles;\n  *_font_size_in_pixels = \\&Graph::Easy::_font_size_in_pixels;\n  *get_color_attribute = \\&color_attribute;\n  *link = \\&Graph::Easy::link;\n  *border_attribute = \\&Graph::Easy::border_attribute;\n  *get_attributes = \\&Graph::Easy::get_attributes;\n  *get_attribute = \\&Graph::Easy::attribute;\n  *raw_attribute = \\&Graph::Easy::raw_attribute;\n  *get_raw_attribute = \\&Graph::Easy::raw_attribute;\n  *raw_color_attribute = \\&Graph::Easy::raw_color_attribute;\n  *raw_attributes = \\&Graph::Easy::raw_attributes;\n  *raw_attributes = \\&Graph::Easy::raw_attributes;\n  *attribute = \\&Graph::Easy::attribute;\n  *color_attribute = \\&Graph::Easy::color_attribute;\n  *default_attribute = \\&Graph::Easy::default_attribute;\n  $att_aliases = Graph::Easy::_att_aliases();\n  }\n\n#############################################################################\n\nsub group\n  {\n  # return the group this object belongs to\n  my $self = shift;\n\n  $self->{group};\n  }\n\nsub add_to_group\n  {\n  my ($self,$group) = @_;\n \n  my $graph = $self->{graph};\t\t\t\t# shortcut\n\n  # delete from old group if nec.\n  $self->{group}->del_member($self) if ref $self->{group};\n\n  # if passed a group name, create or find group object\n  $group = $graph->add_group($group) if (!ref($group) && $graph);\n\n  # To make attribute('group') work:\n  $self->{att}->{group} = $group->{name};\n\n  $group->add_member($self);\n\n  $self;\n  }\n\nsub parent\n  {\n  # return parent object, either the group the node belongs to, or the graph\n  my $self = shift;\n\n  my $p = $self->{graph};\n\n  $p = $self->{group} if ref($self->{group});\n\n  $p;\n  }\n\nsub _update_boundaries\n  {\n  my ($self, $parent) = @_;\n\n  # XXX TODO: use current layout parent for recursive layouter:\n  $parent = $self->{graph};\n\n  # cache max boundaries for A* algorithmn:\n\n  my $x = $self->{x};\n  my $y = $self->{y};\n\n  # create the cache if it doesn't already exist\n  $parent->{cache} = {} unless ref($parent->{cache});\n\n  my $cache = $parent->{cache};\n  \n  $cache->{min_x} = $x if !defined $cache->{min_x} || $x < $cache->{min_x};\n  $cache->{min_y} = $y if !defined $cache->{min_y} || $y < $cache->{min_y};\n\n  $x = $x + ($self->{cx}||1) - 1;\n  $y = $y + ($self->{cy}||1) - 1;\n  $cache->{max_x} = $x if !defined $cache->{max_x} || $x > $cache->{max_x};\n  $cache->{max_y} = $y if !defined $cache->{max_y} || $y > $cache->{max_y};\n\n  if (($parent->{debug}||0) > 1)\n    {\n    my $n = $self->{name}; $n = $self unless defined $n;\n    print STDERR \"Update boundaries for $n (parent $parent) at $x, $y\\n\";\n  \n    print STDERR \"Boundaries are now: \" .\n\t\t \"$cache->{min_x},$cache->{min_y} => $cache->{max_x},$cache->{max_y}\\n\";\n    }\n\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Node - Represents a node in a Graph::Easy graph\n\n=head1 SYNOPSIS\n\n        use Graph::Easy::Node;\n\n\tmy $bonn = Graph::Easy::Node->new('Bonn');\n\n\t$bonn->set_attribute('border', 'solid 1px black');\n\n\tmy $berlin = Graph::Easy::Node->new( name => 'Berlin' );\n\n=head1 DESCRIPTION\n\nA C<Graph::Easy::Node> represents a node in a simple graph. Each\nnode has contents (a text, an image or another graph), and dimension plus\nan origin. The origin is typically determined by a graph layouter module\nlike L<Graph::Easy>.\n\n=head1 METHODS\n\nApart from the methods of the base class L<Graph::Easy::Base>, a\nC<Graph::Easy::Node> has the following methods:\n\n=head2 new()\n\n        my $node = Graph::Easy::Node->new( name => 'node name' );\n        my $node = Graph::Easy::Node->new( 'node name' );\n\nCreates a new node. If you want to add the node to a Graph::Easy object,\nthen please use the following to create the node object:\n\n\tmy $node = $graph->add_node('Node name');\n\nYou can then use C<< $node->set_attribute(); >>\nor C<< $node->set_attributes(); >> to set the new Node's attributes.\n\n=head2 as_ascii()\n\n\tmy $ascii = $node->as_ascii();\n\nReturn the node as a little box drawn in ASCII art as a string.\n\n=head2 as_txt()\n\n\tmy $txt = $node->as_txt();\n\nReturn the node in simple txt format, including attributes.\n\n=head2 as_svg()\n\n\tmy $svg = $node->as_svg();\n\nReturns the node as Scalable Vector Graphic. The actual code for\nthat routine is defined L<Graph::Easy::As_svg.pm>.\n\n=head2 as_graphviz()\n\nB<For internal use> mostly - use at your own risk.\n\n\tmy $txt = $node->as_graphviz();\n\nReturns the node as graphviz compatible text which can be fed\nto dot etc to create images.\n\nOne needs to load L<Graph::Easy::As_graphviz> first before this method\ncan be called.\n\n\n=head2 as_graphviz_txt()\n\nB<For internal use> mostly - use at your own risk.\n\n\tmy $txt = $node->as_graphviz_txt();\n\nReturn only the node itself (without attributes) as a graphviz representation.\n\nOne needs to load L<Graph::Easy::As_graphviz> first before this method\ncan be called.\n\n\n=head2 as_pure_txt()\n\n\tmy $txt = $node->as_pure_txt();\n\nReturn the node in simple txt format, without the attributes.\n\n=head2 text_styles_as_css()\n\n\tmy $styles = $graph->text_styles_as_css();\t# or $edge->...() etc.\n\nReturn the text styles as a chunk of CSS styling that can be embedded into\na C< style=\"\" > parameter.\n\n=head2 as_html()\n\n\tmy $html = $node->as_html();\n\nReturn the node as HTML code.\n\n=head2 attribute(), get_attribute()\n\n\t$node->attribute('border-style');\n\nReturns the respective attribute of the node or undef if it\nwas not set. If there is a default attribute for all nodes\nof the specific class the node is in, then this will be returned.\n\n=head2 get_attributes()\n\n        my $att = $object->get_attributes();\n\nReturn all effective attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance and default values.\n\nNote that this does not include custom attributes.\n\nSee also L<get_custom_attributes> and L<raw_attributes()>.\n\n=head2 get_custom_attributes()\n\n\tmy $att = $object->get_custom_attributes();\n\nReturn all the custom attributes on this object (graph/node/group/edge) as\nan anonymous hash ref.\n\n=head2 custom_attributes()\n\n    my $att = $object->custom_attributes();\n\nC<< custom_attributes() >> is an alias for L<< get_custom_attributes >>.\n\n=head2 raw_attributes()\n\n        my $att = $object->get_attributes();\n\nReturn all set attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance, but does not include\ndefault values for unset attributes.\n\nSee also L<get_attributes()>.\n\n=head2 default_attribute()\n\n\tmy $def = $graph->default_attribute($class, 'fill');\n\nReturns the default value for the given attribute B<in the class>\nof the object.\n\nThe default attribute is the value that will be used if\nthe attribute on the object itself, as well as the attribute\non the class is unset.\n\nTo find out what attribute is on the class, use the three-arg form\nof L<attribute> on the graph:\n\n\tmy $g = Graph::Easy->new();\n\tmy $node = $g->add_node('Berlin');\n\n\tprint $node->attribute('fill'), \"\\n\";\t\t# print \"white\"\n\tprint $node->default_attribute('fill'), \"\\n\";\t# print \"white\"\n\tprint $g->attribute('node','fill'), \"\\n\";\t# print \"white\"\n\n\t$g->set_attribute('node','fill','red');\t\t# class is \"red\"\n\t$node->set_attribute('fill','green');\t\t# this object is \"green\"\n\n\tprint $node->attribute('fill'), \"\\n\";\t\t# print \"green\"\n\tprint $node->default_attribute('fill'), \"\\n\";\t# print \"white\"\n\tprint $g->attribute('node','fill'), \"\\n\";\t# print \"red\"\n\nSee also L<raw_attribute()>.\n\n=head2 attributes_as_txt\n\n\tmy $txt = $node->attributes_as_txt();\n\nReturn the attributes of this node as text description. This is used\nby the C<< $graph->as_txt() >> code and there should be no reason\nto use this function on your own.\n\n=head2 set_attribute()\n\n\t$node->set_attribute('border-style', 'none');\n\nSets the specified attribute of this (and only this!) node to the\nspecified value.\n\n=head2 del_attribute()\n\n\t$node->del_attribute('border-style');\n\nDeletes the specified attribute of this (and only this!) node.\n\n=head2 set_attributes()\n\n\t$node->set_attributes( $hash );\n\nSets all attributes specified in C<$hash> as key => value pairs in this\n(and only this!) node.\n\n=head2 border_attribute()\n\n\tmy $border = $node->border_attribute();\n\nAssembles the C<border-width>, C<border-color> and C<border-style> attributes\ninto a string like \"solid 1px red\".\n\n=head2 color_attribute()\n\n\t# returns f.i. #ff0000\n\tmy $color = $node->get_color_attribute( 'fill' );\n\nJust like get_attribute(), but only for colors, and returns them as hex,\nusing the current colorscheme.\n\n=head2 get_color_attribute()\n\nIs an alias for L<color_attribute()>.\n\n=head2 raw_attribute(), get_raw_attribute()\n\n\tmy $value = $object->raw_attribute( $name );\n\nReturn the value of attribute C<$name> from the object it this\nmethod is called on (graph, node, edge, group etc.). If the\nattribute is not set on the object itself, returns undef.\n\nThis method respects inheritance, so an attribute value of 'inherit'\non an object will make the method return the inherited value:\n\n\tmy $g = Graph::Easy->new();\n\tmy $n = $g->add_node('A');\n\n\t$g->set_attribute('color','red');\n\n\tprint $n->raw_attribute('color');\t\t# undef\n\t$n->set_attribute('color','inherit');\n\tprint $n->raw_attribute('color');\t\t# 'red'\n\nSee also L<attribute()>.\n\n=head2 raw_color_attribute()\n\n\t# returns f.i. #ff0000\n\tmy $color = $graph->raw_color_attribute('color' );\n\nJust like L<raw_attribute()>, but only for colors, and returns them as hex,\nusing the current colorscheme.\n\nIf the attribute is not set on the object, returns C<undef>.\n\n=head2 text_styles()\n\n        my $styles = $node->text_styles();\n        if ($styles->{'italic'})\n          {\n          print 'is italic\\n';\n          }\n\nReturn a hash with the given text-style properties, aka 'underline', 'bold' etc.\n\n=head2 find_grandparent()\n\n\tmy $grandpa = $node->find_grandparent(); \n\nFor a node that has no origin (is not relative to another), returns\nC<$node>. For all others, follows the chain of origin back until\na node without a parent is found and returns this node.\nThis code assumes there are no loops, which C<origin()> prevents from\nhappening.\n\n=head2 name()\n\n\tmy $name = $node->name();\n\nReturn the name of the node. In a graph, each node has a unique name,\nwhich, unless a node label is set, will be displayed when rendering the\ngraph.\n\n=head2 label()\n\n\tmy $label = $node->label();\n\tmy $label = $node->label(1);\t\t# raw\n\nReturn the label of the node. If no label was set, returns the C<name>\nof the node.\n\nIf the optional parameter is true, then the label will returned 'raw',\nthat is any potential escape of the form C<\\N>, C<\\E>, C<\\G>, C<\\T>\nor C<\\H> will not be left alone and not be replaced.\n\n=head2 background()\n\n\tmy $bg = $node->background();\n\nReturns the background color. This method honours group membership and\ninheritance.\n\n=head2 quoted_comment()\n\n\tmy $cmt = $node->comment();\n\nComment of this object, quoted suitable as to be embedded into HTML/SVG.\nReturns the empty string if this object doesn't have a comment set.\n\n=head2 title()\n\n\tmy $title = $node->title();\n\tmy $title = $node->title(1);\t\t# raw\n\nReturns a potential title that can be used for mouse-over effects.\nIf no title was set (or autogenerated), will return an empty string.\n\nIf the optional parameter is true, then the title will returned 'raw',\nthat is any potential escape of the form C<\\N>, C<\\E>, C<\\G>, C<\\T>\nor C<\\H> will be left alone and not be replaced.\n\n=head2 link()\n\n\tmy $link = $node->link();\n\tmy $link = $node->link(1);\t\t# raw\n\nReturns the URL, build from the C<linkbase> and C<link> (or C<autolink>)\nattributes.  If the node has no link associated with it, return an empty\nstring.\n\nIf the optional parameter is true, then the link will returned 'raw',\nthat is any potential escape of the form C<\\N>, C<\\E>, C<\\G>, C<\\T>\nor C<\\H> will not be left alone and not be replaced.\n\n=head2 dimensions()\n\n\tmy ($w,$h) = $node->dimensions();\n\nReturns the dimensions of the node/cell derived from the label (or name) in characters.\nAssumes the label/name has literal '\\n' replaced by \"\\n\".\n\n=head2 size()\n\n\tmy ($cx,$cy) = $node->size();\n\nReturns the node size in cells.\n\n=head2 contents()\n\n\tmy $contents = $node->contents();\n\nFor nested nodes, returns the contents of the node.\n\n=head2 width()\n\n\tmy $width = $node->width();\n\nReturns the width of the node. This is a unitless number.\n\n=head2 height()\n\n\tmy $height = $node->height();\n\nReturns the height of the node. This is a unitless number.\n\n=head2 columns()\n\n\tmy $cols = $node->columns();\n\nReturns the number of columns (in cells) that this node occupies.\n\n=head2 rows()\n\n\tmy $cols = $node->rows();\n\nReturns the number of rows (in cells) that this node occupies.\n\n=head2 is_multicelled()\n\n\tif ($node->is_multicelled())\n\t  {\n\t  ...\n\t  }\n\nReturns true if the node consists of more than one cell. See als\nL<rows()> and L<cols()>.\n\n=head2 is_anon()\n\n\tif ($node->is_anon())\n\t  {\n\t  ...\n\t  }\n\nReturns true if the node is an anonymous node. False for C<Graph::Easy::Node>\nobjects, and true for C<Graph::Easy::Node::Anon>.\n\n=head2 pos()\n\n\tmy ($x,$y) = $node->pos();\n\nReturns the position of the node. Initially, this is undef, and will be\nset from L<Graph::Easy::layout()>. Only valid during the layout phase.\n\n=head2 offset()\n\n\tmy ($dx,$dy) = $node->offset();\n\nReturns the position of the node relativ to the origin. Returns C<(0,0)> if\nthe origin node was not sset.\n\n=head2 x()\n\n\tmy $x = $node->x();\n\nReturns the X position of the node. Initially, this is undef, and will be\nset from L<Graph::Easy::layout()>. Only valid during the layout phase.\n\n=head2 y()\n\n\tmy $y = $node->y();\n\nReturns the Y position of the node. Initially, this is undef, and will be\nset from L<Graph::Easy::layout()>. Only valid during the layout phase.\n\n=head2 id()\n\n\tmy $id = $node->id();\n\nReturns the node's unique, internal ID number.\n\n=head2 connections()\n\n\tmy $cnt = $node->connections();\n\nReturns the count of incoming and outgoing connections of this node.\nSelf-loops count as two connections, so in the following example, node C<N>\nhas B<four> connections, but only B<three> edges:\n\n\t            +--+\n\t            v  |\n\t+---+     +------+     +---+\n\t| 1 | --> |  N   | --> | 2 |\n\t+---+     +------+     +---+\n\nSee also L<edges()>.\n\n=head2 edges()\n\n\tmy $edges = $node->edges();\n\nReturns a list of all the edges (as L<Graph::Easy::Edge> objects) at this node,\nin no particular order.\n\n=head2 predecessors()\n\n\tmy @pre = $node->predecessors();\n\nReturns all nodes (as objects) that link to us.\n\n=head2 has_predecessors()\n\n\tif ($node->has_predecessors())\n\t  {\n\t  ...\n\t  }\n\nReturns true if the node has one or more predecessors. Will return true for\nnodes with selfloops.\n\n=head2 successors()\n\n\tmy @suc = $node->successors();\n\nReturns all nodes (as objects) that we are linking to.\n\n=head2 sorted_successors()\n\n\tmy @suc = $node->sorted_successors();\n\nReturn successors of the node sorted by their chain value\n(e.g. successors with more successors first). \n\n=head2 has_as_successor()\n\n\tif ($node->has_as_successor($other))\n\t  {\n\t  ...\n\t  }\n\nReturns true if C<$other> ( a node or group) is a successor of node, that is if\nthere is an edge leading from node to C<$other>.\n\n=head2 has_as_predecessor()\n\n\tif ($node->has_as_predecessor($other))\n\t  {\n\t  ...\n\t  }\n\nReturns true if the node has C<$other> (a group or node) as predecessor, that\nis if there is an edge leading from C<$other> to node.\n\n=head2 edges_to()\n\n\tmy @edges = $node->edges_to($other_node);\n\nReturns all the edges (as objects) that start at C<< $node >> and go to\nC<< $other_node >>.\n\n=head2 shared_edges()\n\n\tmy @edges = $node->shared_edges();\n\nReturn a list of all edges starting/ending at this node, that share a port\nwith another edge.\n\n=head2 nodes_sharing_start()\n\n\tmy @nodes = $node->nodes_sharing_start($side, $port);\n\nReturn a list of unique nodes that share a start point with an edge\nfrom this node, on the specified side (absolute) and port number.\n\n=head2 nodes_sharing_end()\n\n\tmy @nodes = $node->nodes_sharing_end($side, $port);\n\nReturn a list of unique nodes that share an end point with an edge\nfrom this node, on the specified side (absolute) and port number.\n\n=head2 edges_at_port()\n\n\tmy @edges = $node->edges_to('start', 'south', '0');\n\nReturns all the edge objects that share the same C<start> or C<end>\nport at the specified side and port number. The side must be\none of C<south>, C<north>, C<west> or C<east>. The port number\nmust be positive.\n\n=head2 incoming()\n\n\tmy @edges = $node->incoming();\n\nReturn all edges that end at this node.\n\n=head2 outgoing()\n\n\tmy @edges = $node->outgoing();\n\nReturn all edges that start at this node.\n\n=head2 add_to_group()\n\n\t$node->add_to_group( $group );\n\nPut the node into this group.\n\n=head2 group()\n\n\tmy $group = $node->group();\n\nReturn the group this node belongs to, or undef.\n\n=head2 parent()\n\n\tmy $parent = $node->parent();\n\nReturns the parent object of the node, which is either the group the node belongs\nto, or the graph.\n\n=head2 origin()\n\n\tmy $origin_node = $node->origin();\n\nReturns the node this node is relativ to, or undef otherwise.\n\n=head2 relative_to()\n\n\t$node->relative_to($parent, $dx, $dy);\n\nSets itself relativ to C<$parent> with the offset C<$dx,$dy>.\n\n=head2 shape()\n\n\tmy $shape = $node->shape();\n\nReturns the shape of the node as string, defaulting to 'rect'. \n\n=head2 angle()\n\n\tmy $angle = $self->rotation();\n\nReturn the node's rotation, based on the C<rotate> attribute, and\nin case this is relative, on the node's flow.\n\n=head2 flow()\n\n\tmy $flow = $node->flow();\n\nReturns the outgoing flow for this node as absolute direction in degrees.\n\nThe value is computed from the incoming flow (or the general flow as\ndefault) and the flow attribute of this node.\n\n=head2 _extra_params()\n\n\tmy $extra_params = $node->_extra_params();\n\nThe return value of that method is added as extra params to the\nHTML tag for a node when as_html() is called. Returns the empty\nstring by default, and can be overridden in subclasses. See also\nL<use_class()>.\n\nOverridden method should return a text with a leading space, or the\nempty string.\n\nExample:\n\n\tpackage Graph::Easy::MyNode;\n\tuse base qw/Graph::Easy::Node/;\n\n\tsub _extra_params\n\t  {\n\t  my $self = shift;\n\n\t  ' ' . 'onmouseover=\"alert(\\'' . $self->name() . '\\');\"'; \n\t  }\n\n\t1;\n\n=head1 EXPORT\n\nNone by default.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>.\n\nSee the LICENSE file for more details.\n\n=cut\n",
  "Graph/Easy/Parser/Graphviz.pm": "#############################################################################\n# Parse graphviz/dot text into a Graph::Easy object\n#\n#############################################################################\n\npackage Graph::Easy::Parser::Graphviz;\n\n$VERSION = '0.17';\nuse Graph::Easy::Parser;\n@ISA = qw/Graph::Easy::Parser/;\n\nuse strict;\nuse utf8;\nuse constant NO_MULTIPLES => 1;\n\nsub _init\n  {\n  my $self = shift;\n\n  $self->SUPER::_init(@_);\n  $self->{attr_sep} = '=';\n  # remove \" <p1> \" from autosplit (shape=record) labels\n  $self->{_qr_part_clean} = qr/\\s*<([^>]*)>/;\n\n  $self;\n  }\n\nsub reset\n  {\n  my $self = shift;\n\n  $self->SUPER::reset(@_);\n\n  # set some default attributes on the graph object, because graphviz has\n  # different defaults as Graph::Easy\n  my $g = $self->{_graph};\n\n  $g->set_attribute('colorscheme','x11');\n  $g->set_attribute('flow','south');\n  $g->set_attribute('edge','arrow-style', 'filled');\n  $g->set_attribute('group','align', 'center');\n  $g->set_attribute('group','fill', 'inherit');\n\n  $self->{scope_stack} = [];\n\n  # allow some temp. values during parsing\n  $g->_allow_special_attributes(\n    {\n    node => {\n      shape => [\n       \"\",\n        [ qw/ circle diamond edge ellipse hexagon house invisible\n\t\tinvhouse invtrapezium invtriangle octagon parallelogram pentagon\n\t\tpoint triangle trapezium septagon rect rounded none img record/ ],\n       '',\n       '',\n       undef,\n      ],\n    },\n    } );\n\n  $g->{_warn_on_unknown_attributes} = 1;\n\n  $self;\n  }\n\n# map \"&tilde;\" to \"~\" \nmy %entities = (\n  'amp'    => '&',\n  'quot'   => '\"',\n  'lt'     => '<',\n  'gt'     => '>',\n  'nbsp'   => ' ',\t\t# this is a non-break-space between '' here!\n  'iexcl'  => '¡',\n  'cent'   => '¢',\n  'pound'  => '£',\n  'curren' => '¤',\n  'yen'    => '¥',\n  'brvbar' => '¦',\n  'sect'   => '§',\n  'uml'    => '¨',\n  'copy'   => '©',\n  'ordf'   => 'ª',\n  'ordf'   => 'ª',\n  'laquo'  => '«',\n  'not'    => '¬',\n  'shy'    => \"\\x{00AD}\",\t\t# soft-hyphen\n  'reg'    => '®',\n  'macr'   => '¯',\n  'deg'    => '°',\n  'plusmn' => '±',\n  'sup2'   => '²',\n  'sup3'   => '³',\n  'acute'  => '´',\n  'micro'  => 'µ',\n  'para'   => '¶',\n  'midot'  => '·',\n  'cedil'  => '¸',\n  'sup1'   => '¹',\n  'ordm'   => 'º',\n  'raquo'  => '»',\n  'frac14' => '¼',\n  'frac12' => '½',\n  'frac34' => '¾',\n  'iquest' => '¿',\n  'Agrave' => 'À',\n  'Aacute' => 'Á',\n  'Acirc'  => 'Â',\n  'Atilde' => 'Ã',\n  'Auml'   => 'Ä',\n  'Aring'  => 'Å',\n  'Aelig'  => 'Æ',\n  'Ccedil' => 'Ç',\n  'Egrave' => 'È',\n  'Eacute' => 'É',\n  'Ecirc'  => 'Ê',\n  'Euml'   => 'Ë',\n  'Igrave' => 'Ì',\n  'Iacute' => 'Í',\n  'Icirc'  => 'Î',\n  'Iuml'   => 'Ï',\n  'ETH'    => 'Ð',\n  'Ntilde' => 'Ñ',\n  'Ograve' => 'Ò',\n  'Oacute' => 'Ó',\n  'Ocirc'  => 'Ô',\n  'Otilde' => 'Õ',\n  'Ouml'   => 'Ö',\n  'times'  => '×',\n  'Oslash' => 'Ø',\n  'Ugrave' => 'Ù',\n  'Uacute' => 'Ù',\n  'Ucirc'  => 'Û',\n  'Uuml'   => 'Ü',\n  'Yacute' => 'Ý',\n  'THORN'  => 'Þ',\n  'szlig'  => 'ß',\n  'agrave' => 'à',\n  'aacute' => 'á',\n  'acirc'  => 'â',\n  'atilde' => 'ã',\n  'auml'   => 'ä',\n  'aring'  => 'å',\n  'aelig'  => 'æ',\n  'ccedil' => 'ç',\n  'egrave' => 'è',\n  'eacute' => 'é',\n  'ecirc'  => 'ê',\n  'euml'   => 'ë',\n  'igrave' => 'ì',\n  'iacute' => 'í',\n  'icirc'  => 'î',\n  'iuml'   => 'ï',\n  'eth'    => 'ð',\n  'ntilde' => 'ñ',\n  'ograve' => 'ò',\n  'oacute' => 'ó',\n  'ocirc'  => 'ô',\n  'otilde' => 'õ',\n  'ouml'   => 'ö',\n  'divide' => '÷',\n  'oslash' => 'ø',\n  'ugrave' => 'ù',\n  'uacute' => 'ú',\n  'ucirc'  => 'û',\n  'uuml'   => 'ü',\n  'yacute' => 'ý',\n  'thorn'  => 'þ',\n  'yuml'   => 'ÿ',\n  'Oelig'  => 'Œ',\n  'oelig'  => 'œ',\n  'Scaron' => 'Š',\n  'scaron' => 'š',\n  'Yuml'   => 'Ÿ',\n  'fnof'   => 'ƒ',\n  'circ'   => '^',\n  'tilde'  => '~',\n  'Alpha'  => 'Α',\n  'Beta'   => 'Β',\n  'Gamma'  => 'Γ',\n  'Delta'  => 'Δ',\n  'Epsilon'=> 'Ε',\n  'Zeta'   => 'Ζ',\n  'Eta'    => 'Η',\n  'Theta'  => 'Θ',\n  'Iota'   => 'Ι',\n  'Kappa'  => 'Κ',\n  'Lambda' => 'Λ',\n  'Mu'     => 'Μ',\n  'Nu'     => 'Ν',\n  'Xi'     => 'Ξ',\n  'Omicron'=> 'Ο',\n  'Pi'     => 'Π',\n  'Rho'    => 'Ρ',\n  'Sigma'  => 'Σ',\n  'Tau'    => 'Τ',\n  'Upsilon'=> 'Υ',\n  'Phi'    => 'Φ',\n  'Chi'    => 'Χ',\n  'Psi'    => 'Ψ',\n  'Omega'  => 'Ω',\n  'alpha'  => 'α',\n  'beta'   => 'β',\n  'gamma'  => 'γ',\n  'delta'  => 'δ',\n  'epsilon'=> 'ε',\n  'zeta'   => 'ζ',\n  'eta'    => 'η',\n  'theta'  => 'θ',\n  'iota'   => 'ι',\n  'kappa'  => 'κ',\n  'lambda' => 'λ',\n  'mu'     => 'μ',\n  'nu'     => 'ν',\n  'xi'     => 'ξ',\n  'omicron'=> 'ο',\n  'pi'     => 'π',\n  'rho'    => 'ρ',\n  'sigma'  => 'σ',\n  'tau'    => 'τ',\n  'upsilon'=> 'υ',\n  'phi'    => 'φ',\n  'chi'    => 'χ',\n  'psi'    => 'ψ',\n  'omega'  => 'ω',\n  'thetasym'=>'ϑ',\n  'upsih'  => 'ϒ',\n  'piv'    => 'ϖ',\n  'ensp'   => \"\\x{2003}\",\t# normal wide space\n  'emsp'   => \"\\x{2004}\",\t# wide space\n  'thinsp' => \"\\x{2009}\",\t# very thin space\n  'zwnj'   => \"\\x{200c}\",\t# zero-width-non-joiner\n  'zwj'    => \"\\x{200d}\",\t# zero-width-joiner\n  'lrm'    => \"\\x{200e}\",\t# left-to-right\n  'rlm'    => \"\\x{200f}\",\t# right-to-left\n  'ndash'  => '–',\n  'mdash'  => '—',\n  'lsquo'  => '‘',\n  'rsquo'  => '’',\n  'sbquo'  => '‚',\n  'ldquo'  => '“',\n  'rdquo'  => '”',\n  'bdquo'  => '„',\n  'dagger' => '†',\n  'Dagger' => '‡',\n  'bull'   => '•',\n  'hellip' => '…',\n  'permil' => '‰',\n  'prime'  => '′',\n  'Prime'  => '′',\n  'lsaquo' => '‹',\n  'rsaquo' => '›',\n  'oline'  => '‾',\n  'frasl'  => '⁄',\n  'euro'   => '€',\n  'image'  => 'ℑ',\n  'weierp' => '℘',\n  'real'   => 'ℜ',\n  'trade'  => '™',\n  'alefsym'=> 'ℵ',\n  'larr'   => '←',\n  'uarr'   => '↑',\n  'rarr'   => '→',\n  'darr'   => '↓',\n  'harr'   => '↔',\n  'crarr'  => '↵',\n  'lArr'   => '⇐',\n  'uArr'   => '⇑',\n  'rArr'   => '⇒',\n  'dArr'   => '⇓',\n  'hArr'   => '⇔',\n  'forall' => '∀',\n  'part'   => '∂',\n  'exist'  => '∃',\n  'empty'  => '∅',\n  'nabla'  => '∇',\n  'isin'   => '∈',\n  'notin'  => '∉',\n  'ni'     => '∋',\n  'prod'   => '∏',\n  'sum'    => '∑',\n  'minus'  => '−',\n  'lowast' => '∗',\n  'radic'  => '√',\n  'prop'   => '∝',\n  'infin'  => '∞',\n  'ang'    => '∠',\n  'and'    => '∧',\n  'or'     => '∨',\n  'cap'    => '∩',\n  'cup'    => '∪',\n  'int'    => '∫',\n  'there4' => '∴',\n  'sim'    => '∼',\n  'cong'   => '≅',\n  'asymp'  => '≃',\n  'ne'     => '≠',\n  'eq'     => '=',\n  'le'     => '≤',\n  'ge'     => '≥',\n  'sub'    => '⊂',\n  'sup'    => '⊃',\n  'nsub'   => '⊄',\n  'nsup'   => '⊅',\n  'sube'   => '⊆',\n  'supe'   => '⊇',\n  'oplus'  => '⊕',\n  'otimes' => '⊗',\n  'perp'   => '⊥',\n  'sdot'   => '⋅',\n  'lceil'  => '⌈',\n  'rceil'  => '⌉',\n  'lfloor' => '⌊',\n  'rfloor' => '⌋',\n  'lang'   => '〈',\n  'rang'   => '〉',\n  'roz'    => '◊',\n  'spades' => '♠',\n  'clubs'  => '♣',\n  'diamonds'=>'♦',\n  'hearts' => '♥',\n  );\n\nsub _unquote_attribute\n  {\n  my ($self,$name,$val) = @_;\n\n  my $html_like = 0;\n  if ($name eq 'label')\n    {\n    $html_like = 1 if $val =~ /^\\s*<\\s*</;\n    # '< >' => ' ', ' < a > ' => ' a '\n    if ($html_like == 0 && $val =~ /\\s*<(.*)>\\s*\\z/)\n      {\n      $val = $1; $val = ' ' if $val eq '';\n      }\n    }\n  \n  my $v = $self->_unquote($val);\n\n  # Now HTML labels always start with \"<\", while non-HTML labels\n  # start with \" <\" or anything else.\n  if ($html_like == 0)\n    {\n    $v = ' ' . $v if $v =~ /^</;\n    }\n  else\n    {\n    $v =~ s/^\\s*//; $v =~ s/\\s*\\z//;\n    }\n\n  $v;\n  }\n\nsub _unquote\n  {\n  my ($self, $name) = @_;\n\n  $name = '' unless defined $name;\n\n  # string concat\n  # \"foo\" + \" bar\" => \"foo bar\"\n  $name =~ s/^\n    \"((?:\\\\\"|[^\"])*)\"\t\t\t# \"foo\"\n    \\s*\\+\\s*\"((?:\\\\\"|[^\"])*)\"\t\t# followed by ' + \"bar\"'\n    /\"$1$2\"/x\n  while $name =~ /^\n    \"(?:\\\\\"|[^\"])*\"\t\t\t# \"foo\"\n    \\s*\\+\\s*\"(?:\\\\\"|[^\"])*\"\t\t# followed by ' + \"bar\"'\n    /x;\n\n  # map \"&!;\" to \"!\"\n  $name =~ s/&(.);/$1/g;\n\n  # map \"&amp;\" to \"&\"\n  $name =~ s/&([^;]+);/$entities{$1} || '';/eg;\n\n  # \"foo bar\" => foo bar\n  $name =~ s/^\"\\s*//; \t\t# remove left-over quotes\n  $name =~ s/\\s*\"\\z//; \n\n  # unquote special chars\n  $name =~ s/\\\\([\\[\\(\\{\\}\\]\\)#\"])/$1/g;\n\n  $name;\n  }\n\nsub _clean_line\n  { \n  # do some cleanups on a line before handling it\n  my ($self,$line) = @_;\n\n  chomp($line);\n\n  # collapse white space at start\n  $line =~ s/^\\s+//;\n  # line ending in '\\' means a continuation\n  $line =~ s/\\\\\\z//;\n\n  $line;\n  }\n\nsub _line_insert\n  {\n  # \"a1 -> a2\\na3 -> a4\" => \"a1 -> a2 a3 -> a4\"\n  ' ';\n  }\n\n#############################################################################\n\nsub _match_boolean\n  {\n  # not used yet, match a boolean value\n  qr/(true|false|\\d+)/;\n  }\n\nsub _match_comment\n  {\n  # match the start of a comment\n\n  # // comment\n  qr#(:[^\\\\]|)//#;\n  }\n\nsub _match_multi_line_comment\n  {\n  # match a multi line comment\n\n  # /* * comment * */\n  qr#(?:\\s*/\\*.*?\\*/\\s*)+#;\n  }\n\nsub _match_optional_multi_line_comment\n  {\n  # match a multi line comment\n\n  # \"/* * comment * */\" or /* a */ /* b */ or \"\"\n  qr#(?:(?:\\s*/\\*.*?\\*/\\s*)*|\\s+)#;\n  }\n\nsub _match_name\n  {\n  # Return a regexp that matches an ID in the DOT language.\n  # See http://www.graphviz.org/doc/info/lang.html for reference.\n\n  # \"node\", \"graph\", \"edge\", \"digraph\", \"subgraph\" and \"strict\" are reserved:\n  qr/\\s*\n    (\n\t# double quoted string\n      \"(?:\\\\\"|[^\"])*\"\t\t\t# \"foo\"\n      (?:\\s*\\+\\s*\"(?:\\\\\"|[^\"])*\")*\t# followed by 0 or more ' + \"bar\"'\n    |\n\t# number\n     -?\t\t\t\t\t# optional minus sign\n\t(?:\t\t\t\t# non-capture group\n\t\\.[0-9]+\t\t\t\t# .00019\n\t|\t\t\t\t # or\n\t[0-9]+(?:\\.[0-9]*)?\t\t\t# 123 or 123.1\n\t)\n    |\n\t# plain node name (a-z0-9_+)\n     (?!(?i:node|edge|digraph|subgraph|graph|strict)\\s)[\\w]+\n    )/xi;\n  }\n\nsub _match_node\n  {\n  # Return a regexp that matches something like '\"bonn\"' or 'bonn' or 'bonn:f1'\n  my $self = shift;\n\n  my $qr_n = $self->_match_name();\n\n  # Examples: \"bonn\", \"Bonn\":f1, \"Bonn\":\"f1\", \"Bonn\":\"port\":\"w\", Bonn:port:w\n  qr/\n\t$qr_n\t\t\t\t# node name (see _match_name)\n\t(?:\n\t  :$qr_n\n\t  (?: :(n|ne|e|se|s|sw|w|nw) )?\t# :port:compass_direction\n\t  |\n\t  :(n|ne|e|se|s|sw|w|nw)\t# :compass_direction\n\t  )?\t\t\t\t# optional\n    /x;\n  }\n\nsub _match_group_start\n  {\n  # match a subgraph at the beginning (f.i. \"graph { \")\n  my $self = shift;\n  my $qr_n = $self->_match_name();\n\n  qr/^\\s*(?:strict\\s+)?(?:(?i)digraph|subgraph|graph)\\s+$qr_n\\s*\\{/i;\n  }\n\nsub _match_pseudo_group_start_at_beginning\n  {\n  # match an anonymous group start at the beginning (aka \" { \")\n  qr/^\\s*\\{/;\n  }\n\nsub _match_pseudo_group_start\n  {\n  # match an anonymous group start (aka \" { \")\n  qr/\\s*\\{/;\n  }\n\nsub _match_group_end\n  {\n  # return a regexp that matches something like \" }\" or \"} ;\".\n  qr/^\\s*\\}\\s*;?\\s*/;\n  }\n\nsub _match_edge\n  {\n  # Matches an edge\n  qr/\\s*(->|--)/;\n  }\n\nsub _match_html_regexps\n  {\n  # Return hash with regexps matching different parts of an HTML label.\n  my $qr = \n  {\n    # BORDER=\"2\"\n    attribute \t=> qr/\\s*([A-Za-z]+)\\s*=\\s*\"((?:\\\\\"|[^\"])*)\"/,\n    # BORDER=\"2\" COLSPAN=\"2\"\n    attributes \t=> qr/(?:\\s+(?:[A-Za-z]+)\\s*=\\s*\"(?:\\\\\"|[^\"])*\")*/,\n    text\t=> qr/.*?/,\n    tr\t\t=> qr/\\s*<TR>/i,\n    tr_end\t=> qr/\\s*<\\/TR>/i,\n    td\t\t=> qr/\\s*<TD[^>]*>/i,\n    td_tag\t=> qr/\\s*<TD\\s*/i,\n    td_end\t=> qr/\\s*<\\/TD>/i,\n    table\t=> qr/\\s*<TABLE[^>]*>/i,\n    table_tag\t=> qr/\\s*<TABLE\\s*/i,\n    table_end\t=> qr/\\s*<\\/TABLE>/i,\n  };\n  $qr->{row} = qr/$qr->{tr}(?:$qr->{td}$qr->{text}$qr->{td_end})*$qr->{tr_end}/;\n\n  $qr;\n  }\n\nsub _match_html\n  {\n  # build a giant regular expression that matches an HTML label\n\n#    label=<\n#    <TABLE BORDER=\"2\" CELLBORDER=\"1\" CELLSPACING=\"0\" BGCOLOR=\"#ffffff\">\n#      <TR><TD PORT=\"portname\" COLSPAN=\"3\" BGCOLOR=\"#aabbcc\" ALIGN=\"CENTER\">port</TD></TR>\n#      <TR><TD PORT=\"port2\" COLSPAN=\"2\" ALIGN=\"LEFT\">port2</TD><TD PORT=\"port3\" ALIGN=\"LEFT\">port3</TD></TR>\n#    </TABLE>>\n\n  my $qr = _match_html_regexps();\n\n  # < <TABLE> .. </TABLE> >\n  qr/<$qr->{table}(?:$qr->{row})*$qr->{table_end}\\s*>/;\n  }\n  \nsub _match_single_attribute\n  {\n  my $qr_html = _match_html();\n\n  qr/\\s*(\\w+)\\s*=\\s*\t\t# the attribute name (label=\")\n    (\n      \"(?:\\\\\"|[^\"])*\"\t\t\t# \"foo\"\n      (?:\\s*\\+\\s*\"(?:\\\\\"|[^\"])*\")*\t# followed by 0 or more ' + \"bar\"'\n    |\n      $qr_html\t\t\t\t# or < <TABLE>..<\\/TABLE> >\n    |\n      <[^>]*>\t\t\t\t# or something like < a >\n    |\n      [^<][^,\\]\\}\\n\\s;]*\t\t# or simple 'fooobar'\n    )\n    [,\\]\\n\\}\\s;]?\\s*/x;\t\t# possible \",\", \"\\n\" etc.\n  }\n\nsub _match_special_attribute\n  {\n  # match boolean attributes, these can appear without a value\n  qr/\\s*(\n  center|\n  compound|\n  concentrate|\n  constraint|\n  decorate|\n  diredgeconstraints|\n  fixedsize|\n  headclip|\n  labelfloat|\n  landscape|\n  mosek|\n  nojustify|\n  normalize|\n  overlap|\n  pack|\n  pin|\n  regular|\n  remincross|\n  root|\n  splines|\n  tailclip|\n  truecolor\n  )[,;\\s]?\\s*/x;\n  }\n\nsub _match_attributes\n  {\n  # return a regexp that matches something like \" [ color=red; ]\" and returns\n  # the inner text without the []\n\n  my $qr_att = _match_single_attribute();\n  my $qr_satt = _match_special_attribute();\n  my $qr_cmt = _match_multi_line_comment();\n \n  qr/\\s*\\[\\s*((?:$qr_att|$qr_satt|$qr_cmt)*)\\s*\\];?/;\n  }\n\nsub _match_graph_attribute\n  {\n  # return a regexp that matches something like \" color=red; \" for attributes\n  # that apply to a graph/subgraph\n  qr/^\\s*(\\w+\\s*=\\s*(\"[^\"]+\"|[^;\\n\\s]+))([;\\n\\s]\\s*|\\z)/;\n  }\n\nsub _match_optional_attributes\n  {\n  # return a regexp that matches something like \" [ color=red; ]\" and returns\n  # the inner text with the []\n\n  my $qr_att = _match_single_attribute();\n  my $qr_satt = _match_special_attribute();\n  my $qr_cmt = _match_multi_line_comment();\n \n  qr/\\s*(\\[\\s*((?:$qr_att|$qr_satt|$qr_cmt)*)\\s*\\])?;?/;\n  }\n\nsub _clean_attributes\n  {\n  my ($self,$text) = @_;\n\n  $text =~ s/^\\s*\\[\\s*//;\t\t# remove left-over \"[\" and spaces\n  $text =~ s/\\s*;?\\s*\\]\\s*\\z//;\t\t# remove left-over \"]\" and spaces\n\n  $text;\n  }\n\n#############################################################################\n\nsub _new_scope\n  {\n  # create a new scope, with attributes from current scope\n  my ($self, $is_group) = @_;\n\n  my $scope = {};\n\n  if (@{$self->{scope_stack}} > 0)\n    {\n    my $old_scope = $self->{scope_stack}->[-1];\n\n    # make a copy of the old scope's attributes\n    for my $t (keys %$old_scope)\n      {\n      next if $t =~ /^_/;\n      my $s = $old_scope->{$t};\n      $scope->{$t} = {} unless ref $scope->{$t}; my $sc = $scope->{$t};\n      for my $k (keys %$s)\n        {\n\t# skip things like \"_is_group\"\n        $sc->{$k} = $s->{$k} unless $k =~ /^_/;\n        }\n      }\n    }\n  $scope->{_is_group} = 1 if defined $is_group;\n\n  push @{$self->{scope_stack}}, $scope;\n  $scope;\n  }\n\nsub _add_group_match\n  {\n  # register handlers for group start/end\n  my $self = shift;\n\n  my $qr_pseudo_group_start = $self->_match_pseudo_group_start_at_beginning();\n  my $qr_group_start = $self->_match_group_start();\n  my $qr_group_end   = $self->_match_group_end();\n  my $qr_edge  = $self->_match_edge();\n  my $qr_ocmt  = $self->_match_optional_multi_line_comment();\n\n  # \"subgraph G {\"\n  $self->_register_handler( $qr_group_start,\n    sub\n      {\n      my $self = shift;\n      my $graph = $self->{_graph};\n      my $gn = $self->_unquote($1);\n      print STDERR \"# Parser: found subcluster '$gn'\\n\" if $self->{debug};\n      push @{$self->{group_stack}}, $self->_new_group($gn);\n      $self->_new_scope( 1 );\n      1;\n      } );\n  \n  # \"{ \"\n  $self->_register_handler( $qr_pseudo_group_start,\n    sub\n      {\n      my $self = shift;\n      print STDERR \"# Parser: Creating new scope\\n\" if $self->{debug};\n      $self->_new_scope();\n      # forget the left side\n      $self->{left_edge} = undef;\n      $self->{left_stack} = [ ];\n      1;\n      } );\n\n  # \"} -> \" group/cluster/scope end with an edge\n  $self->_register_handler( qr/$qr_group_end$qr_ocmt$qr_edge/,\n    sub\n      {\n      my $self = shift;\n\n      my $scope = pop @{$self->{scope_stack}};\n      return $self->parse_error(0) if !defined $scope;\n\n      if ($scope->{_is_group} && @{$self->{group_stack}})\n        {\n        print STDERR \"# Parser: end subcluster '$self->{group_stack}->[-1]->{name}'\\n\" if $self->{debug};\n        pop @{$self->{group_stack}};\n        }\n      else { print STDERR \"# Parser: end scope\\n\" if $self->{debug}; }\n\n      1;\n      }, \n    sub\n      {\n      my ($self, $line) = @_;\n      $line =~ qr/$qr_group_end$qr_edge/;\n      $1 . ' ';\n      } );\n\n  # \"}\" group/cluster/scope end\n  $self->_register_handler( $qr_group_end,\n    sub\n      {\n      my $self = shift;\n \n      my $scope = pop @{$self->{scope_stack}};\n      return $self->parse_error(0) if !defined $scope;\n\n      if ($scope->{_is_group} && @{$self->{group_stack}})\n        {\n        print STDERR \"# Parser: end subcluster '$self->{group_stack}->[-1]->{name}'\\n\" if $self->{debug};\n        pop @{$self->{group_stack}};\n        }\n      # always reset the stack\n      $self->{stack} = [ ];\n      1;\n      } );\n  }\n\nsub _edge_style\n  {\n  # To convert \"--\" or \"->\" we simple do nothing, since the edge style in\n  # Graphviz can only be set via the attribute \"style\"\n  my ($self, $ed) = @_;\n\n  'solid';\n  }\n\nsub _new_nodes\n  {\n  my ($self, $name, $group_stack, $att, $port, $stack) = @_;\n\n  $port = '' unless defined $port;\n  my @rc = ();\n  # \"name1\" => \"name1\"\n  if ($port ne '')\n    {\n    # create a special node\n    $name =~ s/^\"//; $name =~ s/\"\\z//;\n    $port =~ s/^\"//; $port =~ s/\"\\z//;\n    # XXX TODO: find unique name?\n    @rc = $self->_new_node ($self->{_graph}, \"$name:$port\", $group_stack, $att, $stack);\n    my $node = $rc[0];\n    $node->{_graphviz_portlet} = $port;\n    $node->{_graphviz_basename} = $name;\n    }\n  else\n    {\n    @rc = $self->_new_node ($self->{_graph}, $name, $group_stack, $att, $stack);\n    }\n  @rc;\n  }\n\nsub _build_match_stack\n  {\n  my $self = shift;\n\n  my $qr_node  = $self->_match_node();\n  my $qr_name  = $self->_match_name();\n  my $qr_cmt   = $self->_match_multi_line_comment();\n  my $qr_ocmt  = $self->_match_optional_multi_line_comment();\n  my $qr_attr  = $self->_match_attributes();\n  my $qr_gatr  = $self->_match_graph_attribute();\n  my $qr_oatr  = $self->_match_optional_attributes();\n  my $qr_edge  = $self->_match_edge();\n  my $qr_pgr = $self->_match_pseudo_group_start();\n\n  # remove multi line comments /* comment */\n  $self->_register_handler( qr/^$qr_cmt/, undef );\n  \n  # remove single line comment // comment\n  $self->_register_handler( qr/^\\s*\\/\\/.*/, undef );\n  \n  # simple remove the graph start, but remember that we did this\n  $self->_register_handler( qr/^\\s*((?i)strict)?$qr_ocmt((?i)digraph|graph)$qr_ocmt$qr_node$qr_ocmt\\{/, \n    sub \n      {\n      my $self = shift;\n      return $self->parse_error(6) if @{$self->{scope_stack}} > 0; \n      $self->{_graphviz_graph_name} = $3; \n      $self->_new_scope(1);\n      $self->{_graph}->set_attribute('type','undirected') if lc($2) eq 'graph';\n      1;\n      } );\n\n  # simple remove the graph start, but remember that we did this\n  $self->_register_handler( qr/^\\s*(strict)?$qr_ocmt(di)?graph$qr_ocmt\\{/i, \n    sub \n      {\n      my $self = shift;\n      return $self->parse_error(6) if @{$self->{scope_stack}} > 0; \n      $self->{_graphviz_graph_name} = 'unnamed'; \n      $self->_new_scope(1);\n      $self->{_graph}->set_attribute('type','undirected') if lc($2) ne 'di';\n      1;\n      } );\n\n  # end-of-statement\n  $self->_register_handler( qr/^\\s*;/, undef );\n\n  # cluster/subgraph \"subgraph G { .. }\"\n  # scope (dummy group): \"{ .. }\" \n  # scope/group/subgraph end: \"}\"\n  $self->_add_group_match();\n\n  # node [ color=\"red\" ] etc.\n  # The \"(?i)\" makes the keywords match case-insensitive. \n  $self->_register_handler( qr/^\\s*((?i)node|graph|edge)$qr_ocmt$qr_attr/,\n    sub\n      {\n      my $self = shift;\n      my $type = lc($1 || '');\n      my $att = $self->_parse_attributes($2 || '', $type, NO_MULTIPLES );\n      return undef unless defined $att;\t\t# error in attributes?\n\n      if ($type ne 'graph')\n\t{\n\t# apply the attributes to the current scope\n\tmy $scope = $self->{scope_stack}->[-1];\n        $scope->{$type} = {} unless ref $scope->{$type};\n\tmy $s = $scope->{$type};\n\tfor my $k (keys %$att)\n\t  {\n          $s->{$k} = $att->{$k}; \n\t  }\n\t}\n      else\n\t{\n\tmy $graph = $self->{_graph};\n\t$graph->set_attributes ($type, $att);\n\t}\n\n      # forget stacks\n      $self->{stack} = [];\n      $self->{left_edge} = undef;\n      $self->{left_stack} = [];\n      1;\n      } );\n\n  # color=red; (for graphs or subgraphs)\n  $self->_register_attribute_handler($qr_gatr, 'parent');\n  # [ color=red; ] (for nodes/edges)\n  $self->_register_attribute_handler($qr_attr);\n\n  # node chain continued like \"-> { ... \"\n  $self->_register_handler( qr/^$qr_edge$qr_ocmt$qr_pgr/,\n    sub\n      {\n      my $self = shift;\n\n      return if @{$self->{stack}} == 0;\t# only match this if stack non-empty\n\n      my $graph = $self->{_graph};\n      my $eg = $1;\t\t\t\t\t# entire edge (\"->\" etc)\n\n      my $edge_un = 0; $edge_un = 1 if $eg eq '--';\t# undirected edge?\n\n      # need to defer edge attribute parsing until the edge exists\n      # if inside a scope, set the scope attributes, too:\n      my $scope = $self->{scope_stack}->[-1] || {};\n      my $edge_atr = $scope->{edge} || {};\n\n      # create a new scope\n      $self->_new_scope();\n\n      # remember the left side\n      $self->{left_edge} = [ 'solid', '', $edge_atr, 0, $edge_un ];\n      $self->{left_stack} = $self->{stack};\n\n      # forget stack and remember the right side instead\n      $self->{stack} = [];\n\n      1;\n      } );\n\n  # \"Berlin\"\n  $self->_register_handler( qr/^$qr_node/,\n    sub\n      {\n      my $self = shift;\n      my $graph = $self->{_graph};\n\n      # only match this inside a \"{ }\" (normal, non-group) scope\n      return if exists $self->{scope_stack}->[-1]->{_is_group};\n\n      my $n1 = $1;\n      my $port = $2;\n      push @{$self->{stack}},\n        $self->_new_nodes ($n1, $self->{group_stack}, {}, $port, $self->{stack}); \n\n      if (defined $self->{left_edge})\n        {\n        my $e = $self->{use_class}->{edge};\n        my ($style, $edge_label, $edge_atr, $edge_bd, $edge_un) = @{$self->{left_edge}};\n\n        foreach my $node (@{$self->{left_stack}})\n          {\n          my $edge = $e->new( { style => $style, name => $edge_label } );\n\n\t  # if inside a scope, set the scope attributes, too:\n\t  my $scope = $self->{scope_stack}->[-1];\n          $edge->set_attributes($scope->{edge}) if $scope;\n\n\t  # override with the local attributes \n\t  # 'string' => [ 'string' ]\n\t  # [ { hash }, 'string' ] => [ { hash }, 'string' ]\n\t  my $e = $edge_atr; $e = [ $edge_atr ] unless ref($e) eq 'ARRAY';\n\n\t  for my $a (@$e)\n\t    {\n\t    if (ref $a)\n\t    {\n\t    $edge->set_attributes($a);\n\t    }\n\t  else\n\t    {\n\t    # deferred parsing with the object as param:\n\t    my $out = $self->_parse_attributes($a, $edge, NO_MULTIPLES);\n            return undef unless defined $out;\t\t# error in attributes?\n\t    $edge->set_attributes($out);\n\t    }\n\t  }\n\n          # \"<--->\": bidirectional\n          $edge->bidirectional(1) if $edge_bd;\n          $edge->undirected(1) if $edge_un;\n          $graph->add_edge ( $node, $self->{stack}->[-1], $edge );\n          }\n        }\n      1;\n      } );\n\n  # \"Berlin\" [ color=red ] or \"Bonn\":\"a\" [ color=red ]\n  $self->_register_handler( qr/^$qr_node$qr_oatr/,\n    sub\n      {\n      my $self = shift;\n      my $name = $1;\n      my $port = $2;\n      my $compass = $4 || ''; $port .= \":$compass\" if $compass;\n\n      $self->{stack} = [ $self->_new_nodes ($name, $self->{group_stack}, {}, $port ) ];\n\n      # defer attribute parsing until object exists\n      my $node = $self->{stack}->[0];\n      my $a1 = $self->_parse_attributes($5||'', $node);\n      return undef if $self->{error};\n      $node->set_attributes($a1);\n\n      # forget left stack\n      $self->{left_edge} = undef;\n      $self->{left_stack} = [];\n      1;\n      } );\n\n  # Things like ' \"Node\" ' will be consumed before, so we do not need a case\n  # for '\"Bonn\" -> \"Berlin\"'\n\n  # node chain continued like \"-> \"Kassel\" [ ... ]\"\n  $self->_register_handler( qr/^$qr_edge$qr_ocmt$qr_node$qr_ocmt$qr_oatr/,\n    sub\n      {\n      my $self = shift;\n\n      return if @{$self->{stack}} == 0;\t# only match this if stack non-empty\n\n      my $graph = $self->{_graph};\n      my $eg = $1;\t\t\t\t\t# entire edge (\"->\" etc)\n      my $n = $2;\t\t\t\t\t# node name\n      my $port = $3;\n      my $compass = $4 || $5 || ''; $port .= \":$compass\" if $compass;\n\n      my $edge_un = 0; $edge_un = 1 if $eg eq '--';\t# undirected edge?\n\n      my $scope = $self->{scope_stack}->[-1] || {};\n\n      # need to defer edge attribute parsing until the edge exists\n      my $edge_atr = [ $6||'', $scope->{edge} || {} ];\n\n      # the right side nodes:\n      my $nodes_b = [ $self->_new_nodes ($n, $self->{group_stack}, {}, $port) ];\n\n      my $style = $self->_link_lists( $self->{stack}, $nodes_b,\n\t'--', '', $edge_atr, 0, $edge_un);\n\n      # remember the left side\n      $self->{left_edge} = [ $style, '', $edge_atr, 0, $edge_un ];\n      $self->{left_stack} = $self->{stack};\n\n      # forget stack and remember the right side instead\n      $self->{stack} = $nodes_b;\n      1;\n      } );\n\n  $self;\n  }\n\nsub _add_node\n  {\n  # add a node to the graph, overridable by subclasses\n  my ($self, $graph, $name) = @_;\n\n  # \"a -- clusterB\" should not create a spurious node named \"clusterB\"\n  my @groups = $graph->groups();\n  for my $g (@groups)\n    {\n    return $g if $g->{name} eq $name;\n    }\n\n  my $node = $graph->node($name);\n \n  if (!defined $node)\n    {\n    $node = $graph->add_node($name);\t\t# add\n\n    # apply attributes from the current scope (only for new nodes)\n    my $scope = $self->{scope_stack}->[-1];\n    return $self->error(\"Scope stack is empty!\") unless defined $scope;\n  \n    my $is_group = $scope->{_is_group};\n    delete $scope->{_is_group};\n    $node->set_attributes($scope->{node});\n    $scope->{_is_group} = $is_group if $is_group;\n    }\n\n  $node;\n  }\n\n#############################################################################\n# attribute remapping\n\n# undef => drop that attribute\n# not listed attributes will result in \"x-dot-$attribute\" and a warning\n\nmy $remap = {\n  'node' => {\n    'distortion' => 'x-dot-distortion',\n\n    'fixedsize' => undef,\n    'group' => 'x-dot-group',\n    'height' => 'x-dot-height',\n\n    # XXX TODO: ignore non-node attributes set in a scope\n    'dir' => undef,\n\n    'layer' => 'x-dot-layer',\n    'margin' => 'x-dot-margin',\n    'orientation' => \\&_from_graphviz_node_orientation,\n    'peripheries' => \\&_from_graphviz_node_peripheries,\n    'pin' => 'x-dot-pin',\n    'pos' => 'x-dot-pos',\n    # XXX TODO: rank=0 should make that node the root node\n#   'rank' => undef,\n    'rects' => 'x-dot-rects',\n    'regular' => 'x-dot-regular',\n#    'root' => undef,\n    'sides' => 'x-dot-sides',\n    'shapefile' => 'x-dot-shapefile',\n    'shape' => \\&_from_graphviz_node_shape,\n    'skew' => 'x-dot-skew',\n    'style' => \\&_from_graphviz_style,\n    'width' => 'x-dot-width',\n    'z' => 'x-dot-z',\n    },\n\n  'edge' => {\n    'arrowsize' => 'x-dot-arrowsize',\n    'arrowhead' => \\&_from_graphviz_arrow_style,\n    'arrowtail' => 'x-dot-arrowtail',\n     # important for color lists like \"red:red\" => double edge\n    'color' => \\&_from_graphviz_edge_color,\n    'constraint' => 'x-dot-constraint',\n    'dir' => \\&_from_graphviz_edge_dir,\n    'decorate' => 'x-dot-decorate',\n    'f' => 'x-dot-f',\n    'headclip' => 'x-dot-headclip',\n    'headhref' => 'headlink',\n    'headurl' => 'headlink',\n    'headport' => \\&_from_graphviz_headport,\n    'headlabel' => 'headlabel',\n    'headtarget' => 'x-dot-headtarget',\n    'headtooltip' => 'headtitle',\n    'labelangle' => 'x-dot-labelangle',\n    'labeldistance' => 'x-dot-labeldistance',\n    'labelfloat' => 'x-dot-labelfloat',\n    'labelfontcolor' => \\&_from_graphviz_color,\n    'labelfontname' => 'font',\n    'labelfontsize' => 'font-size',\n    'layer' => 'x-dot-layer',\n    'len' => 'x-dot-len',\n    'lhead' => 'x-dot-lhead',\n    'ltail' => 'x-dot-tail',\n    'minlen' => \\&_from_graphviz_edge_minlen,\n    'pos' => 'x-dot-pos',\n    'samehead' => 'x-dot-samehead',\n    'samearrowhead' => 'x-dot-samearrowhead',\n    'sametail' => 'x-dot-sametail',\n    'style' => \\&_from_graphviz_edge_style,\n    'tailclip' => 'x-dot-tailclip',\n    'tailhref' => 'taillink',\n    'tailurl' => 'taillink',\n    'tailport' => \\&_from_graphviz_tailport,\n    'taillabel' => 'taillabel',\n    'tailtarget' => 'x-dot-tailtarget',\n    'tailtooltip' => 'tailtitle',\n    'weight' => 'x-dot-weight',\n    },\n\n  'graph' => {\n    'damping' => 'x-dot-damping',\n    'K' => 'x-dot-k',\n    'bb' => 'x-dot-bb',\n    'center' => 'x-dot-center',\n    # will be handled automatically:\n    'charset' => undef,\n    'clusterrank' => 'x-dot-clusterrank',\n    'compound' => 'x-dot-compound',\n    'concentrate' => 'x-dot-concentrate',\n    'defaultdist' => 'x-dot-defaultdist',\n    'dim' => 'x-dot-dim',\n    'dpi' => 'x-dot-dpi',\n    'epsilon' => 'x-dot-epsilon',\n    'esep' => 'x-dot-esep',\n    'fontpath' => 'x-dot-fontpath',\n    'labeljust' => \\&_from_graphviz_graph_labeljust,\n    'labelloc' => \\&_from_graphviz_labelloc,\n    'landscape' => 'x-dot-landscape',\n    'layers' => 'x-dot-layers',\n    'layersep' => 'x-dot-layersep',\n    'levelsgap' => 'x-dot-levelsgap',\n    'margin' => 'x-dot-margin',\n    'maxiter' => 'x-dot-maxiter',\n    'mclimit' => 'x-dot-mclimit',\n    'mindist' => 'x-dot-mindist',\n    'minquit' => 'x-dot-minquit',\n    'mode' => 'x-dot-mode',\n    'model' => 'x-dot-model',\n    'nodesep' => 'x-dot-nodesep',\n    'normalize' => 'x-dot-normalize',\n    'nslimit' => 'x-dot-nslimit',\n    'nslimit1' => 'x-dot-nslimit1',\n    'ordering' => 'x-dot-ordering',\n    'orientation' => 'x-dot-orientation',\n    'output' => 'output',\n    'outputorder' => 'x-dot-outputorder',\n    'overlap' => 'x-dot-overlap',\n    'pack' => 'x-dot-pack',\n    'packmode' => 'x-dot-packmode',\n    'page' => 'x-dot-page',\n    'pagedir' => 'x-dot-pagedir',\n    'pencolor' => \\&_from_graphviz_color,\n    'quantum' => 'x-dot-quantum',\n    'rankdir' => \\&_from_graphviz_graph_rankdir,\n    'ranksep' => 'x-dot-ranksep',\n    'ratio' => 'x-dot-ratio',\n    'remincross' => 'x-dot-remincross',\n    'resolution' => 'x-dot-resolution',\n    'rotate' => 'x-dot-rotate',\n    'samplepoints' => 'x-dot-samplepoints',\n    'searchsize' => 'x-dot-searchsize',\n    'sep' => 'x-dot-sep',\n    'size' => 'x-dot-size',\n    'splines' => 'x-dot-splines',\n    'start' => 'x-dot-start',\n    'style' => \\&_from_graphviz_style,\n    'stylesheet' => 'x-dot-stylesheet',\n    'truecolor' => 'x-dot-truecolor',\n    'viewport' => 'x-dot-viewport',\n    'voro-margin' => 'x-dot-voro-margin',\n    },\n\n  'group' => {\n    'labeljust' => \\&_from_graphviz_graph_labeljust,\n    'labelloc' => \\&_from_graphviz_labelloc,\n    'pencolor' => \\&_from_graphviz_color,\n    'style' => \\&_from_graphviz_style,\n    'K' => 'x-dot-k',\n    },\n\n  'all' => {\n    'color' => \\&_from_graphviz_color,\n    'colorscheme' => 'x-colorscheme',\n    'bgcolor' => \\&_from_graphviz_color,\n    'fillcolor' => \\&_from_graphviz_color,\n    'fontsize' => \\&_from_graphviz_font_size,\n    'fontcolor' => \\&_from_graphviz_color,\n    'fontname' => 'font',\n    'lp' => 'x-dot-lp',\n    'nojustify' => 'x-dot-nojustify',\n    'rank' => 'x-dot-rank',\n    'showboxes' => 'x-dot-showboxes',\n    'target' => 'x-dot-target',\n    'tooltip' => 'title',\n    'URL' => 'link',\n    'href' => 'link',\n    },\n  };\n\nsub _remap { $remap; }\n\nmy $rankdir = {\n  'LR' => 'east',\n  'RL' => 'west',\n  'TB' => 'south',\n  'BT' => 'north',\n  };\n\nsub _from_graphviz_graph_rankdir\n  {\n  my ($self, $name, $dir, $object) = @_;\n\n  my $d = $rankdir->{$dir} || 'east';\n\n  ('flow', $d);\n  }\n\nmy $shapes = {\n  box => 'rect',\n  polygon => 'rect',\n  egg => 'rect',\n  rectangle => 'rect',\n  mdiamond => 'diamond',\n  msquare => 'rect',\n  plaintext => 'none',\n  none => 'none',\n  };\n\nsub _from_graphviz_node_shape\n  {\n  my ($self, $name, $shape) = @_;\n\n  my @rc;\n  my $s = lc($shape);\n  if ($s =~ /^(triple|double)/)\n    {\n    $s =~ s/^(triple|double)//;\n    push @rc, ('border-style','double');\n    }\n\n  # map the name to what Graph::Easy expects (ellipse stays as ellipse f.i.)\n  $s = $shapes->{$s} || $s;\n\n  (@rc, $name, $s);\n  }\n\nsub _from_graphviz_style\n  {\n  my ($self, $name, $style, $class) = @_;\n\n  my @styles = split /\\s*,\\s*/, $style;\n\n  my $is_node = 0;\n  $is_node = 1 if ref($class) && !$class->isa('Graph::Easy::Group');\n  $is_node = 1 if !ref($class) && defined $class && $class eq 'node';\n\n  my @rc;\n  for my $s (@styles)\n    {\n    @rc = ('shape', 'rounded') if $s eq 'rounded';\n    @rc = ('shape', 'invisible') if $s eq 'invis';\n    @rc = ('border', 'black ' . $1) if $s =~ /^(bold|dotted|dashed)\\z/;\n    if ($is_node != 0)\n      {\t\n      @rc = ('shape', 'rect') if $s eq 'filled';\n      }\n    # convert \"setlinewidth(12)\" => \n    if ($s =~ /setlinewidth\\((\\d+|\\d*\\.\\d+)\\)/)\n      {\n      my $width = abs($1 || 1);\n      my $style = '';\n      $style = 'wide';\t\t\t# > 11\n      $style = 'solid' if $width < 3;\n      $style = 'bold' if $width >= 3 && $width < 5;\n      $style = 'broad' if $width >= 5 && $width < 11;\n      push @rc, ('borderstyle',$style);\n      }\n    }\n\n  @rc;\n  }\n\nsub _from_graphviz_node_orientation\n  {\n  my ($self, $name, $o) = @_;\n\n  my $r = int($o);\n  \n  return (undef,undef) if $r == 0;\n\n  # 1.0 => 1\n  ('rotate', $r);\n  }\n\nmy $port_remap = {\n  n => 'north',\n  e => 'east',\n  w => 'west',\n  s => 'south',\n  };\n\nsub _from_graphviz_headport\n  {\n  my ($self, $name, $compass) = @_;\n\n  # XXX TODO\n  # handle \"port:compass\" too\n\n  # one of \"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\n  # \"ne => n\"\n  my $c = $port_remap->{ substr(lc($compass),0,1) } || 'east';\n \n  ('end', $c);\n  }\n\nsub _from_graphviz_tailport\n  {\n  my ($self, $name, $compass) = @_;\n\n  # XXX TODO\n  # handle \"port:compass\" too\n\n  # one of \"n\",\"ne\",\"e\",\"se\",\"s\",\"sw\",\"w\",\"nw\n  # \"ne => n\" => \"north\"\n  my $c = $port_remap->{ substr(lc($compass),0,1) } || 'east';\n  \n  ('start', $c);\n  }\n\nsub _from_graphviz_node_peripheries\n  {\n  my ($self, $name, $cnt) = @_;\n\n  return (undef,undef) if $cnt < 2;\n\n  # peripheries = 2 => double border\n  ('border-style', 'double');\n  }\n\nsub _from_graphviz_edge_minlen\n  {\n  my ($self, $name, $len) = @_;\n\n  # 1 => 1, 2 => 3, 3 => 5 etc\n  $len = $len * 2 - 1;\n  ($name, $len);\n  }\n\nsub _from_graphviz_font_size\n  {\n  my ($self, $f, $size) = @_;\n\n  # 20 => 20px\n  $size = $size . 'px' if $size =~ /^\\d+(\\.\\d+)?\\z/;\n\n  ('fontsize', $size);\n  }\n\nsub _from_graphviz_labelloc\n  {\n  my ($self, $name, $loc) = @_;\n\n  my $l = 'top';\n  $l = 'bottom' if $loc =~ /^b/;\n\n  ('labelpos', $l);\n  }\n\nsub _from_graphviz_edge_dir\n  {\n  my ($self, $name, $dir, $edge) = @_;\n\n  # Modify the edge, depending on dir\n  if (ref($edge))\n    {\n    # \"forward\" is the default and ignored\n    $edge->flip() if $dir eq 'back';\n    $edge->bidirectional(1) if $dir eq 'both';\n    $edge->undirected(1) if $dir eq 'none';\n    }\n\n  (undef, undef);\n  }\n\nsub _from_graphviz_edge_style\n  {\n  my ($self, $name, $style, $object) = @_;\n\n  # input: solid dashed dotted bold invis\n  $style = 'invisible' if $style eq 'invis';\n\n  # although \"normal\" is not documented, it occurs in the wild\n  $style = 'solid' if $style eq 'normal';\n\n  # convert \"setlinewidth(12)\" => \n  if ($style =~ /setlinewidth\\((\\d+|\\d*\\.\\d+)\\)/)\n    {\n    my $width = abs($1 || 1);\n    $style = 'wide';\t\t\t# > 11\n    $style = 'solid' if $width < 3;\n    $style = 'bold' if $width >= 3 && $width < 5;\n    $style = 'broad' if $width >= 5 && $width < 11;\n    }\n\n  ($name, $style);\n  }\n\nsub _from_graphviz_arrow_style\n  {\n  my ($self, $name, $shape, $object) = @_;\n\n  my $style = 'open';\n\n  $style = 'closed' if $shape =~ /^(empty|onormal)\\z/;\n  $style = 'filled' if $shape eq 'normal' || $shape eq 'normalnormal';\n  $style = 'open' if $shape eq 'vee' || $shape eq 'veevee';\n  $style = 'none' if $shape eq 'none' || $shape eq 'nonenone';\n\n  ('arrow-style', $style);\n  }\n\nmy $color_atr_map = {\n  fontcolor => 'color',\n  bgcolor => 'background',\n  fillcolor => 'fill',\n  pencolor => 'bordercolor',\n  labelfontcolor => 'labelcolor',\n  color => 'color',\n  };\n\nsub _from_graphviz_color\n  {\n  # Remap the color name and value\n  my ($self, $name, $color) = @_;\n\n  # \"//red\" => \"red\"\n  $color =~ s/^\\/\\///;\n\n  my $colorscheme = 'x11';\n  if ($color =~ /^\\//)\n    {\n    # \"/set9/red\" => \"red\"\n    $color =~ s/^\\/([^\\/]+)\\///;\n    $colorscheme = $1;\n    # map the color to the right color according to the colorscheme\n    $color = Graph::Easy->color_value($color,$colorscheme) || 'black';\n    }\n\n  # \"#AA BB CC => \"#AABBCC\"\n  $color =~ s/\\s+//g if $color =~ /^#/;\n\n  # \"0.1 0.4 0.5\" => \"hsv(0.1,0.4,0.5)\"\n  $color =~ s/\\s+/,/g if $color =~ /\\s/;\n  $color = 'hsv(' . $color . ')' if $color =~ /,/;\n\n  ($color_atr_map->{$name}, $color);\n  }\n\nsub _from_graphviz_edge_color\n  {\n  # remap the color name and value\n  my ($self, $name, $color) = @_;\n\n  my @colors = split /:/, $color;\n\n  for my $c (@colors)\n    {\n    $c = Graph::Easy::Parser::Graphviz::_from_graphviz_color($self,$name,$c);\n    }\n\n  my @rc;\n  if (@colors > 1)\n    {\n    # 'red:blue' => \"style: double; color: red\"\n    push @rc, 'style', 'double';\n    }\n\n  (@rc, $color_atr_map->{$name}, $colors[0]);\n  }\n\nsub _from_graphviz_graph_labeljust\n  {\n  my ($self, $name, $l) = @_;\n\n  # input: \"l\" \"r\" or \"c\", output \"left\", \"right\" or \"center\"\n  my $a = 'center';\n  $a = 'left' if $l eq 'l';\n  $a = 'right' if $l eq 'r';\n\n  ('align', $a);\n  }\n\n#############################################################################\n\nsub _remap_attributes\n  {\n  my ($self, $att, $object, $r) = @_;\n\n  if ($self->{debug})\n    {\n    my $o = ''; $o = \" for $object\" if $object;\n    print STDERR \"# remapping attributes '$att'$o\\n\";\n    require Data::Dumper; print STDERR \"#\" , Data::Dumper::Dumper($att),\"\\n\";\n    }\n\n  $r = $self->_remap() unless defined $r;\n\n  $self->{_graph}->_remap_attributes($object, $att, $r, 'noquote', undef, undef);\n  }\n\n#############################################################################\n\nmy $html_remap = {\n  'table' => {\n    'align' => 'align',\n    'balign' => undef,\n    'bgcolor' => 'fill',\n    'border' => 'border',\n    # XXX TODO\n    'cellborder' => 'border',\n    'cellspacing' => undef,\n    'cellpadding' => undef,\n    'fixedsize' => undef,\n    'height' => undef,\n    'href' => 'link',\n    'port' => undef,\n    'target' => undef,\n    'title' => 'title',\n    'tooltip' => 'title',\n    'valign' => undef,\n    'width' => undef,\n    },\n  'td' => {\n    'align' => 'align',\n    'balign' => undef,\n    'bgcolor' => 'fill',\n    'border' => 'border',\n    'cellspacing' => undef,\n    'cellpadding' => undef,\n    'colspan' => 'columns',\n    'fixedsize' => undef,\n    'height' => undef,\n    'href' => 'link',\n    'port' => undef,\n    'rowspan' => 'rows',\n    'target' => undef,\n    'title' => 'title',\n    'tooltip' => 'title',\n    'valign' => undef,\n    'width' => undef,\n    },\n  };\n\nsub _parse_html_attributes\n  {\n  my ($self, $text, $qr, $tag) = @_;\n\n  # \"<TD ...>\" => \" ...\"\n  $text =~ s/^$qr->{td_tag}//;\n  $text =~ s/\\s*>\\z//;\n\n  my $attr = {};\n  while ($text ne '')\n    {\n\n    return $self->error(\"HTML-like attribute '$text' doesn't look valid to me.\")\n      unless $text =~ s/^($qr->{attribute})//;\n\n    my $name = lc($2); my $value = $3;\n\n    $self->_unquote($value);\n    $value = lc($value) if $name eq 'align';\n    $self->error (\"Unknown attribute '$name' in HTML-like label\") unless exists $html_remap->{$tag}->{$name};\n    # filter out attributes we do not yet support\n    $attr->{$name} = $value if defined $html_remap->{$tag}->{$name};\n    }\n\n  $attr;\n  }\n\nsub _html_per_table\n  {\n  # take the HTML-like attributes found per TABLE and create a hash with them\n  # so they can be applied as default to each node\n  my ($self, $attributes) = @_;\n\n  $self->_remap_attributes($attributes,'table',$html_remap);\n  }\n\nsub _html_per_node\n  {\n  # take the HTML-like attributes found per TD and apply them to the node\n  my ($self, $attr, $node) = @_;\n\n  my $c = $attr->{colspan} || 1;\n  $node->set_attribute('columns',$c) if $c != 1;\n\n  my $r = $attr->{rowspan} || 1;\n  $node->set_attribute('rows',$r) if $r != 1;\n\n  $node->{autosplit_portname} = $attr->{port} if exists $attr->{port};\n\n  for my $k (qw/port colspan rowspan/)\n    {\n    delete $attr->{$k};\n    }\n\n  my $att = $self->_remap_attributes($attr,$node,$html_remap);\n \n  $node->set_attributes($att);\n\n  $self;\n  }\n\nsub _parse_html\n  {\n  # Given an HTML label, parses that into the individual parts. Returns a\n  # list of nodes.\n  my ($self, $n, $qr) = @_;\n\n  my $graph = $self->{_graph};\n\n  my $label = $n->label(1); $label = '' unless defined $label;\n  my $org_label = $label;\n\n#  print STDERR \"# 1 HTML-like label is now: $label\\n\";\n\n  # \"unquote\" the HTML-like label\n  $label =~ s/^<\\s*//;\n  $label =~ s/\\s*>\\z//;\n\n#  print STDERR \"# 2 HTML-like label is now: $label\\n\";\n\n  # remove the table end (at the end)\n  $label =~ s/$qr->{table_end}\\s*\\z//;\n#  print STDERR \"# 2.a HTML-like label is now: $label\\n\";\n  # remove the table start\n  $label =~ s/($qr->{table})//;\n\n#  print STDERR \"# 3 HTML-like label is now: $label\\n\";\n\n  my $table_tag = $1 || ''; \n  $table_tag =~ /$qr->{table_tag}(.*?)>/;\n  my $table_attr = $self->_parse_html_attributes($1 || '', $qr, 'table');\n\n#  use Data::Dumper;\n#  print STDERR \"# 3 HTML-like table-tag attributes are: \", Dumper($table_attr),\"\\n\";\n\n  # generate the base name from the actual graphviz node name to allow links to\n  # it\n  my $base_name = $n->{name};\n\n  my $class = $self->{use_class}->{node};\n\n  my $raw_attributes = $n->raw_attributes();\n  delete $raw_attributes->{label};\n  delete $raw_attributes->{shape};\n\n  my @rc; my $first_in_row;\n  my $x = 0; my $y = 0; my $idx = 0;\n  while ($label ne '')\n    {\n    $label =~ s/^\\s*($qr->{row})//;\n  \n    return $self->error (\"Cannot parse HTML-like label: '$label'\")\n      unless defined $1;\n\n    # we now got one row:\n    my $row = $1;\n\n#  print STDERR \"# 3 HTML-like row is $row\\n\";\n\n    # remove <TR>\n    $row =~ s/^\\s*$qr->{tr}\\s*//; \n    # remove </TR>\n    $row =~ s/\\s*$qr->{tr_end}\\s*\\z//;\n\n    my $first = 1;\n    while ($row ne '')\n      {\n      # remove one TD from the current row text\n      $row =~ s/^($qr->{td})($qr->{text})$qr->{td_end}//;\n      return $self->error (\"Cannot parse HTML-like row: '$row'\")\n        unless defined $1;\n\n      my $node_label = $2;\n      my $attr_txt = $1;\n\n      # convert \"<BR/>\" etc. to line breaks\n      # XXX TODO apply here the default of BALIGN\n      $node_label =~ s/<BR\\s*\\/?>/\\\\n/gi;\n\n      # if the font covers the entire node, set \"font\" attribute\n      my $font_face = undef;\n      if ($node_label =~ /^[ ]*<FONT FACE=\"([^\"]+)\">(.*)<\\/FONT>[ ]*\\z/i)\n        {\n        $node_label = $2; $font_face = $1;\n        }\n      # XXX TODO if not, allow inline font changes\n      $node_label =~ s/<FONT[^>]+>(.*)<\\/FONT>/$1/ig;\n\n      my $node_name = $base_name . '.' . $idx;\n\n      # if it doesn't exist, add it, otherwise retrieve node object to $node\n\n      my $node = $graph->node($node_name);\n      if (!defined $node)\n\t{\n\t# create node object from the correct class\n\t$node = $class->new($node_name);\n        $graph->add_node($node);\n\t$node->set_attributes($raw_attributes);\n        $node->{autosplit_portname} = $idx;\t\t# some sensible default\n\t}\n\n      # apply the default attributes from the table\n      $node->set_attributes($table_attr);\n      # if found a global font attribute, override the font attribute with it\n      $node->set_attribute('font',$font_face) if defined $font_face;\n\n      # parse the attributes and apply them to the node\n      $self->_html_per_node( $self->_parse_html_attributes($attr_txt,$qr,'td'), $node );\n\n#     print STDERR \"# Created $node_name\\n\";\n \n      $node->{autosplit_label} = $node_label;\n      $node->{autosplit_basename} = $base_name;\n\n      push @rc, $node;\n      if (@rc == 1)\n        {\n        # for correct as_txt output\n        $node->{autosplit} = $org_label;\n        $node->{autosplit} =~ s/\\s+\\z//;\t# strip trailing spaces\n        $node->{autosplit} =~ s/^\\s+//;\t\t# strip leading spaces\n        $first_in_row = $node;\n        }\n      else\n        {\n        # second, third etc. get previous as origin\n        my ($sx,$sy) = (1,0);\n        my $origin = $rc[-2];\n\t# the first node in one row is relative to the first node in the\n\t# prev row\n\tif ($first == 1)\n          {\n          ($sx,$sy) = (0,1); $origin = $first_in_row;\n          $first_in_row = $node;\n\t  $first = 0;\n          } \n        $node->relative_to($origin,$sx,$sy);\n\t# suppress as_txt output for other parts\n\t$node->{autosplit} = undef;\n        }\t\n      # nec. for border-collapse\n      $node->{autosplit_xy} = \"$x,$y\";\n\n      $idx++;\t\t\t\t\t\t# next node ID\n      $x++;\n      }\n\n    # next row\n    $y++;\n    }\n\n  # return created nodes\n  @rc;\n  }\n\n#############################################################################\n\nsub _parser_cleanup\n  {\n  # After initial parsing, do cleanup, e.g. autosplit nodes with shape record,\n  # parse HTML-like labels, re-connect edges to the parts etc.\n  my ($self) = @_;\n\n  print STDERR \"# Parser cleanup pass\\n\" if $self->{debug};\n\n  my $g = $self->{_graph};\n  my @nodes = $g->nodes();\n\n  # For all nodes that have a shape of \"record\", break down their label into\n  # parts and create these as autosplit nodes.\n  # For all nodes that have a label starting with \"<\", parse it as HTML.\n\n  # keep a record of all nodes to be deleted later:\n  my $delete = {};\n\n  my $html_regexps = $self->_match_html_regexps();\n  my $graph_flow = $g->attribute('flow');\n  for my $n (@nodes)\n    {\n    my $label = $n->label(1);\n    # we can get away with a direct lookup, since DOT does not have classes\n    my $shape = $n->{att}->{shape} || 'rect';\n\n    if ($shape ne 'record' && $label =~ /^<\\s*<.*>\\z/)\n      {\n      print STDERR \"# HTML-like label found: $label\\n\" if $self->{debug};\n      my @nodes = $self->_parse_html($n, $html_regexps);\n      # remove the temp. and spurious node\n      $delete->{$n->{name}} = undef;\n      my @edges = $n->edges();\n      # reconnect the found edges to the new autosplit parts\n      for my $e (@edges)\n        {\n        # XXX TODO: connect to better suited parts based on flow?\n        $e->start_at($nodes[0]) if ($e->{from} == $n);\n        $e->end_at($nodes[0]) if ($e->{to} == $n);\n        }\n      $g->del_node($n);\n      next;\n      }\n\n    if ($shape eq 'record' && $label =~ /\\|/)\n      {\n      my $att = {};\n      # create basename only when node name differes from label\n      $att->{basename} = $n->{name};\n      if ($n->{name} ne $label)\n\t{\n\t$att->{basename} = $n->{name};\n\t}\n      # XXX TODO: autosplit needs to handle nesting like \"{}\".\n\n      # Replace \"{ ... | ... |  ... }\" with \"...|| ... || ....\" as a cheat\n      # to fix some common cases\n      if ($label =~ /^\\s*\\{[^\\{\\}]+\\}\\s*\\z/)\n\t{\n        $label =~ s/[\\{\\}]//g;\t# {..|..} => ..|..\n        # if flow up/down:    {A||B} => \"[ A||  ||  B ]\"\n        $label =~ s/\\|/\\|\\|  /g\t# ..|.. => ..||  ..\n\t  if ($graph_flow =~ /^(east|west)/);\n        # if flow left/right: {A||B} => \"[ A|  |B ]\"\n        $label =~ s/\\|\\|/\\|  \\|/g\t# ..|.. => ..|  |..\n\t  if ($graph_flow =~ /^(north|south)/);\n\t}\n      my @rc = $self->_autosplit_node($g, $label, $att, 0 );\n      my $group = $n->group();\n      $n->del_attribute('label');\n\n      my $qr_clean = $self->{_qr_part_clean};\n      # clean the base name of ports:\n      #  \"<f1> test | <f2> test\" => \"test|test\"\n      $rc[0]->{autosplit} =~ s/(^|\\|)$qr_clean/$1/g;\n      $rc[0]->{att}->{basename} =~ s/(^|\\|)$qr_clean/$1/g;\n      $rc[0]->{autosplit} =~ s/^\\s*//;\n      $rc[0]->{att}->{basename} =~ s/^\\s*//;\n      # '| |' => '|  |' to avoid empty parts via as_txt() => as_ascii()\n      $rc[0]->{autosplit} =~ s/\\|\\s\\|/\\|  \\|/g;\n      $rc[0]->{att}->{basename} =~ s/\\|\\s\\|/\\|  \\|/g;\n      $rc[0]->{autosplit} =~ s/\\|\\s\\|/\\|  \\|/g;\n      $rc[0]->{att}->{basename} =~ s/\\|\\s\\|/\\|  \\|/g;\n      delete $rc[0]->{att}->{basename} if $rc[0]->{att}->{basename} eq $rc[0]->{autosplit};\n\n      for my $n1 (@rc)\n\t{\n\t$n1->add_to_group($group) if $group;\n\t$n1->set_attributes($n->{att});\n\t# remove the temp. \"shape=record\"\n\t$n1->del_attribute('shape');\n\t}\n\n      # If the helper node has edges, reconnect them to the first\n      # part of the autosplit node (dot seems to render them arbitrarily\n      # on the autosplit node):\n\n      for my $e (values %{$n->{edges}})\n\t{\n        $e->start_at($rc[0]) if $e->{from} == $n;\n        $e->end_at($rc[0]) if $e->{to} == $n;\n\t}\n      # remove the temp. and spurious node\n      $delete->{$n->{name}} = undef;\n      $g->del_node($n);\n      }\n    }\n\n  # During parsing, \"bonn:f1\" -> \"berlin:f2\" results in \"bonn:f1\" and\n  # \"berlin:f2\" as nodes, plus an edge connecting them\n\n  # We find all of these nodes, move the edges to the freshly created\n  # autosplit parts above, then delete the superflous temporary nodes.\n\n  # if we looked up \"Bonn:f1\", remember it here to save time:\n  my $node_cache = {};\n\n  my @edges = $g->edges();\n  @nodes = $g->nodes();\t\t# get a fresh list of nodes after split\n  for my $e (@edges)\n    {\n    # do this for both the \"from\" and \"to\" side of the edge:\n    for my $side ('from','to')\n      {\n      my $n = $e->{$side};\n      next unless defined $n->{_graphviz_portlet};\n\n      my $port = $n->{_graphviz_portlet};\n      my $base = $n->{_graphviz_basename};\n\n      my $compass = '';\n      if ($port =~ s/:(n|ne|e|se|s|sw|w|nw)\\z//)\n\t{\n        $compass = $1;\n\t}\n      # \"Bonn:w\" is port \"w\", and only \"west\" when that port doesnt exist\t\n\n      # look it up in the cache first\n      my $node = $node_cache->{\"$base:$port\"};\n\n      my $p = undef;\n      if (!defined $node)\n\t{\n\t# go thru all nodes and for see if we find one with the right port name\n\tfor my $na (@nodes)\n\t  {\n\t  next unless exists $na->{autosplit_portname} && exists $na->{autosplit_basename};\n\t  next unless $na->{autosplit_basename} eq $base;\n\t  next unless $na->{autosplit_portname} eq $port;\n\t  # cache result\n          $node_cache->{\"$base:$port\"} = $na;\n          $node = $na;\n          $p = $port_remap->{substr($compass,0,1)} if $compass;\t\t# ne => n => north\n\t  }\n\t}\n\n      if (!defined $node)\n\t{\n\t# Still not defined?\n        # port looks like a compass node?\n\tif ($port =~ /^(n|ne|e|se|s|sw|w|nw)\\z/)\n\t  {\n\t  # get the first node matching the base\n\t  for my $na (@nodes)\n\t    {\n\t    #print STDERR \"# evaluating $na ($na->{name} $na->{autosplit_basename}) ($base)\\n\";\n\t    next unless exists $na->{autosplit_basename};\n\t    next unless $na->{autosplit_basename} eq $base;\n\t    # cache result\n\t    $node_cache->{\"$base:$port\"} = $na;\n\t    $node = $na;\n\t    }\n\t  if (!defined $node)\n\t    {\n\t    return $self->error(\"Cannot find autosplit node for $base:$port on edge $e->{id}\");\n\t    }\n          $p = $port_remap->{substr($port,0,1)};\t\t# ne => n => north\n\t  }\n\telse\n\t  {\n\t  # uhoh...\n\t  return $self->error(\"Cannot find autosplit node for $base:$port on edge $e->{id}\");\n\t  }\n \t}\n\n      if ($side eq 'from')\n\t{\n        $delete->{$e->{from}->{name}} = undef;\n  \tprint STDERR \"# Setting new edge start point to $node->{name}\\n\" if $self->{debug};\n\t$e->start_at($node);\n  \tprint STDERR \"# Setting new edge end point to start at $p\\n\" if $self->{debug} && $p;\n\t$e->set_attribute('start', $p) if $p;\n\t}\n      else\n\t{\n        $delete->{$e->{to}->{name}} = undef;\n  \tprint STDERR \"# Setting new edge end point to $node->{name}\\n\" if $self->{debug};\n\t$e->end_at($node);\n  \tprint STDERR \"# Setting new edge end point to end at $p\\n\" if $self->{debug} && $p;\n\t$e->set_attribute('end', $p) if $p;\n\t}\n\n      } # end for side \"from\" and \"to\"\n    # we have reconnected this edge\n    }\n\n  # after reconnecting all edges, we can delete temp. nodes: \n  for my $n (@nodes)\n    {\n    next unless exists $n->{_graphviz_portlet};\n    # \"c:w\" => \"c\"\n    my $name = $n->{name}; $name =~ s/:.*?\\z//;\n    # add \"c\" unless we should delete the base node (this deletes record\n    # and autosplit nodes, but keeps loners like \"c:w\" around as \"c\":\n    $g->add_node($name) unless exists $delete->{$name};\n    # delete \"c:w\"\n    $g->del_node($n); \n    }\n\n  # if the graph doesn't have a title, set the graph name as title\n  $g->set_attribute('title', $self->{_graphviz_graph_name})\n    unless defined $g->raw_attribute('title');\n  \n  # cleanup if there are no groups\n  if ($g->groups() == 0)\n    {\n    $g->del_attribute('group', 'align');\n    $g->del_attribute('group', 'fill');\n    }\n  $g->{_warn_on_unknown_attributes} = 0;\t# reset to die again\n\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Parser::Graphviz - Parse Graphviz text into Graph::Easy\n\n=head1 SYNOPSIS\n\n        # creating a graph from a textual description\n\n        use Graph::Easy::Parser::Graphviz;\n        my $parser = Graph::Easy::Parser::Graphviz->new();\n\n        my $graph = $parser->from_text(\n                \"digraph MyGraph { \\n\" .\n\t \t\"\tBonn -> \\\"Berlin\\\" \\n }\"\n        );\n        print $graph->as_ascii();\n\n\tprint $parser->from_file('mygraph.dot')->as_ascii();\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Parser::Graphviz> parses the text format from the DOT language\nuse by Graphviz and constructs a C<Graph::Easy> object from it.\n\nThe resulting object can than be used to layout and output the graph\nin various formats.\n\nPlease see the Graphviz manual for a full description of the syntax\nrules of the DOT language.\n\n=head2 Output\n\nThe output will be a L<Graph::Easy|Graph::Easy> object (unless overrriden\nwith C<use_class()>), see the documentation for Graph::Easy what you can do\nwith it.\n\n=head2 Attributes\n\nAttributes will be remapped to the proper Graph::Easy attribute names and\nvalues, as much as possible.\n\nAnything else will be converted to custom attributes starting with \"x-dot-\".\nSo \"ranksep: 2\" will become \"x-dot-ranksep: 2\".\n\n=head1 METHODS\n\nC<Graph::Easy::Parser::Graphviz> supports the same methods\nas its parent class C<Graph::Easy::Parser>:\n\n=head2 new()\n\n\tuse Graph::Easy::Parser::Graphviz;\n\tmy $parser = Graph::Easy::Parser::Graphviz->new();\n\nCreates a new parser object. There are two valid parameters:\n\n\tdebug\n\tfatal_errors\n\nBoth take either a false or a true value.\n\n\tmy $parser = Graph::Easy::Parser::Graphviz->new( debug => 1 );\n\t$parser->from_text('digraph G { A -> B }');\n\n=head2 reset()\n\n\t$parser->reset();\n\nReset the status of the parser, clear errors etc. Automatically called\nwhen you call any of the C<from_XXX()> methods below.\n\n=head2 use_class()\n\n\t$parser->use_class('node', 'Graph::Easy::MyNode');\n\nOverride the class to be used to constructs objects while parsing.\n\nSee L<Graph::Easy::Parser> for further information.\n\n=head2 from_text()\n\n\tmy $graph = $parser->from_text( $text );\n\nCreate a L<Graph::Easy|Graph::Easy> object from the textual description in C<$text>.\n\nReturns undef for error, you can find out what the error was\nwith L<error()>.\n\nThis method will reset any previous error, and thus the C<$parser> object\ncan be re-used to parse different texts by just calling C<from_text()>\nmultiple times.\n\n=head2 from_file()\n\n\tmy $graph = $parser->from_file( $filename );\n\tmy $graph = Graph::Easy::Parser->from_file( $filename );\n\nCreates a L<Graph::Easy|Graph::Easy> object from the textual description in the file\nC<$filename>.\n\nThe second calling style will create a temporary parser object,\nparse the file and return the resulting C<Graph::Easy> object.\n\nReturns undef for error, you can find out what the error was\nwith L<error()> when using the first calling style.\n\n=head2 error()\n\n\tmy $error = $parser->error();\n\nReturns the last error, or the empty string if no error occured.\n\n=head2 parse_error()\n\n\t$parser->parse_error( $msg_nr, @params);\n\nSets an error message from a message number and replaces embedded\ntemplates like C<##param1##> with the passed parameters.\n\n=head1 CAVEATS\n\nThe parser has problems with the following things:\n\n=over 12\n\n=item encoding and charset attribute\n\nThe parser assumes the input to be C<utf-8>. Input files in <code>Latin1</code>\nare not parsed properly, even when they have the charset attribute set.\n\n=item shape=record\n\nNodes with shape record are only parsed properly when the label does not\ncontain groups delimited by \"{\" and \"}\", so the following is parsed\nwrongly:\n\n\tnode1 [ shape=record, label=\"A|{B|C}\" ]\n\n=item default shape\n\nThe default shape for a node is 'rect', opposed to 'circle' as dot renders\nnodes.\n\n=item attributes\n\nSome attributes are B<not> remapped properly to what Graph::Easy expects, thus\nlosing information, either because Graph::Easy doesn't support this feature\nyet, or because the mapping is incomplete.\n\nSome attributes meant only for nodes or edges etc. might be incorrectly applied\nto other objects, resulting in unnec. warnings while parsing.\n\nAttributes not valid in the original DOT language are silently ignored by dot,\nbut result in a warning when parsing under Graph::Easy. This helps catching all\nthese pesky misspellings, but it's not yet possible to disable these warnings.\n\n=item comments\n\nComments written in the source code itself are discarded. If you want to have\ncomments on the graph, clusters, nodes or edges, use the attribute C<comment>.\nThese are correctly read in and stored, and then output into the different\nformats, too.\n\n=back\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<Graph::Reader::Dot>.\n\n=head1 AUTHOR\n\nCopyright (C) 2005 - 2007 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy/Parser/VCG.pm": "#############################################################################\n# Parse VCG text into a Graph::Easy object\n#\n#############################################################################\n\npackage Graph::Easy::Parser::VCG;\n\n$VERSION = '0.06';\nuse Graph::Easy::Parser::Graphviz;\n@ISA = qw/Graph::Easy::Parser::Graphviz/;\n\nuse strict;\nuse utf8;\nuse constant NO_MULTIPLES => 1;\nuse Encode qw/decode/;\n\nsub _init\n  {\n  my $self = shift;\n\n  $self->SUPER::_init(@_);\n  $self->{attr_sep} = '=';\n\n  $self;\n  }\n\nmy $vcg_color_by_name = {};\n\nmy $vcg_colors = [\n  white \t=> 'white',\n  blue  \t=> 'blue',\t\n  red \t\t=> 'red',\n  green\t\t=> 'green',\n  yellow\t=> 'yellow',\n  magenta\t=> 'magenta',\n  cyan\t\t=> 'cyan',\n  darkgrey\t=> 'rgb(85,85,85)',\n  darkblue\t=> 'rgb(0,0,128)',\n  darkred\t=> 'rgb(128,0,0)',\n  darkgreen\t=> 'rgb(0,128,0)',\n  darkyellow\t=> 'rgb(128,128,0)',\n  darkmagenta\t=> 'rgb(128,0,128)',\n  darkcyan\t=> 'rgb(0,128,128)',\n  gold\t\t=> 'rgb(255,215,0)',\n  lightgrey\t=> 'rgb(170,170,170)',\n  lightblue\t=> 'rgb(128,128,255)',\n  lightred \t=> 'rgb(255,128,128)',\n  lightgreen    => 'rgb(128,255,128)',\n  lightyellow   => 'rgb(255,255,128)',\n  lightmagenta  => 'rgb(255,128,255)',\n  lightcyan \t=> 'rgb(128,255,255)',\n  lilac \t=> 'rgb(238,130,238)',\n  turquoise \t=> 'rgb(64,224,208)',\n  aquamarine \t=> 'rgb(127,255,212)',\n  khaki \t=> 'rgb(240,230,140)',\n  purple \t=> 'rgb(160,32,240)',\n  yellowgreen \t=> 'rgb(154,205,50)',\n  pink\t\t=> 'rgb(255,192,203)',\n  orange \t=> 'rgb(255,165,0)',\n  orchid\t=> 'rgb(218,112,214)',\n  black \t=> 'black',\n  ];\n\n  {\n  for (my $i = 0; $i < @$vcg_colors; $i+=2)\n    {\n    $vcg_color_by_name->{$vcg_colors->[$i]} = $vcg_colors->[$i+1];\n    }\n  }\n\nsub reset\n  {\n  my $self = shift;\n\n  Graph::Easy::Parser::reset($self, @_);\n\n  my $g = $self->{_graph};\n  $self->{scope_stack} = [];\n\n  $g->{_vcg_color_map} = [];\n  for (my $i = 0; $i < @$vcg_colors; $i+=2)\n    {\n    # set the first 32 colors as the default\n    push @{$g->{_vcg_color_map}}, $vcg_colors->[$i+1];\n    }\n\n  $g->{_vcg_class_names} = {};\n\n  # allow some temp. values during parsing\n  $g->_allow_special_attributes(\n    {\n    edge => {\n      source => [ \"\", undef, '', '', undef, ],\n      target => [ \"\", undef, '', '', undef, ],\n    },\n    } );\n\n  $g->{_warn_on_unknown_attributes} = 1;\n\n  # a hack to support multiline labels\n  $self->{_in_vcg_multi_line_label} = 0;\n\n  # set some default attributes on the graph object, because GDL has\n  # some different defaults as Graph::Easy\n  $g->set_attribute('flow', 'south');\n  $g->set_attribute('edge', 'arrow-style', 'filled');\n  $g->set_attribute('node', 'align', 'left');\n\n  $self;\n  }\n\nsub _vcg_color_map_entry\n  {\n  my ($self, $index, $color) = @_;\n\n  $color =~ /([0-9]+)\\s+([0-9]+)\\s+([0-9]+)/;\n  $self->{_graph}->{_vcg_color_map}->[$index] = \"rgb($1,$2,$3)\";\n  }\n\nsub _unquote\n  {\n  my ($self, $name) = @_;\n\n  $name = '' unless defined $name;\n\n  # \"foo bar\" => foo bar\n  # we need to use \"[ ]\" here, because \"\\s\" also matches 0x0c, and\n  # these color codes need to be kept intact:\n  $name =~ s/^\"[ ]*//; \t\t# remove left-over quotes\n  $name =~ s/[ ]*\"\\z//; \n\n  # unquote special chars\n  $name =~ s/\\\\([\\[\\(\\{\\}\\]\\)#\"])/$1/g;\n\n  $name;\n  }\n\n#############################################################################\n\nsub _match_commented_line\n  {\n  # matches only empty lines\n  qr/^\\s*\\z/;\n  }\n\nsub _match_multi_line_comment\n  {\n  # match a multi line comment\n\n  # /* * comment * */\n  qr#^\\s*/\\*.*?\\*/\\s*#;\n  }\n\nsub _match_optional_multi_line_comment\n  {\n  # match a multi line comment\n\n  # \"/* * comment * */\" or /* a */ /* b */ or \"\"\n  qr#(?:(?:\\s*/\\*.*?\\*/\\s*)*|\\s+)#;\n  }\n\nsub _match_classname\n  {\n  # Return a regexp that matches something like classname 1: \"foo\"\n  my $self = shift;\n\n  qr/^\\s*classname\\s([0-9]+)\\s*:\\s*\"((\\\\\"|[^\"])*)\"/;\n  }\n\nsub _match_node\n  {\n  # Return a regexp that matches a node at the start of the buffer\n  my $self = shift;\n\n  my $attr = $self->_match_attributes();\n\n  # Examples: \"node: { title: \"a\" }\"\n  qr/^\\s*node:\\s*$attr/;\n  }\n\nsub _match_edge\n  {\n  # Matches an edge at the start of the buffer\n  my $self = shift;\n\n  my $attr = $self->_match_attributes();\n\n  # Examples: \"edge: { sourcename: \"a\" targetname: \"b\" }\"\n  #           \"backedge: { sourcename: \"a\" targetname: \"b\" }\"\n  qr/^\\s*(|near|bentnear|back)edge:\\s*$attr/;\n  }\n\nsub _match_single_attribute\n  {\n\n  qr/\\s*(\tenergetic\\s\\w+\t\t\t# \"energetic attraction\" etc.\n\t\t|\n\t\t\\w+ \t\t\t\t# a word\n\t\t|\n\t\tborder\\s(?:x|y)\t\t\t# \"border x\" or \"border y\"\n\t\t|\n\t\tcolorentry\\s+[0-9]{1,2}\t\t# colorentry\n\t)\\s*:\\s*\n    (\n      \"(?:\\\\\"|[^\"])*\"\t\t\t\t# \"foo\"\n    |\n      [0-9]{1,3}\\s+[0-9]{1,3}\\s+[0-9]{1,3}\t# \"128 128 64\" for color entries\n    |\n      \\{[^\\}]+\\}\t\t\t\t# or {..}\n    |\n      [^<][^,\\]\\}\\n\\s;]*\t\t\t# or simple 'fooobar'\n    )\n    \\s*/x;\t\t\t\t\t# possible trailing whitespace\n  }\n\nsub _match_class_attribute\n  {\n  # match something like \"edge.color: 10\"\n\n  qr/\\s*(edge|node)\\.(\\w+)\\s*:\\s*\t# the attribute name (label:\")\n    (\n      \"(?:\\\\\"|[^\"])*\"\t\t# \"foo\"\n    |\n      [^<][^,\\]\\}\\n\\s]*\t\t# or simple 'fooobar'\n    )\n    \\s*/x;\t\t\t# possible whitespace\n  }\n\nsub _match_attributes\n  {\n  # return a regexp that matches something like \" { color=red; }\" and returns\n  # the inner text without the {}\n\n  my $qr_att = _match_single_attribute();\n  my $qr_cmt = _match_multi_line_comment();\n \n  qr/\\s*\\{\\s*((?:$qr_att|$qr_cmt)*)\\s*\\}/;\n  }\n\nsub _match_graph_attribute\n  {\n  # return a regexp that matches something like \" color: red \" for attributes\n  # that apply to a graph/subgraph\n  qr/^\\s*(\n    (\n     colorentry\\s+[0-9]{1,2}:\\s+[0-9]+\\s+[0-9]+\\s+[0-9]+\n     |\n     (?!(node|edge|nearedge|bentnearedge|graph))\t# not one of these\n     \\w+\\s*:\\s*(\"(?:\\\\\"|[^\"])*\"|[^\\n\\s]+)\n    )\n   )([\\n\\s]\\s*|\\z)/x;\n  }\n\nsub _clean_attributes\n  {\n  my ($self,$text) = @_;\n\n  $text =~ s/^\\s*\\{\\s*//;\t\t# remove left-over \"{\" and spaces\n  $text =~ s/\\s*;?\\s*\\}\\s*\\z//;\t\t# remove left-over \"}\" and spaces\n\n  $text;\n  }\n\nsub _match_group_end\n  {\n  # return a regexp that matches something like \" }\" at the beginning\n  qr/^\\s*\\}\\s*/;\n  }\n\nsub _match_group_start\n  {\n  # return a regexp that matches something like \"graph {\" at the beginning\n  qr/^\\s*graph:\\s+\\{\\s*/;\n  }\n\nsub _clean_line\n  { \n  # do some cleanups on a line before handling it\n  my ($self,$line) = @_;\n\n  chomp($line);\n\n  # collapse white space at start\n  $line =~ s/^\\s+//;\n\n  if ($self->{_in_vcg_multi_line_label})\n    {\n    if ($line =~ /\\\"[^\\\"]*\\z/)\n      {\n      # '\"\\n'\n      $self->{_in_vcg_multi_line_label} = 0;\n      # restore the match stack\n      $self->{match_stack} = $self->{_match_stack};\n      delete $self->{_match_stack};\n      }\n    else\n      {\n      # hack: convert \"a\" to \\\"a\\\" to fix faulty inputs\n      $line =~ s/([^\\\\])\\\"/$1\\\\\\\"/g;\n      }\n    }\n  # a line ending in 'label: \"...\\n' means a multi-line label\n  elsif ($line =~ /(^|\\s)label:\\s+\\\"[^\\\"]*\\z/)\n    {\n    $self->{_in_vcg_multi_line_label} = 1;\n    # swap out the match stack since we just wait for the end of the label\n    $self->{_match_stack} = $self->{match_stack};\n    delete $self->{match_stack};\n    }\n\n  $line;\n  }\n\nsub _line_insert\n  {\n  # What to insert between two lines.\n  my ($self) = @_;\n\n  print STDERR \"in multiline\\n\" if $self->{_in_vcg_multi_line_label} && $self->{debug};\n  # multiline labels => '\\n'\n  return '\\\\n' if $self->{_in_vcg_multi_line_label};\n\n  # the default is ' '\n  ' ';\n  }\n\n#############################################################################\n\nsub _new_scope\n  {\n  # create a new scope, with attributes from current scope\n  my ($self, $is_group) = @_;\n\n  my $scope = {};\n\n  if (@{$self->{scope_stack}} > 0)\n    {\n    my $old_scope = $self->{scope_stack}->[-1];\n\n    # make a copy of the old scope's attribtues\n    for my $t (keys %$old_scope)\n      {\n      next if $t =~ /^_/;\n      my $s = $old_scope->{$t};\n      $scope->{$t} = {} unless ref $scope->{$t}; my $sc = $scope->{$t};\n      for my $k (keys %$s)\n        {\n        # skip things like \"_is_group\"\n        $sc->{$k} = $s->{$k} unless $k =~ /^_/;\n        }\n      }\n    }\n  $scope->{_is_group} = 1 if defined $is_group;\n\n  push @{$self->{scope_stack}}, $scope;\n\n  $scope;\n  }\n\nsub _edge_style\n  {\n  # To convert \"--\" or \"->\" we simple do nothing, since the edge style in\n  # VCG can only be set via the attributes (if at all)\n  my ($self, $ed) = @_;\n\n  'solid';\n  }\n\nsub _build_match_stack\n  {\n  my $self = shift;\n\n  my $qr_cn    = $self->_match_classname();\n  my $qr_node  = $self->_match_node();\n  my $qr_cmt   = $self->_match_multi_line_comment();\n  my $qr_ocmt  = $self->_match_optional_multi_line_comment();\n  my $qr_attr  = $self->_match_attributes();\n  my $qr_gatr  = $self->_match_graph_attribute();\n  my $qr_oatr  = $self->_match_optional_attributes();\n  my $qr_edge  = $self->_match_edge();\n  my $qr_class = $self->_match_class_attribute();\n\n  my $qr_group_end   = $self->_match_group_end();\n  my $qr_group_start = $self->_match_group_start();\n\n  # \"graph: {\"\n  $self->_register_handler( $qr_group_start,\n    sub\n      {\n      my $self = shift;\n\n      # the main graph\n      if (@{$self->{scope_stack}} == 0)\n        {\n        print STDERR \"# Parser: found main graph\\n\" if $self->{debug};\n\t$self->{_vcg_graph_name} = 'unnamed'; \n\t$self->_new_scope(1);\n        }\n      else\n\t{\n        print STDERR \"# Parser: found subgraph\\n\" if $self->{debug};\n\t# a new subgraph\n        push @{$self->{group_stack}}, $self->_new_group();\n\t}\n      1;\n      } );\n\n  # graph or subgraph end \"}\"\n  $self->_register_handler( $qr_group_end,\n    sub\n      {\n      my $self = shift;\n\n      print STDERR \"# Parser: found end of (sub-)graph\\n\" if $self->{debug};\n      \n      my $scope = pop @{$self->{scope_stack}};\n      return $self->parse_error(0) if !defined $scope;\n\n      1;\n      } );\n\n  # classname 1: \"foo\"\n  $self->_register_handler( $qr_cn,\n    sub {\n      my $self = shift;\n      my $class = $1; my $name = $2;\n\n      print STDERR \"#  Found classname '$name' for class '$class'\\n\" if $self->{debug} > 1;\n\n      $self->{_graph}->{_vcg_class_names}->{$class} = $name;\n      1;\n      } );\n\n  # node: { ... }\n  $self->_register_handler( $qr_node,\n    sub {\n      my $self = shift;\n      my $att = $self->_parse_attributes($1 || '', 'node', NO_MULTIPLES );\n      return undef unless defined $att;\t\t# error in attributes?\n\n      my $name = $att->{title}; delete $att->{title};\n\n      print STDERR \"#  Found node with name $name\\n\" if $self->{debug} > 1;\n\n      my $node = $self->_new_node($self->{_graph}, $name, $self->{group_stack}, $att, []);\n\n      # set attributes from scope\n      my $scope = $self->{scope_stack}->[-1] || {};\n      $node->set_attributes ($scope->{node}) if keys %{$scope->{node}} != 0;\n\n      # override with local attributes\n      $node->set_attributes ($att) if keys %$att != 0;\n      1;\n      } );\n\n  # \"edge: { ... }\"\n  $self->_register_handler( $qr_edge,\n    sub {\n      my $self = shift;\n      my $type = $1 || 'edge';\n      my $txt = $2 || '';\n      $type = \"edge\" if $type =~ /edge/;\t# bentnearedge => edge\n      my $att = $self->_parse_attributes($txt, 'edge', NO_MULTIPLES );\n      return undef unless defined $att;\t\t# error in attributes?\n\n      my $from = $att->{source}; delete $att->{source};\n      my $to = $att->{target}; delete $att->{target};\n\n      print STDERR \"#  Found edge ($type) from $from to $to\\n\" if $self->{debug} > 1;\n\n      my $edge = $self->{_graph}->add_edge ($from, $to);\n\n      # set attributes from scope\n      my $scope = $self->{scope_stack}->[-1] || {};\n      $edge->set_attributes ($scope->{edge}) if keys %{$scope->{edge}} != 0;\n\n      # override with local attributes\n      $edge->set_attributes ($att) if keys %$att != 0;\n\n      1;\n      } );\n\n  # color: red (for graphs or subgraphs)\n  $self->_register_attribute_handler($qr_gatr, 'parent');\n\n  # edge.color: 10\n  $self->_register_handler( $qr_class,\n    sub {\n      my $self = shift;\n      my $type = $1;\n      my $name = $2;\n      my $val = $3;\n\n      print STDERR \"#  Found color definition $type $name $val\\n\" if $self->{debug} > 2;\n\n      my $att = $self->_remap_attributes( { $name => $val }, $type, $self->_remap());\n\n      # store the attributes in the current scope\n      my $scope = $self->{scope_stack}->[-1];\n      $scope->{$type} = {} unless ref $scope->{$type};\n      my $s = $scope->{$type};\n\n      for my $k (keys %$att)\n        {\n        $s->{$k} = $att->{$k};\n        }\n\n      #$self->{_graph}->set_attributes ($type, $att);\n      1;\n      });\n\n  # remove multi line comments /* comment */\n  $self->_register_handler( $qr_cmt, undef );\n  \n  # remove single line comment // comment\n  $self->_register_handler( qr/^\\s*\\/\\/.*/, undef );\n\n  $self;\n  }\n\nsub _new_node\n  {\n  # add a node to the graph, overridable by subclasses\n  my ($self, $graph, $name, $group_stack, $att, $stack) = @_;\n\n#  print STDERR \"add_node $name\\n\";\n\n  my $node = $graph->node($name);\n \n  if (!defined $node)\n    {\n    $node = $graph->add_node($name);\t\t# add\n\n    # apply attributes from the current scope (only for new nodes)\n    my $scope = $self->{scope_stack}->[-1];\n    return $self->error(\"Scope stack is empty!\") unless defined $scope;\n  \n    my $is_group = $scope->{_is_group};\n    delete $scope->{_is_group};\n    $node->set_attributes($scope->{node});\n    $scope->{_is_group} = $is_group if $is_group;\n\n    my $group = $self->{group_stack}->[-1];\n\n    $node->add_to_group($group) if $group;\n    }\n\n  $node;\n  }\n\n#############################################################################\n# attribute remapping\n\n# undef => drop that attribute\n# not listed attributes are simple copied unmodified\n\nmy $vcg_remap = {\n  'node' => {\n    iconfile => 'x-vcg-iconfile',\n    info1 => 'x-vcg-info1',\n    info2 => 'x-vcg-info2',\n    info3 => 'x-vcg-info3',\n    invisible => \\&_invisible_from_vcg,\n    importance => 'x-vcg-importance',\n    focus => 'x-vcg-focus',\n    margin => 'x-vcg-margin',\n    textmode => \\&_textmode_from_vcg,\n    textcolor => \\&_node_color_from_vcg,\n    color => \\&_node_color_from_vcg,\n    bordercolor => \\&_node_color_from_vcg,\n    level => 'rank',\n    horizontal_order => \\&_horizontal_order_from_vcg,\n    shape => \\&_vcg_node_shape,\n    vertical_order => \\&_vertical_order_from_vcg,\n    },\n\n  'edge' => {\n    anchor => 'x-vcg-anchor',\n    right_anchor => 'x-vcg-right_anchor',\n    left_anchor => 'x-vcg-left_anchor',\n    arrowcolor => 'x-vcg-arrowcolor',\n    arrowsize => 'x-vcg-arrowsize',\n    # XXX remap this\n    arrowstyle => 'x-vcg-arrowstyle',\n    backarrowcolor => 'x-vcg-backarrowcolor',\n    backarrowsize => 'x-vcg-backarrowsize',\n    backarrowstyle => 'x-vcg-backarrowstyle',\n    class => \\&_edge_class_from_vcg,\n    color => \\&_edge_color_from_vcg,\n    horizontal_order => 'x-vcg-horizontal_order',\n    linestyle => 'style',\n    priority => 'x-vcg-priority',\n    source => 'source',\n    sourcename => 'source',\n    target => 'target',\n    targetname => 'target',\n    textcolor => \\&_edge_color_from_vcg,\n    thickness => 'x-vcg-thickness', \t\t# remap to broad etc.\n    },\n\n  'graph' => {\n    color => \\&_node_color_from_vcg,\n    bordercolor => \\&_node_color_from_vcg,\n    textcolor => \\&_node_color_from_vcg,\n\n    x => 'x-vcg-x',\n    y => 'x-vcg-y',\n    xmax => 'x-vcg-xmax',\n    ymax => 'x-vcg-ymax',\n    xspace => 'x-vcg-xspace',\n    yspace => 'x-vcg-yspace',\n    xlspace => 'x-vcg-xlspace',\n    ylspace => 'x-vcg-ylspace',\n    xbase => 'x-vcg-xbase',\n    ybase => 'x-vcg-ybase',\n    xlraster => 'x-vcg-xlraster',\n    xraster => 'x-vcg-xraster',\n    yraster => 'x-vcg-yraster',\n\n    amax => 'x-vcg-amax',\n    bmax => 'x-vcg-bmax',\n    cmax => 'x-vcg-cmax',\n    cmin => 'x-vcg-cmin',\n    smax => 'x-vcg-smax',\n    pmax => 'x-vcg-pmax',\n    pmin => 'x-vcg-pmin',\n    rmax => 'x-vcg-rmax',\n    rmin => 'x-vcg-rmin',\n\n    splines => 'x-vcg-splines',\n    focus => 'x-vcg-focus',\n    hidden => 'x-vcg-hidden',\n    horizontal_order => 'x-vcg-horizontal_order',\n    iconfile => 'x-vcg-iconfile',\n    inport_sharing => \\&_inport_sharing_from_vcg,\n    importance => 'x-vcg-importance',\n    ignore_singles => 'x-vcg-ignore_singles',\n    invisible => 'x-vcg-invisible',\n    info1 => 'x-vcg-info1',\n    info2 => 'x-vcg-info2',\n    info3 => 'x-vcg-info3',\n    infoname1 => 'x-vcg-infoname1',\n    infoname2 => 'x-vcg-infoname2',\n    infoname3 => 'x-vcg-infoname3',\n    level => 'x-vcg-level',\n    loc => 'x-vcg-loc',\n    layout_algorithm => 'x-vcg-layout_algorithm',\n    # also allow this variant:\n    layoutalgorithm => 'x-vcg-layout_algorithm',\n    layout_downfactor => 'x-vcg-layout_downfactor',\n    layout_upfactor => 'x-vcg-layout_upfactor',\n    layout_nearfactor => 'x-vcg-layout_nearfactor',\n    linear_segments => 'x-vcg-linear_segments',\n    margin => 'x-vcg-margin',\n    manhattan_edges => \\&_manhattan_edges_from_vcg,\n    near_edges => 'x-vcg-near_edges',\n    nearedges => 'x-vcg-nearedges',\n    node_alignment => 'x-vcg-node_alignment',\n    port_sharing => \\&_port_sharing_from_vcg,\n    priority_phase => 'x-vcg-priority_phase',\n    outport_sharing => \\&_outport_sharing_from_vcg,\n    shape => 'x-vcg-shape',\n    smanhattan_edges => 'x-vcg-smanhattan_edges',\n    state => 'x-vcg-state',\n    splines => 'x-vcg-splines',\n    splinefactor => 'x-vcg-splinefactor',\n    spreadlevel => 'x-vcg-spreadlevel',\n\n    title => 'label',\n    textmode => \\&_textmode_from_vcg,\n    useractioncmd1 => 'x-vcg-useractioncmd1',\n    useractioncmd2 => 'x-vcg-useractioncmd2',\n    useractioncmd3 => 'x-vcg-useractioncmd3',\n    useractioncmd4 => 'x-vcg-useractioncmd4',\n    useractionname1 => 'x-vcg-useractionname1',\n    useractionname2 => 'x-vcg-useractionname2',\n    useractionname3 => 'x-vcg-useractionname3',\n    useractionname4 => 'x-vcg-useractionname4',\n    vertical_order => 'x-vcg-vertical_order',\n\n    display_edge_labels => 'x-vcg-display_edge_labels',\n    edges => 'x-vcg-edges',\n    nodes => 'x-vcg-nodes',\n    icons => 'x-vcg-icons',\n    iconcolors => 'x-vcg-iconcolors',\n    view => 'x-vcg-view',\n    subgraph_labels => 'x-vcg-subgraph_labels',\n    arrow_mode => 'x-vcg-arrow_mode',\n    arrowmode => 'x-vcg-arrowmode',\n    crossing_optimization => 'x-vcg-crossing_optimization',\n    crossing_phase2 => 'x-vcg-crossing_phase2',\n    crossing_weight => 'x-vcg-crossing_weight',\n    equal_y_dist => 'x-vcg-equal_y_dist',\n    equalydist => 'x-vcg-equalydist',\n    finetuning => 'x-vcg-finetuning',\n    fstraight_phase => 'x-vcg-fstraight_phase',\n    straight_phase => 'x-vcg-straight_phase',\n    import_sharing => 'x-vcg-import_sharing',\n    late_edge_labels => 'x-vcg-late_edge_labels',\n    treefactor => 'x-vcg-treefactor',\n    orientation => \\&_orientation_from_vcg,\n\n    attraction => 'x-vcg-attraction',\n    'border x' => 'x-vcg-border-x',\n    'border y' => 'x-vcg-border-y',\n    'energetic' => 'x-vcg-energetic',\n    'energetic attraction' => 'x-vcg-energetic-attraction',\n    'energetic border' => 'x-vcg-energetic-border',\n    'energetic crossing' => 'x-vcg-energetic-crossing',\n    'energetic gravity' => 'x-vcg-energetic gravity',\n    'energetic overlapping' => 'x-vcg-energetic overlapping',\n    'energetic repulsion' => 'x-vcg-energetic repulsion',\n    fdmax => 'x-vcg-fdmax',\n    gravity => 'x-vcg-gravity',\n\n    magnetic_field1 => 'x-vcg-magnetic_field1',\n    magnetic_field2 => 'x-vcg-magnetic_field2',\n    magnetic_force1 => 'x-vcg-magnetic_force1',\n    magnetic_force2 => 'x-vcg-magnetic_force2',\n    randomfactor => 'x-vcg-randomfactor',\n    randomimpulse => 'x-vcg-randomimpulse',\n    randomrounds => 'x-vcg-randomrounds',\n    repulsion => 'x-vcg-repulsion',\n    tempfactor => 'x-vcg-tempfactor',\n    tempmax => 'x-vcg-tempmax',\n    tempmin => 'x-vcg-tempmin'.\n    tempscheme => 'x-vcg-tempscheme'.\n    temptreshold => 'x-vcg-temptreshold',\n\n    dirty_edge_labels => 'x-vcg-dirty_edge_labels',\n    fast_icons => 'x-vcg-fast_icons',\n\n    },\n\n  'group' => {\n    # graph attributes will be added here automatically\n    title => \\&_group_name_from_vcg,\n    status => 'x-vcg-status',\n    },\n\n  'all' => {\n    loc => 'x-vcg-loc',\n    folding => 'x-vcg-folding',\n    scaling => 'x-vcg-scaling',\n    shrink => 'x-vcg-shrink',\n    stretch => 'x-vcg-stretch',\n    width => 'x-vcg-width',\n    height => 'x-vcg-height',\n    fontname => 'font',\n    },\n  };\n\n  {\n  # add all graph attributes to group, too\n  my $group = $vcg_remap->{group};\n  my $graph = $vcg_remap->{graph};\n  for my $k (keys %$graph)\n    {\n    $group->{$k} = $graph->{$k};\n    }\n  }\n\nsub _remap { $vcg_remap; }\n\nmy $vcg_edge_color_remap = {\n  textcolor => 'labelcolor',\n  };\n\nmy $vcg_node_color_remap = {\n  textcolor => 'color',\n  color => 'fill',\n  };\n\nsub _vertical_order_from_vcg\n  {\n  # remap \"vertical_order: 5\" to \"rank: 5\"\n  my ($graph, $name, $value) = @_;\n\n  my $rank = $value;\n  # insert a really really high rank\n  $rank = '1000000' if $value eq 'maxdepth';\n\n  # save the original value, too\n  ('x-vcg-vertical_order', $value, 'rank', $rank);\n  }\n\nsub _horizontal_order_from_vcg\n  {\n  # remap \"horizontal_order: 5\" to \"rank: 5\"\n  my ($graph, $name, $value) = @_;\n\n  my $rank = $value;\n  # insert a really really high rank\n  $rank = '1000000' if $value eq 'maxdepth';\n\n  # save the original value, too\n  ('x-vcg-horizontal_order', $value, 'rank', $rank);\n  }\n\nsub _invisible_from_vcg\n  {\n  # remap \"invisible: yes\" to \"shape: invisible\"\n  my ($graph, $name, $value) = @_;\n\n  return (undef,undef) if $value ne 'yes';\n\n  ('shape', 'invisible');\n  }\n\nsub _manhattan_edges_from_vcg\n  {\n  # remap \"manhattan_edges: yes\" for graphs\n  my ($graph, $name, $value) = @_;\n\n  if ($value eq 'yes')\n    {\n    $graph->set_attribute('edge','start','front');\n    $graph->set_attribute('edge','end','back');\n    }\n  # store the value for proper VCG output\n  ('x-vcg-' . $name, $value);\n  }\n\nsub _textmode_from_vcg\n  {\n  # remap \"textmode: left_justify\" to \"align: left;\"\n  my ($graph, $name, $align) = @_;\n\n  $align =~ s/_.*//;\t# left_justify => left\t\n\n  ('align', lc($align));\n  }\n\nsub _edge_color_from_vcg\n  {\n  # remap \"darkyellow\" to \"rgb(128 128 0)\"\n  my ($graph, $name, $color) = @_;\n\n#  print STDERR \"edge $name $color\\n\";\n#  print STDERR ($vcg_edge_color_remap->{$name} || $name, \" \", $vcg_color_by_name->{$color} || $color), \"\\n\";\n\n  my $c = $vcg_color_by_name->{$color} || $color;\n  $c = $graph->{_vcg_color_map}->[$c] if $c =~ /^[0-9]+\\z/ && $c < 256;\n\n  ($vcg_edge_color_remap->{$name} || $name, $c);\n  }\n\nsub _edge_class_from_vcg\n  {\n  # remap \"1\" to \"edgeclass1\" to create a valid class name\n  my ($graph, $name, $class) = @_;\n\n  $class = $graph->{_vcg_class_names}->{$class} || ('edgeclass' . $class) if $class =~ /^[0-9]+\\z/;\n  #$class = 'edgeclass' . $class if $class !~ /^[a-zA-Z]/;\n\n  ('class', $class);\n  }\n\nmy $vcg_orientation = {\n  top_to_bottom => 'south',\n  bottom_to_top => 'north',\n  left_to_right => 'east',\n  right_to_left => 'west',\n  };\n\nsub _orientation_from_vcg\n  {\n  my ($graph, $name, $value) = @_;\n\n  ('flow', $vcg_orientation->{$value} || 'south');\n  }\n\nsub _port_sharing_from_vcg\n  {\n  # if we see this, add autojoin/autosplit\n  my ($graph, $name, $value) = @_;\n\n  $value = ($value =~ /yes/i) ? 'yes' : 'no';\n \n  ('autojoin', $value, 'autosplit', $value);\n  }\n\nsub _inport_sharing_from_vcg\n  {\n  # if we see this, add autojoin/autosplit\n  my ($graph, $name, $value) = @_;\n\n  $value = ($value =~ /yes/i) ? 'yes' : 'no';\n \n  ('autojoin', $value);\n  }\n\nsub _outport_sharing_from_vcg\n  {\n  # if we see this, add autojoin/autosplit\n  my ($graph, $name, $value) = @_;\n\n  $value = ($value =~ /yes/i) ? 'yes' : 'no';\n \n  ('autosplit', $value);\n  }\n\nsub _node_color_from_vcg\n  {\n  # remap \"darkyellow\" to \"rgb(128 128 0)\"\n  my ($graph, $name, $color) = @_;\n\n  my $c = $vcg_color_by_name->{$color} || $color;\n  $c = $graph->{_vcg_color_map}->[$c] if $c =~ /^[0-9]+\\z/ && $c < 256;\n\n  ($vcg_node_color_remap->{$name} || $name, $c);\n  }\n\nmy $shapes = {\n  box => 'rect',\n  rhomb => 'diamond',\n  triangle => 'triangle',\n  ellipse => 'ellipse',\n  circle => 'circle',\n  hexagon => 'hexagon',\n  trapeze => 'trapezium',\n  uptrapeze => 'invtrapezium',\n  lparallelogram => 'invparallelogram',\n  rparallelogram => 'parallelogram',\n  };\n\nsub _vcg_node_shape\n  {\n  my ($self, $name, $shape) = @_;\n\n  my @rc;\n  my $s = lc($shape);\n\n  # map the name to what Graph::Easy expects (ellipse stays as ellipse but\n  # everything unknown gets converted to rect)\n  $s = $shapes->{$s} || 'rect';\n\n  (@rc, $name, $s);\n  }\n\nsub _group_name_from_vcg\n  {\n  my ($self, $attr, $name, $object) = @_;\n\n  print STDERR \"# Renaming anon group '$object->{name}' to '$name'\\n\"\n\tif $self->{debug} > 0;\n\n  $self->rename_group($object, $name);\n\n  # name was set, so drop the \"title: name\" pair\n  (undef, undef);\n  }\n\n#############################################################################\n\nsub _remap_attributes\n  {\n  my ($self, $att, $object, $r) = @_;\n\n#  print STDERR \"# Remapping attributes\\n\";\n#    use Data::Dumper; print Dumper($att);\n\n  # handle the \"colorentry 00\" entries:\n  for my $key (keys %$att)\n    {\n    if ($key =~ /^colorentry\\s+([0-9]{1,2})/)\n      {\n      # put the color into the current color map\n      $self->_vcg_color_map_entry($1, $att->{$key});\n      delete $att->{$key};\n      next; \n      }\n\n    # remap \\fi065 to 'A'\n    $att->{$key} =~ s/(\\x0c|\\\\f)i([0-9]{3})/ decode('iso-8859-1', chr($2)); /eg;\n\n    # XXX TDOO: support inline colorations\n    # remap \\f65 to ''\n    $att->{$key} =~ s/(\\x0c|\\\\f)([0-9]{2})//g;\n\n    # remap \\c09 to color 09: TODO for now remove\n    $att->{$key} =~ s/(\\x0c|\\\\f)([0-9]{2})//g;\n\n    # XXX TODO: support real hor lines\n    # insert a fake <HR>\n    $att->{$key} =~ s/(\\x0c|\\\\f)-/\\\\c ---- \\\\n /g;\n\n    }\n  $self->SUPER::_remap_attributes($att,$object,$r);\n  }\n\n#############################################################################\n\nsub _parser_cleanup\n  {\n  # After initial parsing, do cleanup.\n  my ($self) = @_;\n\n  my $g = $self->{_graph};\n  $g->{_warn_on_unknown_attributes} = 0;\t# reset to die again\n\n  delete $g->{_vcg_color_map};\n  delete $g->{_vcg_class_names};\n\n  $self;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Parser::VCG - Parse VCG or GDL text into Graph::Easy\n\n=head1 SYNOPSIS\n\n        # creating a graph from a textual description\n\n        use Graph::Easy::Parser::VCG;\n        my $parser = Graph::Easy::Parser::VCG->new();\n\n        my $graph = $parser->from_text(\n                \"graph: { \\n\" .\n\t \t\"\tnode: { title: \"Bonn\" }\\n\" .\n\t \t\"\tnode: { title: \"Berlin\" }\\n\" .\n\t \t\"\tedge: { sourcename: \"Bonn\" targetname: \"Berlin\" }\\n\" .\n\t\t\"}\\n\"\n        );\n        print $graph->as_ascii();\n\n\tprint $parser->from_file('mygraph.vcg')->as_ascii();\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Parser::VCG> parses the text format from the VCG or GDL\n(Graph Description Language) use by tools like GCC and AiSee, and\nconstructs a C<Graph::Easy> object from it.\n\nThe resulting object can then be used to layout and output the graph\nin various formats.\n\n=head2 Output\n\nThe output will be a L<Graph::Easy|Graph::Easy> object (unless overrriden\nwith C<use_class()>), see the documentation for Graph::Easy what you can do\nwith it.\n\n=head2 Attributes\n\nAttributes will be remapped to the proper Graph::Easy attribute names and\nvalues, as much as possible.\n\nAnything else will be converted to custom attributes starting with \"x-vcg-\".\nSo \"dirty_edge_labels: yes\" will become \"x-vcg-dirty_edge_labels: yes\".\n\n=head1 METHODS\n\nC<Graph::Easy::Parser::VCG> supports the same methods\nas its parent class C<Graph::Easy::Parser>:\n\n=head2 new()\n\n\tuse Graph::Easy::Parser::VCG;\n\tmy $parser = Graph::Easy::Parser::VCG->new();\n\nCreates a new parser object. There are two valid parameters:\n\n\tdebug\n\tfatal_errors\n\nBoth take either a false or a true value.\n\n\tmy $parser = Graph::Easy::Parser::VCG->new( debug => 1 );\n\t$parser->from_text('graph: { }');\n\n=head2 reset()\n\n\t$parser->reset();\n\nReset the status of the parser, clear errors etc. Automatically called\nwhen you call any of the C<from_XXX()> methods below.\n\n=head2 use_class()\n\n\t$parser->use_class('node', 'Graph::Easy::MyNode');\n\nOverride the class to be used to constructs objects while parsing.\n\nSee L<Graph::Easy::Parser> for further information.\n\n=head2 from_text()\n\n\tmy $graph = $parser->from_text( $text );\n\nCreate a L<Graph::Easy|Graph::Easy> object from the textual description in C<$text>.\n\nReturns undef for error, you can find out what the error was\nwith L<error()>.\n\nThis method will reset any previous error, and thus the C<$parser> object\ncan be re-used to parse different texts by just calling C<from_text()>\nmultiple times.\n\n=head2 from_file()\n\n\tmy $graph = $parser->from_file( $filename );\n\tmy $graph = Graph::Easy::Parser::VCG->from_file( $filename );\n\nCreates a L<Graph::Easy|Graph::Easy> object from the textual description in the file\nC<$filename>.\n\nThe second calling style will create a temporary parser object,\nparse the file and return the resulting C<Graph::Easy> object.\n\nReturns undef for error, you can find out what the error was\nwith L<error()> when using the first calling style.\n\n=head2 error()\n\n\tmy $error = $parser->error();\n\nReturns the last error, or the empty string if no error occured.\n\n=head2 parse_error()\n\n\t$parser->parse_error( $msg_nr, @params);\n\nSets an error message from a message number and replaces embedded\ntemplates like C<##param1##> with the passed parameters.\n\n=head1 CAVEATS\n\nThe parser has problems with the following things:\n\n=over 12\n\n=item attributes\n\nSome attributes are B<not> remapped properly to what Graph::Easy expects, thus\nlosing information, either because Graph::Easy doesn't support this feature\nyet, or because the mapping is incomplete.\n\n=item comments\n\nComments written in the source code itself are discarded. If you want to have\ncomments on the graph, clusters, nodes or edges, use the attribute C<comment>.\nThese are correctly read in and stored, and then output into the different\nformats, too.\n\n=back\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>, L<Graph::Write::VCG>.\n\n=head1 AUTHOR\n\nCopyright (C) 2005 - 2008 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n\n",
  "Graph/Easy/Parser.pm": "#############################################################################\n# Parse text definition into a Graph::Easy object\n#\n#############################################################################\n\npackage Graph::Easy::Parser;\n\nuse Graph::Easy;\n\n$VERSION = '0.35';\nuse Graph::Easy::Base;\n@ISA = qw/Graph::Easy::Base/;\nuse Scalar::Util qw/weaken/;\n\nuse strict;\nuse constant NO_MULTIPLES => 1;\n\nsub _init\n  {\n  my ($self,$args) = @_;\n\n  $self->{error} = '';\n  $self->{debug} = 0;\n  $self->{fatal_errors} = 1;\n  \n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(debug|fatal_errors)\\z/)\n      {\n      require Carp;\n      my $class = ref($self);\n      Carp::confess (\"Invalid argument '$k' passed to $class\" . '->new()');\n      }\n    $self->{$k} = $args->{$k};\n    }\n\n  # what to replace the matched text with\n  $self->{replace} = '';\n  $self->{attr_sep} = ':';\n  # An optional regexp to remove parts of an autosplit label, used by Graphviz\n  # to remove \" <p1> \":\n  $self->{_qr_part_clean} = undef;\n\n  # setup default class names for generated objects\n  $self->{use_class} = {\n    edge  => 'Graph::Easy::Edge',\n    group => 'Graph::Easy::Group',\n    graph => 'Graph::Easy',\n    node  => 'Graph::Easy::Node',\n  };\n\n  $self;\n  }\n\nsub reset\n  {\n  # reset the status of the parser, clear errors etc.\n  my $self = shift;\n\n  $self->{error} = '';\n  $self->{anon_id} = 0;\n  $self->{cluster_id} = '';\t\t# each cluster gets a unique ID\n  $self->{line_nr} = -1;\n  $self->{match_stack} = [];\t\t# patterns and their handlers\n\n  $self->{clusters} = {};\t\t# cluster names we already created\n\n  Graph::Easy::Base::_reset_id();\t# start with the same set of IDs\n  \n  # After \"[ 1 ] -> [ 2 ]\" we push \"2\" on the stack and when we encounter\n  # \" -> [ 3 ]\" treat the stack as a node-list left of \"3\".\n  # In addition, for \" [ 1 ], [ 2 ] => [ 3 ]\", the stack will contain\n  # \"1\" and \"2\" when we encounter \"3\".\n  $self->{stack} = [];\n\n  $self->{group_stack} = [];\t# all the (nested) groups we are currently in\n  $self->{left_stack} = [];\t# stack for the left side for \"[]->[],[],...\"\n  $self->{left_edge} = undef;\t# for -> [A], [B] continuations\n\n  Graph::Easy->_drop_special_attributes();\n\n  $self->{_graph} = $self->{use_class}->{graph}->new( {\n      debug => $self->{debug},\n      strict => 0,\n      fatal_errors => $self->{fatal_errors},\n    } );\n\n  $self;\n  }\n\nsub from_file\n  {\n  # read in entire file and call from_text() on the contents\n  my ($self,$file) = @_;\n\n  $self = $self->new() unless ref $self;\n\n  my $doc;\n  local $/ = undef;\t\t\t# slurp mode\n  # if given a reference, assume it is a glob, or something like that\n  if (ref($file))\n    {\n    binmode $file, ':utf8' or die (\"binmode '$file', ':utf8' failed: $!\");\n    $doc = <$file>;\n    }\n  else\n    {\n    open my $PARSER_FILE, $file or die (ref($self).\": Cannot read $file: $!\");\n    binmode $PARSER_FILE, ':utf8' or die (\"binmode '$file', ':utf8' failed: $!\");\n    $doc = <$PARSER_FILE>;\t\t# read entire file\n    close $PARSER_FILE;\n    }\n\n  $self->from_text($doc);\n  }\n\nsub use_class\n  {\n  # use the provided class for generating objects of the type $object\n  my ($self, $object, $class) = @_;\n\n  $self->_croak(\"Expected one of node, edge, group or graph, but got $object\")\n    unless $object =~ /^(node|group|graph|edge)\\z/;\n\n  $self->{use_class}->{$object} = $class;\n\n  $self;  \n  }\n\nsub _register_handler\n  {\n  # register a pattern and a handler for it\n  my $self = shift;\n\n  push @{$self->{match_stack}}, [ @_ ];\n\n  $self;\n  }\n\nsub _register_attribute_handler\n  {\n  # register a handler for attributes like \"{ color: red; }\"\n  my ($self, $qr_attr, $target) = @_;\n\n  # $object is either undef (for Graph::Easy, meaning \"node\", or \"parent\" for Graphviz)\n\n  # { attributes }\n  $self->_register_handler( qr/^$qr_attr/,\n    sub\n      {\n      my $self = shift;\n      # This happens in the case of \"[ Test ]\\n { ... }\", the node is consumed\n      # first, and the attributes are left over:\n\n      my $stack = $self->{stack}; $stack = $self->{group_stack} if @{$self->{stack}} == 0;\n\n      my $object = $target;\n      if ($target && $target eq 'parent')\n        {\n        # for Graphviz, stray attributes always apply to the parent\n        $stack = $self->{group_stack};\n\n        $object = $stack->[-1] if ref $stack;\n        if (!defined $object)\n          {\n          # try the scope stack next:\n          $stack = $self->{scope_stack};\n\t  $object = $self->{_graph};\n          if (!$stack || @$stack <= 1)\n\t    {\n\t    $object = $self->{_graph};\n\t    $stack = [ $self->{_graph} ];\n\t    }\n          }\n        }\n      my ($a, $max_idx) = $self->_parse_attributes($1||'', $object);\n      return undef if $self->{error};\t# wrong attributes or empty stack?\n\n      if (ref($stack->[-1]) eq 'HASH')\n\t{\n\t# stack is a scope stack\n\t# XXX TODO: Find out wether the attribute goes to graph, node or edge\n\tfor my $k (keys %$a)\n\t  {\n\t  $stack->[-1]->{graph}->{$k} = $a->{$k};\n\t  }\n\treturn 1;\n\t}\n\n      print STDERR \"max_idx = $max_idx, stack contains \", join (\" , \", @$stack),\"\\n\"\n\tif $self->{debug} && $self->{debug} > 1;\n      if ($max_idx != 1)\n\t{\n\tmy $i = 0;\n        for my $n (@$stack)\n\t  {\n\t  $n->set_attributes($a, $i++);\n\t  }\n\t}\n      else\n\t{\n        # set attributes on all nodes/groups on stack\n        for my $n (@$stack) { $n->set_attributes($a); }\n\t}\n      # This happens in the case of \"[ a | b ]\\n { ... }\", the node is consumed\n      # first, and the attributes are left over. And if we encounter a basename\n      # attribute here, the node-parts will already have been created with the\n      # wrong basename, so correct this:\n      if (defined $a->{basename})\n        {\n        for my $s (@$stack)\n          {\n          # for every node on the stack that is the primary one\n          $self->_set_new_basename($s, $a->{basename}) if exists $s->{autosplit_parts};\n          }\n        }\n      1;\n      } );\n  }\n\nsub _register_node_attribute_handler\n  {\n  # register a handler for attributes like \"[ A ] { ... }\"\n  my ($self, $qr_node, $qr_oatr) = @_;\n\n  $self->_register_handler( qr/^$qr_node$qr_oatr/,\n    sub\n      {\n      my $self = shift;\n      my $n1 = $1;\n      my $a1 = $self->_parse_attributes($2||'');\n      return undef if $self->{error};\n \n      $self->{stack} = [ $self->_new_node ($self->{_graph}, $n1, $self->{group_stack}, $a1) ];\n\n      # forget left stack\n      $self->{left_edge} = undef;\n      $self->{left_stack} = [];\n      1;\n      } );\n  }\n\nsub _new_group\n  {\n  # create a new (possible anonymous) group\n  my ($self, $name) = @_;\n\n  $name = '' unless defined $name;\n\n  my $gr = $self->{use_class}->{group};\n\n  my $group;\n\n  if ($name eq '')\n    {\n    print STDERR \"# Creating new anon group.\\n\" if $self->{debug};\n    $gr .= '::Anon';\n    $group = $gr->new();\n    }\n  else\n    {\n    $name = $self->_unquote($name);\n    print STDERR \"# Creating new group '$name'.\\n\" if $self->{debug};\n    $group = $gr->new( name => $name );\n    }\n\n  $self->{_graph}->add_group($group);\n\n  my $group_stack = $self->{group_stack};\n  if (@$group_stack > 0)\n    {\n    $group->set_attribute('group', $group_stack->[-1]->{name});\n    }\n\n  $group;\n  }\n\nsub _add_group_match\n  {\n  # register two handlers for group start/end\n  my $self = shift;\n\n  my $qr_group_start = $self->_match_group_start();\n  my $qr_group_end   = $self->_match_group_end();\n  my $qr_oatr  = $self->_match_optional_attributes();\n\n  # \"( group start [\" or empty group like \"( Group )\"\n  $self->_register_handler( qr/^$qr_group_start/,\n    sub\n      {\n      my $self = shift;\n      my $graph = $self->{_graph};\n\n      my $end = $2; $end = '' unless defined $end;\n\n      # repair the start of the next node/group\n      $self->{replace} = '[' if $end eq '[';\n      $self->{replace} = '(' if $end eq '(';\n\n      # create the new group\n      my $group = $self->_new_group($1);\n\n      if ($end eq ')')\n        {\n        # we matched an empty group like \"()\", or \"( group name )\"\n        $self->{stack} = [ $group ]; \n         print STDERR \"# Seen end of group '$group->{name}'.\\n\" if $self->{debug};\n        }\n      else\n        {\n\t# only put the group on the stack if it is still open\n        push @{$self->{group_stack}}, $group;\n        }\n\n      1;\n      } );\n\n  # \") { }\" # group end (with optional attributes)\n  $self->_register_handler( qr/^$qr_group_end$qr_oatr/,\n    sub\n      {\n      my $self = shift;\n\n      my $group = pop @{$self->{group_stack}};\n      return $self->parse_error(0) if !defined $group;\n\n      print STDERR \"# Seen end of group '$group->{name}'.\\n\" if $self->{debug};\n\n      my $a1 = $self->_parse_attributes($1||'', 'group', NO_MULTIPLES);\n      return undef if $self->{error};\n\n      $group->set_attributes($a1);\n\n      # the new left side is the group itself\n      $self->{stack} = [ $group ];\n      1;\n      } );\n\n  }\n\nsub _build_match_stack\n  {\n  # put all known patterns and their handlers on the match stack\n  my $self = shift;\n\n  # regexps for the different parts\n  my $qr_node  = $self->_match_node();\n  my $qr_attr  = $self->_match_attributes();\n  my $qr_oatr  = $self->_match_optional_attributes();\n  my $qr_edge  = $self->_match_edge();\n  my $qr_comma = $self->_match_comma();\n  my $qr_class = $self->_match_class_selector();\n\n  my $e = $self->{use_class}->{edge};\n\n  # node { color: red; } \n  # node.graph { ... }\n  # .foo { ... }\n  # .foo, node, edge.red { ... }\n  $self->_register_handler( qr/^\\s*$qr_class$qr_attr/,\n    sub\n      {\n      my $self = shift;\n      my $class = lc($1 || '');\n      my $att = $self->_parse_attributes($2 || '', $class, NO_MULTIPLES );\n\n      return undef unless defined $att;\t\t# error in attributes?\n\n      my $graph = $self->{_graph};\n      $graph->set_attributes ( $class, $att);\n\n      # forget stacks\n      $self->{stack} = [];\n      $self->{left_edge} = undef;\n      $self->{left_stack} = [];\n      1;\n      } );\n\n  $self->_add_group_match();\n\n  $self->_register_attribute_handler($qr_attr);\n  $self->_register_node_attribute_handler($qr_node,$qr_oatr);\n\n  # , [ Berlin ] { color: red; }\n  $self->_register_handler( qr/^$qr_comma$qr_node$qr_oatr/,\n    sub\n      {\n      my $self = shift;\n      my $graph = $self->{_graph};\n      my $n1 = $1;\n      my $a1 = $self->_parse_attributes($2||'');\n      return undef if $self->{error};\n\n      push @{$self->{stack}}, \n        $self->_new_node ($graph, $n1, $self->{group_stack}, $a1, $self->{stack});\n\n      if (defined $self->{left_edge})\n\t{\n\tmy ($style, $edge_label, $edge_atr, $edge_bd, $edge_un) = @{$self->{left_edge}};\n\n\tforeach my $node (@{$self->{left_stack}})\n          {\n\t  my $edge = $e->new( { style => $style, name => $edge_label } );\n\t  $edge->set_attributes($edge_atr);\n\t  # \"<--->\": bidirectional\n\t  $edge->bidirectional(1) if $edge_bd;\n\t  $edge->undirected(1) if $edge_un;\n\t  $graph->add_edge ( $node, $self->{stack}->[-1], $edge );\n          }\n\t}\n      1;\n      } );\n\n  # Things like \"[ Node ]\" will be consumed before, so we do not need a case\n  # for \"[ A ] -> [ B ]\":\n  # node chain continued like \"-> { ... } [ Kassel ] { ... }\"\n  $self->_register_handler( qr/^$qr_edge$qr_oatr$qr_node$qr_oatr/,\n    sub\n      {\n      my $self = shift;\n\n      return if @{$self->{stack}} == 0;\t# only match this if stack non-empty\n\n      my $graph = $self->{_graph};\n      my $eg = $1;\t\t\t\t\t# entire edge (\"-- label -->\" etc)\n\n      my $edge_bd = $2 || $4;\t\t\t\t# bidirectional edge ('<') ?\n      my $edge_un = 0;\t\t\t\t\t# undirected edge?\n      $edge_un = 1 if !defined $2 && !defined $5;\n\n      # optional edge label\n      my $edge_label = $7;\n      my $ed = $3 || $5 || $1;\t\t\t\t# edge pattern/style (\"--\")\n\n      my $edge_atr = $11 || '';\t\t\t\t# save edge attributes\n\n      my $n = $12;\t\t\t\t\t# node name\n      my $a1 = $self->_parse_attributes($13||'');\t# node attributes\n\n      $edge_atr = $self->_parse_attributes($edge_atr, 'edge');\n      return undef if $self->{error};\n\n      # allow undefined edge labels for setting them from the class\n      # strip trailing spaces and convert \\[ => [\n      $edge_label = $self->_unquote($edge_label) if defined $edge_label;\n      # strip trailing spaces\n      $edge_label =~ s/\\s+\\z// if defined $edge_label;\n\n      # the right side node(s) (multiple in case of autosplit)\n      my $nodes_b = [ $self->_new_node ($self->{_graph}, $n, $self->{group_stack}, $a1) ];\n\n      my $style = $self->_link_lists( $self->{stack}, $nodes_b,\n\t$ed, $edge_label, $edge_atr, $edge_bd, $edge_un);\n\n      # remember the left side\n      $self->{left_edge} = [ $style, $edge_label, $edge_atr, $edge_bd, $edge_un ];\n      $self->{left_stack} = $self->{stack};\n\n      # forget stack and remember the right side instead\n      $self->{stack} = $nodes_b;\n      1;\n      } );\n\n  my $qr_group_start = $self->_match_group_start();\n\n  # Things like \")\" will be consumed before, so we do not need a case\n  # for \") -> { ... } ( Group [ B ]\":\n  # edge to a group like \"-> { ... } ( Group [\"\n  $self->_register_handler( qr/^$qr_edge$qr_oatr$qr_group_start/,\n    sub\n      {\n      my $self = shift;\n\n      return if @{$self->{stack}} == 0;\t# only match this if stack non-empty\n\n      my $eg = $1;\t\t\t\t\t# entire edge (\"-- label -->\" etc)\n\n      my $edge_bd = $2 || $4;\t\t\t\t# bidirectional edge ('<') ?\n      my $edge_un = 0;\t\t\t\t\t# undirected edge?\n      $edge_un = 1 if !defined $2 && !defined $5;\n\n      # optional edge label\n      my $edge_label = $7;\n      my $ed = $3 || $5 || $1;\t\t\t\t# edge pattern/style (\"--\")\n\n      my $edge_atr = $11 || '';\t\t\t\t# save edge attributes\n\n      my $gn = $12; \n      # matched \"-> ( Group [\" or \"-> ( Group (\"\n      $self->{replace} = '[' if defined $13 && $13 eq '[';\n      $self->{replace} = '(' if defined $13 && $13 eq '(';\n\n      $edge_atr = $self->_parse_attributes($edge_atr, 'edge');\n      return undef if $self->{error};\n\n      # get the last group of the stack, lest the new one gets nested in it\n      pop @{$self->{group_stack}};\n\n      $self->{group_stack} = [ $self->_new_group($gn) ];\n\n      # allow undefined edge labels for setting them from the class\n      $edge_label = $self->_unquote($edge_label) if $edge_label;\n      # strip trailing spaces\n      $edge_label =~ s/\\s+\\z// if $edge_label;\n\n      my $style = $self->_link_lists( $self->{stack}, $self->{group_stack},\n\t$ed, $edge_label, $edge_atr, $edge_bd, $edge_un);\n\n      # remember the left side\n      $self->{left_edge} = [ $style, $edge_label, $edge_atr, $edge_bd, $edge_un ];\n      $self->{left_stack} = $self->{stack};\n      # forget stack\n      $self->{stack} = [];\n      # matched \"->()\" so remember the group on the stack\n      $self->{stack} = [ $self->{group_stack}->[-1] ] if defined $13 && $13 eq ')';\n\n      1;\n      } );\n  }\n\nsub _line_insert\n  {\n  # what to insert between two lines, '' for Graph::Easy, ' ' for Graphviz;\n  '';\n  }\n\nsub _clean_line\n  { \n  # do some cleanups on a line before handling it\n  my ($self,$line) = @_;\n\n  chomp($line);\n\n  # convert #808080 into \\#808080, and \"#fff\" into \"\\#fff\"\n  my $sep = $self->{attr_sep};\n  $line =~ s/$sep\\s*(\"?)(#(?:[a-fA-F0-9]{6}|[a-fA-F0-9]{3}))(\"?)/$sep $1\\\\$2$3/g;\n\n  # remove comment at end of line (but leave \\# alone):\n  $line =~ s/(:[^\\\\]|)$self->{qr_comment}.*/$1/;\n\n  # remove white space at end (but not at the start, to keep \"  ||\" intact\n  $line =~ s/\\s+\\z//;\n\n#  print STDERR \"# at line '$line' stack: \", join(\",\",@{ $self->{stack}}),\"\\n\";\n\n  $line;\n  }\n\nsub from_text\n  {\n  my ($self,$txt) = @_;\n\n  # matches a multi-line comment\n  my $o_cmt = qr#((\\s*/\\*.*?\\*/\\s*)*\\s*|\\s+)#;\n\n  if ((ref($self)||$self) eq 'Graph::Easy::Parser' && \n    # contains \"digraph GRAPH {\" or something similiar\n     ( $txt =~ /^(\\s*|\\s*\\/\\*.*?\\*\\/\\s*)(strict)?$o_cmt(di)?graph$o_cmt(\"[^\"]*\"|[\\w_]+)$o_cmt\\{/im ||\n    # contains \"digraph {\" or something similiar\t\n      $txt =~ /^(\\s*|\\s*\\/\\*.*?\\*\\/\\s*)(strict)?${o_cmt}digraph$o_cmt\\{/im || \n    # contains \"strict graph {\" or something similiar\t\n      $txt =~ /^(\\s*|\\s*\\/\\*.*?\\*\\/\\s*)strict${o_cmt}(di)?graph$o_cmt\\{/im)) \n    {\n    require Graph::Easy::Parser::Graphviz;\n    # recreate ourselfes, and pass our arguments along\n    my $debug = 0;\n    my $old_self = $self;\n    if (ref($self))\n      {\n      $debug = $self->{debug};\n      $self->{fatal_errors} = 0;\n      }\n    $self = Graph::Easy::Parser::Graphviz->new( debug => $debug, fatal_errors => 0 );\n    $self->reset();\n    $self->{_old_self} = $old_self if ref($self);\n    }\n\n  if ((ref($self)||$self) eq 'Graph::Easy::Parser' && \n    # contains \"graph: {\"\n      $txt =~ /^([\\s\\n\\t]*|\\s*\\/\\*.*?\\*\\/\\s*)graph\\s*:\\s*\\{/m) \n    {\n    require Graph::Easy::Parser::VCG;\n    # recreate ourselfes, and pass our arguments along\n    my $debug = 0;\n    my $old_self = $self;\n    if (ref($self))\n      {\n      $debug = $self->{debug};\n      $self->{fatal_errors} = 0;\n      }\n    $self = Graph::Easy::Parser::VCG->new( debug => $debug, fatal_errors => 0 );\n    $self->reset();\n    $self->{_old_self} = $old_self if ref($self);\n    }\n\n  $self = $self->new() unless ref $self;\n  $self->reset();\n\n  my $graph = $self->{_graph};\n  return $graph if !defined $txt || $txt =~ /^\\s*\\z/;\t\t# empty text?\n \n  my $uc = $self->{use_class};\n\n  # instruct the graph to use the custom classes, too\n  for my $o (keys %$uc)\n    {\n    $graph->use_class($o, $uc->{$o}) unless $o eq 'graph';\t# group, node and edge\n    }\n\n  my @lines = split /(\\r\\n|\\n|\\r)/, $txt;\n\n  my $backbuffer = '';\t# left over fragments to be combined with next line\n\n  my $qr_comment = $self->_match_commented_line();\n  $self->{qr_comment} = $self->_match_comment();\n  # cache the value of this since it can be expensive to construct:\n  $self->{_match_single_attribute} = $self->_match_single_attribute();\n\n  $self->_build_match_stack();\n\n  ###########################################################################\n  # main parsing loop\n\n  my $handled = 0;\t\t# did we handle a fragment?\n  my $line;\n\n#  my $counts = {};\n  LINE:\n  while (@lines > 0 || $backbuffer ne '')\n    {\n    # only accumulate more text if we didn't handle a fragment\n    if (@lines > 0 && $handled == 0)\n      {\n      $self->{line_nr}++;\n      my $curline = shift @lines;\n\n      # discard empty lines, or completely commented out lines\n      next if $curline =~ $qr_comment;\n\n      # convert tabs to spaces (the regexps don't expect tabs)\n      $curline =~ tr/\\t/ /d;\n\n      # combine backbuffer, what to insert between two lines and next line:\n      $line = $backbuffer . $self->_line_insert() . $self->_clean_line($curline);\n      }\n\n  print STDERR \"# Line is '$line'\\n\" if $self->{debug} && $self->{debug} > 2;\n  print STDERR \"#  Backbuffer is '$backbuffer'\\n\" if $self->{debug} && $self->{debug} > 2;\n\n    $handled = 0;\n#debug my $count = 0;\n    PATTERN:\n    for my $entry (@{$self->{match_stack}})\n      {\n      # nothing to match against?\n      last PATTERN if $line eq '';\n\n      $self->{replace} = '';\t# as default just remove the matched text\n      my ($pattern, $handler, $replace) = @$entry;\n\n  print STDERR \"# Matching against $pattern\\n\" if $self->{debug} && $self->{debug} > 3;\n\n      if ($line =~ $pattern)\n        {\n#debug $counts->{$count}++;\n  print STDERR \"# Matched, calling handler\\n\" if $self->{debug} && $self->{debug} > 2;\n        my $rc = 1;\n        $rc = &$handler($self) if defined $handler;\n        if ($rc)\n\t  {\n          $replace = $self->{replace} unless defined $replace;\n\t  $replace = &$replace($self,$line) if ref($replace);\n  print STDERR \"# Handled it successfully.\\n\" if $self->{debug} && $self->{debug} > 2;\n          $line =~ s/$pattern/$replace/;\n  print STDERR \"# Line is now '$line' (replaced with '$replace')\\n\" if $self->{debug} && $self->{debug} > 2;\n          $handled++; last PATTERN;\n          }\n        }\n#debug $count ++;\n\n      }\n\n#debug    if ($handled == 0) { $counts->{'-1'}++; }\n    # couldn't handle that fragement, so accumulate it and try again\n    $backbuffer = $line;\n\n    # stop at the very last line\n    last LINE if $handled == 0 && @lines == 0;\n\n    # stop at parsing errors\n    last LINE if $self->{error};\n    }\n\n  $self->error(\"'$backbuffer' not recognized by \" . ref($self)) if $backbuffer ne '';\n\n  # if something was left on the stack, file ended unexpectedly\n  $self->parse_error(7) if !$self->{error} && $self->{scope_stack} && @{$self->{scope_stack}} > 0;\n\n  return undef if $self->{error} && $self->{fatal_errors};\n\n#debug  use Data::Dumper; print Dumper($counts);\n\n  print STDERR \"# Parsing done.\\n\" if $graph->{debug};\n\n  # Do final cleanup (for parsing Graphviz)\n  $self->_parser_cleanup() if $self->can('_parser_cleanup');\n  $graph->_drop_special_attributes();\n\n  # turn on strict checking on returned graph\n  $graph->strict(1);\n  $graph->fatal_errors(1);\n\n  $graph;\n  }\n\n#############################################################################\n# internal routines\n\nsub _edge_style\n  {\n  my ($self, $ed) = @_;\n\n  my $style = undef;\t\t\t# default is \"inherit from class\"\n  $style = 'double-dash' if $ed =~ /^(= )+\\z/; \n  $style = 'double' if $ed =~ /^=+\\z/; \n  $style = 'dotted' if $ed =~ /^\\.+\\z/; \n  $style = 'dashed' if $ed =~ /^(- )+\\z/; \n  $style = 'dot-dot-dash' if $ed =~ /^(..-)+\\z/; \n  $style = 'dot-dash' if $ed =~ /^(\\.-)+\\z/; \n  $style = 'wave' if $ed =~ /^\\~+\\z/; \n  $style = 'bold' if $ed =~ /^#+\\z/; \n\n  $style;\n  }\n\nsub _link_lists\n  {\n  # Given two node lists and an edge style, links each node from list\n  # one to list two.\n  my ($self, $left, $right, $ed, $label, $edge_atr, $edge_bd, $edge_un) = @_;\n\n  my $graph = $self->{_graph};\n \n  my $style = $self->_edge_style($ed);\n  my $e = $self->{use_class}->{edge};\n\n  # add edges for all nodes in the left list\n  for my $node (@$left)\n    {\n    for my $node_b (@$right)\n      {\n      my $edge = $e->new( { style => $style, name => $label } );\n\n      $graph->add_edge ( $node, $node_b, $edge );\n\n      # 'string' => [ 'string' ]\n      # [ { hash }, 'string' ] => [ { hash }, 'string' ]\n      my $e = $edge_atr; $e = [ $edge_atr ] unless ref($e) eq 'ARRAY';\n\n      for my $a (@$e)\n\t{\n\tif (ref $a)\n\t  {\n\t  $edge->set_attributes($a);\n\t  }\n\telse\n\t  {\n\t  # deferred parsing with the object as param:\n\t  my $out = $self->_parse_attributes($a, $edge);\n\t  return undef if $self->{error};\n\t  $edge->set_attributes($out);\n\t  }\n\t}\n\n      # \"<--->\": bidirectional\n      $edge->bidirectional(1) if $edge_bd;\n      $edge->undirected(1) if $edge_un;\n      }\n    }\n\n  $style;\n  }\n\nsub _unquote_attribute\n  {\n  my ($self,$name,$value) = @_;\n\n  $self->_unquote($value);\n  }\n\nsub _unquote\n  {\n  my ($self, $name, $no_collapse) = @_;\n\n  $name = '' unless defined $name;\n\n  # unquote special chars\n  $name =~ s/\\\\([\\[\\(\\{\\}\\]\\)#<>\\-\\.\\=])/$1/g;\n\n  # collapse multiple spaces\n  $name =~ s/\\s+/ /g unless $no_collapse;\n\n  $name;\n  }\n\nsub _add_node\n  {\n  # add a node to the graph, overidable by subclasses\n  my ($self, $graph, $name) = @_;\n\n  $graph->add_node($name);\t\t# add unless exists\n  }\n\nsub _get_cluster_name\n  {\n  # create a unique name for an autosplit node\n  my ($self, $base_name) = @_;\n\n  # Try to find a unique cluster name in case some one get's creative and names the\n  # last part \"-1\":\n\n  # does work without cluster-id?\n  if (exists $self->{clusters}->{$base_name})\n    {\n    my $g = 1;\n    while ($g == 1)\n      {\n      my $base_try = $base_name; $base_try .= '-' . $self->{cluster_id} if $self->{cluster_id};\n      last if !exists $self->{clusters}->{$base_try};\n      $self->{cluster_id}++;\n      }\n    $base_name .= '-' . $self->{cluster_id} if $self->{cluster_id}; $self->{cluster_id}++;\n    }\n\n  $self->{clusters}->{$base_name} = undef;\t# reserve this name\n\n  $base_name;\n  }\n\nsub _set_new_basename\n  {\n  # when encountering something like:\n  #   [ a | b ]\n  #   { basename: foo; }\n  # the Parser will create two nodes, ab.0 and ab.1, and then later see\n  # the \"basename: foo\". Sowe need to rename the already created nodes\n  # due to the changed basename:\n  my ($self, $node, $new_basename) = @_;\n\n  # nothing changes?\n  return if $node->{autosplit_basename} eq $new_basename;\n\n  my $g = $node->{graph};\n\n  my @parts = @{$node->{autosplit_parts}};\n  my $nr = 0;\n  for my $part ($node, @parts)\n    {\n    print STDERR \"# Setting new basename $new_basename for node $part->{name}\\n\"\n      if $self->{debug} > 1;\n\n    $part->{autosplit_basename} = $new_basename;\n    $part->set_attribute('basename', $new_basename);\n  \n    # delete it from the list of nodes\n    delete $g->{nodes}->{$part->{name}};\n    $part->{name} = $new_basename . '.' . $nr; $nr++;\n    # and re-insert it with the right name\n    $g->{nodes}->{$part->{name}} = $part;\n\n    # we do not need to care for edges here, as they are stored with refs\n    # to the nodes and not the node names itself\n    }\n  }\n\nsub _autosplit_node\n  {\n  # Takes a node name like \"a|b||c\" and splits it into \"a\", \"b\", and \"c\".\n  # Returns the individual parts.\n  my ($self, $graph, $name, $att, $allow_empty) = @_;\n \n  # Default is to have empty parts. Graphviz sets this to true;\n  $allow_empty = 1 unless defined $allow_empty;\n\n  my @rc;\n  my $uc = $self->{use_class};\n  my $qr_clean = $self->{_qr_part_clean};\n\n  # build base name: \"A|B |C||D\" => \"ABCD\"\n  my $base_name = $name; $base_name =~ s/\\s*\\|\\|?\\s*//g;\n\n  # use user-provided base name\n  $base_name = $att->{basename} if exists $att->{basename};\n\n  # strip trailing/leading spaces on basename\n  $base_name =~ s/\\s+\\z//;\n  $base_name =~ s/^\\s+//;\n\n  # first one gets: \"ABC\", second one \"ABC.1\" and so on\n  $base_name = $self->_get_cluster_name($base_name);\n\n  print STDERR \"# Parser: Autosplitting node with basename '$base_name'\\n\" if $graph->{debug};\n\n  my $first_in_row;\t\t\t# for relative placement of new row\n  my $x = 0; my $y = 0; my $idx = 0;\n  my $remaining = $name; my $sep; my $last_sep = '';\n  my $add = 0;\n  while ($remaining ne '')\n    {\n    # XXX TODO: parsing of \"\\|\" and \"|\" in one node\n    $remaining =~ s/^((\\\\\\||[^\\|])*)(\\|\\|?|\\z)//;\n    my $part = $1 || ' ';\n    $sep = $3;\n    my $port_name = '';\n\n    # possible cleanup for this part\n    if ($qr_clean)\n      {\n      $part =~ s/^$qr_clean//; $port_name = $1;\n      }\n\n    # fix [|G|] to have one empty part as last part\n    if ($add == 0 && $remaining eq '' && $sep =~ /\\|\\|?/)\n      {\n      $add++;\t\t\t\t# only do it once\n      $remaining .= '|' \n      }\n\n    print STDERR \"# Parser: Found autosplit part '$part'\\n\" if $graph->{debug};\n\n    my $class = $uc->{node};\n    if ($allow_empty && $part eq ' ')\n      {\n      # create an empty node with no border\n      $class .= \"::Empty\";\n      }\n    elsif ($part =~ /^[ ]{2,}\\z/)\n      {\n      # create an empty node with border\n      $part = ' ';\n      }\n    else\n      {\n      $part =~ s/^\\s+//;\t# rem spaces at front\n      $part =~ s/\\s+\\z//;\t# rem spaces at end\n      }\n\n    my $node_name = \"$base_name.$idx\";\n\n    if ($graph->{debug})\n      {\n      my $empty = '';\n      $empty = ' empty' if $class ne $self->{use_class}->{node};\n      print STDERR \"# Parser:  Creating$empty autosplit part '$part'\\n\" if $graph->{debug};\n      }\n\n    # if it doesn't exist, add it, otherwise retrieve node object to $node\n    if ($class =~ /::Empty/)\n      {\n      my $node = $graph->node($node_name);\n      if (!defined $node)\n\t{\n\t# create node object from the correct class\n\t$node = $class->new($node_name);\n        $graph->add_node($node);\n\t}\n      }\n\n    my $node = $graph->add_node($node_name);\n    $node->{autosplit_label} = $part;\n    # remember these two for Graphviz\n    $node->{autosplit_portname} = $port_name;\n    $node->{autosplit_basename} = $base_name;\n\n    push @rc, $node;\n    if (@rc == 1)\n      {\n      # for correct as_txt output\n      $node->{autosplit} = $name;\n      $node->{autosplit} =~ s/\\s+\\z//;\t\t# strip trailing spaces\n      $node->{autosplit} =~ s/^\\s+//;\t\t# strip leading spaces\n      $node->{autosplit} =~ s/([^\\|])\\s+\\|/$1 \\|/g;\t# 'foo  |' => 'foo |'\n      $node->{autosplit} =~ s/\\|\\s+([^\\|])/\\| $1/g;\t# '|  foo' => '| foo'\n      $node->set_attribute('basename', $att->{basename}) if defined $att->{basename};\n      # list of all autosplit parts so as_txt() can find them easily again\n      $node->{autosplit_parts} = [ ];\n      $first_in_row = $node;\n      }\n    else\n      {\n      # second, third etc. get previous as origin\n      my ($sx,$sy) = (1,0);\n      my $origin = $rc[-2];\n      if ($last_sep eq '||')\n        {\n        ($sx,$sy) = (0,1); $origin = $first_in_row;\n        $first_in_row = $node;\n        }\n      $node->relative_to($origin,$sx,$sy);\n      push @{$rc[0]->{autosplit_parts}}, $node;\n      weaken @{$rc[0]->{autosplit_parts}}[-1];\n\n      # suppress as_txt output for other parts\n      $node->{autosplit} = undef;\n      }\t\n    # nec. for border-collapse\n    $node->{autosplit_xy} = \"$x,$y\";\n\n    $idx++;\t\t\t\t\t\t# next node ID\n    $last_sep = $sep;\n    $x++;\n    # || starts a new row:\n    if ($sep eq '||')\n      {\n      $x = 0; $y++;\n      }\n    }  # end for all parts\n\n  @rc;\t# return all created nodes\n  }\n\nsub _new_node\n  {\n  # Create a new node unless it doesn't already exist. If the group stack\n  # contains entries, the new node appears first in this/these group(s), so\n  # add it to these groups. If the newly created node contains \"|\", we auto\n  # split it up into several nodes and cluster these together.\n  my ($self, $graph, $name, $group_stack, $att, $stack) = @_;\n\n  print STDERR \"# Parser: new node '$name'\\n\" if $graph->{debug};\n\n  $name = $self->_unquote($name, 'no_collapse');\n\n  my $autosplit;\n  my $uc = $self->{use_class};\n\n  my @rc = ();\n\n  if ($name =~ /^\\s*\\z/)\n    {\n    print STDERR \"# Parser: Creating anon node\\n\" if $graph->{debug};\n    # create a new anon node and add it to the graph\n    my $class = $uc->{node} . '::Anon';\n    my $node = $class->new();\n    @rc = ( $graph->add_node($node) );\n    }\n  # nodes to be autosplit will be done in a sep. pass for Graphviz\n  elsif ((ref($self) eq 'Graph::Easy::Parser') && $name =~ /[^\\\\]\\|/)\n    {\n    $autosplit = 1;\n    @rc = $self->_autosplit_node($graph, $name, $att);\n    }\n  else\n    {\n    # strip trailing and leading spaces\n    $name =~ s/\\s+\\z//; \n    $name =~ s/^\\s+//; \n\n    # collapse multiple spaces\n    $name =~ s/\\s+/ /g;\n\n    # unquote \\|\n    $name =~ s/\\\\\\|/\\|/g;\n\n    if ($self->{debug})\n      {\n      if (!$graph->node($name))\n\t{\n\tprint STDERR \"# Parser: Creating normal node from name '$name'.\\n\";\n\t}\n      else\n\t{\n\tprint STDERR \"# Parser: Found node '$name' already in graph.\\n\";\n\t}\n      }\n    @rc = ( $self->_add_node($graph, $name) ); \t# add to graph, unless exists\n    }\n\n  $self->parse_error(5) if exists $att->{basename} && !$autosplit;\n\n  my $b = $att->{basename};\n  delete $att->{basename};\n\n  # on a node list \"[A],[B] { ... }\" set attributes on all nodes\n  # encountered so far, too:\n  if (defined $stack)\n    {\n    for my $node (@$stack)\n      {\n      $node->set_attributes ($att, 0);\n      }\n    }\n  my $index = 0;\n  my $group = $self->{group_stack}->[-1];\n\n  for my $node (@rc)\n    {\n    $node->add_to_group($group) if $group;\n    $node->set_attributes ($att, $index);\n    $index++;\n    }\n  \n  $att->{basename} = $b if defined $b;\n\n  # return list of created nodes (usually one, but more for \"A|B\")\n  @rc;\n  }\n\nsub _match_comma\n  {\n  # return a regexp that matches something like \" , \" like in:\n  # \"[ Bonn ], [ Berlin ] => [ Hamburg ]\"\n  qr/\\s*,\\s*/;\n  }\n\nsub _match_comment\n  {\n  # match the start of a comment\n  qr/(^|[^\\\\])#/;\n  }\n\nsub _match_commented_line\n  {\n  # match empty lines or a completely commented out line\n  qr/^\\s*(#|\\z)/;\n  }\n\nsub _match_attributes\n  {\n  # return a regexp that matches something like \" { color: red; }\" and returns\n  # the inner text without the {}\n  qr/\\s*\\{\\s*([^\\}]+?)\\s*\\}/;\n  }\n\nsub _match_optional_attributes\n  {\n  # return a regexp that matches something like \" { color: red; }\" and returns\n  # the inner text with the {}\n  qr/(\\s*\\{[^\\}]+?\\})?/;\n  }\n\nsub _match_node\n  {\n  # return a regexp that matches something like \" [ bonn ]\" and returns\n  # the inner text without the [] (might leave some spaces)\n\n  qr/\\s*\\[\t\t\t\t#  '[' start of the node\n    (\n     (?:\t\t\t\t# non-capturing group\n      \\\\.\t\t\t\t# either '\\]' or '\\N' etc.\n      |\t\t\t\t\t#  or\n      [^\\]\\\\]\t\t\t\t# not ']' and not '\\'\n     )*\t\t\t\t\t# 0 times for '[]'\n    )\n    \\]/x;\t\t\t\t# followed by ']'\n  }\n\nsub _match_class_selector\n  {\n  my $class = qr/(?:\\.\\w+|graph|(?:edge|group|node)(?:\\.\\w+)?)/;\n  qr/($class(?:\\s*,\\s*$class)*)/;\n  }\n\nsub _match_single_attribute\n  {\n  qr/\\s*([^:]+?)\\s*:\\s*(\"(?:\\\\\"|[^\"])+\"|(?:\\\\;|[^;])+?)(?:\\s*;\\s*|\\s*\\z)/;\t# \"name: value\"\n  }\n\nsub _match_group_start\n  {\n  # Return a regexp that matches something like \" ( group [\" and returns\n  # the text between \"(\" and \"[\". Also matches empty groups like \"( group )\"\n  # or even \"()\":\n  qr/\\s*\\(\\s*([^\\[\\)\\(]*?)\\s*([\\[\\)\\(])/;\n  }\n\nsub _match_group_end\n  {\n  # return a regexp that matches something like \" )\".\n  qr/\\s*\\)\\s*/;\n  }\n\nsub _match_edge\n  {\n  # Matches all possible edge variants like:\n  # -->, ---->, ==> etc\n  # <-->, <---->, <==>, <..> etc\n  # <-- label -->, <.- label .-> etc  \n  # -- label -->, .- label .-> etc  \n\n  # \"- \" must come before \"-\"!\n  # likewise, \"..-\" must come before \".-\" must come before \".\"\n\n  # XXX TODO: convert the first group into a non-matching group\n\n  qr/\\s*\n     (\t\t\t\t\t# egde without label (\"-->\")\n       (<?) \t\t\t\t # optional left \"<\"\n       (=\\s|=|-\\s|-|\\.\\.-|\\.-|\\.|~)+>\t # pattern (style) of edge\n     |\t\t\t\t\t# edge with label (\"-- label -->\")\n       (<?) \t\t\t\t # optional left \"<\"\n       ((=\\s|=|-\\s|-|\\.\\.-|\\.-|\\.|~)+)\t # pattern (style) of edge\n       \\s+\t\t\t\t # followed by at least a space\n       ((?:\\\\.|[^>\\[\\{])*?)\t\t # either \\\\, \\[ etc, or not \">\", \"[\", \"{\"\n       (\\s+\\5)>\t\t\t\t # a space and pattern before \">\"\n\n# inserting this needs mucking with all the code that access $5 etc\n#     |\t\t\t\t\t# undirected edge (without arrows, but with label)\n#       ((=\\s|=|-\\s|-|\\.\\.-|\\.-|\\.|~)+)\t # pattern (style) of edge\n#       \\s+\t\t\t\t # followed by at least a space\n#       ((?:\\\\.|[^>\\[\\{])*?)\t\t # either \\\\, \\[ etc, or not \">\", \"[\", \"{\"\n#       (\\s+\\10)\t\t\t\t # a space and pattern\n\n     |\t\t\t\t\t# undirected edge (without arrows and label)\n       (\\.\\.-|\\.-)+\t\t\t # pattern (style) of edge (at least once)\n     |\n       (=\\s|=|-\\s|-|\\.|~){2,}\t\t # these at least two times\n     )\n     /x;\n   }\n\nsub _clean_attributes\n  {\n  my ($self,$text) = @_;\n\n  $text =~ s/^\\s*\\{\\s*//;\t# remove left-over \"{\" and spaces\n  $text =~ s/\\s*\\}\\s*\\z//;\t# remove left-over \"}\" and spaces\n\n  $text;\n  }\n\nsub _parse_attributes\n  {\n  # Takes a text like \"attribute: value;  attribute2 : value2;\" and\n  # returns a hash with the attributes. $class defaults to 'node'.\n  # In list context, also returns a flag that is maxlevel-1 when one\n  # of the attributes was a multiple one (aka 2 for \"red|green\", 1 for \"red\");\n  my ($self, $text, $object, $no_multiples) = @_;\n\n  my $class = $object;\n  $class = $object->{class} if ref($object);\n  $class = 'node' unless defined $class;\n  $class =~ s/\\..*//;\t\t\t\t# remove subclass\n\n  my $out;\n  my $att = {};\n  my $multiples = 0;\n\n  $text = $self->_clean_attributes($text);\n  my $qr_att  = $self->{_match_single_attribute};\n  my $qr_cmt;  $qr_cmt  = $self->_match_multi_line_comment()\n   if $self->can('_match_multi_line_comment');\n  my $qr_satt; $qr_satt = $self->_match_special_attribute() \n   if $self->can('_match_special_attribute');\n\n  return {} if $text =~ /^\\s*\\z/;\n\n  print STDERR \"attr parsing: matching\\n '$text'\\n against $qr_att\\n\" if $self->{debug} > 3;    \n\n  while ($text ne '')\n    {\n    print STDERR \"attr parsing: matching '$text'\\n\" if $self->{debug} > 3;    \n\n    # remove a possible comment\n    $text =~ s/^$qr_cmt//g if $qr_cmt;\n\n    # if the last part was a comment, we end up with an empty text here:\n    last if $text =~ /^\\s*\\z/;\n\n    # match and remove \"name: value\"\n    my $done = ($text =~ s/^$qr_att//) || 0;\n\n    # match and remove \"name\" if \"name: value;\" didn't match\n    $done++ if $done == 0 && $qr_satt && ($text =~ s/^$qr_satt//);\n\n    return $self->error (\"Error in attribute: '$text' doesn't look valid to me.\")\n      if $done == 0;\n\n    my $name = $1;\n    my $v = $2; $v = '' unless defined $v;\t# for special attributes w/o value\n\n    # unquote and store\n    $out->{$name} = $self->_unquote_attribute($name,$v);\n    }\n\n  if ($self->{debug} && $self->{debug} > 1)\n    {\n    require Data::Dumper;\n    print STDERR \"# \", join (\" \", caller),\"\\n\";\n    print STDERR \"# Parsed attributes into:\\n\", Data::Dumper::Dumper($out),\"\\n\";\n    }\n  # possible remap attributes (for parsing Graphviz)\n  $out = $self->_remap_attributes($out, $object) if $self->can('_remap_attributes');\n\n  my $g = $self->{_graph};\n  # check for being valid and finally create hash with name => value pairs\n  for my $name (sort keys %$out)\n    {\n    my ($rc, $newname, $v) = $g->validate_attribute($name,$out->{$name},$class,$no_multiples);\n\n    $self->error($g->{error}) if defined $rc;\n\n    $multiples = scalar @$v if ref($v) eq 'ARRAY';\n\n    $att->{$newname} = $v if defined $v;\t# undef => ignore attribute\n    }\n\n  return $att unless wantarray;\n\n  ($att, $multiples || 1);\n  }\n\nsub parse_error\n  {\n  # take a msg number, plus params, and throws an exception\n  my $self = shift;\n  my $msg_nr = shift;\n\n  # XXX TODO: should really use the msg nr mapping\n  my $msg = \"Found unexpected group end\";\t\t\t\t\t\t# 0\n  $msg = \"Error in attribute: '##param2##' is not a valid attribute for a ##param3##\"\t# 1\n        if $msg_nr == 1;\n  $msg = \"Error in attribute: '##param1##' is not a valid ##param2## for a ##param3##\"\n\tif $msg_nr == 2;\t\t\t\t\t\t\t\t# 2\n  $msg = \"Error: Found attributes, but expected group or node start\"\n\tif $msg_nr == 3;\t\t\t\t\t\t\t\t# 3\n  $msg = \"Error in attribute: multi-attribute '##param1##' not allowed here\"\n\tif $msg_nr == 4;\t\t\t\t\t\t\t\t# 4\n  $msg = \"Error in attribute: basename not allowed for non-autosplit nodes\"\n\tif $msg_nr == 5;\t\t\t\t\t\t\t\t# 5\n  # for graphviz parsing\n  $msg = \"Error: Already seen graph start\"\n\tif $msg_nr == 6;\t\t\t\t\t\t\t\t# 6\n  $msg = \"Error: Expected '}', but found file end\"\n\tif $msg_nr == 7;\t\t\t\t\t\t\t\t# 7\n\n  my $i = 1;\n  foreach my $p (@_)\n    {\n    $msg =~ s/##param$i##/$p/g; $i++;\n    }\n\n  $self->error($msg . ' at line ' . $self->{line_nr});\n  }\n\nsub _parser_cleanup\n  {\n  # After initial parsing, do a cleanup pass.\n  my ($self) = @_;\n\n  my $g = $self->{_graph};\n  \n  for my $n (values %{$g->{nodes}})\n    {\n    next if $n->{autosplit};\n    $self->warn(\"Node '\" . $self->_quote($n->{name}) . \"' has an offset but no origin\")\n      if (($n->attribute('offset') ne '0,0') && $n->attribute('origin') eq '');\n    }\n\n  $self;\n  }\n\nsub _quote\n  {\n  # make a node name safe for error message output\n  my ($self,$n) = @_;\n\n  $n =~ s/'/\\\\'/g;\n\n  $n;\n  }\n\n1;\n__END__\n\n=head1 NAME\n\nGraph::Easy::Parser - Parse Graph::Easy from textual description\n\n=head1 SYNOPSIS\n\n        # creating a graph from a textual description\n        use Graph::Easy::Parser;\n        my $parser = Graph::Easy::Parser->new();\n\n        my $graph = $parser->from_text(\n                '[ Bonn ] => [ Berlin ]'.\n                '[ Berlin ] => [ Rostock ]'.\n        );\n        print $graph->as_ascii();\n\n        print $parser->from_file('mygraph.txt')->as_ascii();\n\n\t# Also works automatically on graphviz code:\n        print Graph::Easy::Parser->from_file('mygraph.dot')->as_ascii();\n\n=head1 DESCRIPTION\n\nC<Graph::Easy::Parser> lets you parse simple textual descriptions\nof graphs, and constructs a C<Graph::Easy> object from them.\n\nThe resulting object can than be used to layout and output the graph.\n\n=head2 Input\n\nThe input consists of text describing the graph, encoded in UTF-8.\n\nExample:\n\n\t[ Bonn ]      --> [ Berlin ]\n\t[ Frankfurt ] <=> [ Dresden ]\n\t[ Bonn ]      --> [ Frankfurt ]\n\t[ Bonn ]      = > [ Frankfurt ]\n\n=head3 Graphviz\n\nIn addition there is a bit of magic that detects graphviz code, so\ninput of the following form will also work:\n\n\tdigraph Graph1 {\n\t\t\"Bonn\" -> \"Berlin\"\n\t}\n\nNote that the magic detection only works for B<named> graphs or graph\nwith \"digraph\" at their start, so the following will not be detected as\ngraphviz code because it looks exactly like valid Graph::Easy code\nat the start:\n\n\tgraph {\n\t\t\"Bonn\" -> \"Berlin\"\n\t}\n\nSee L<Graph::Easy::Parser::Graphviz> for more information about parsing\ngraphs in the DOT language.\n\n=head3 VCG\n\nIn addition there is a bit of magic that detects VCG code, so\ninput of the following form will also work:\n\n\tgraph: {\n\t\tnode: { title: Bonn; }\n\t\tnode: { title: Berlin; }\n\t\tedge: { sourcename: Bonn; targetname: Berlin; }\n\t}\n\nSee L<Graph::Easy::Parser::VCG> for more information about parsing\ngraphs in the VCG language.\n\n=head2 Input Syntax\n\nThis is a B<very> brief description of the syntax for the Graph::Easy\nlanguage, for a full specification, please see L<Graph::Easy::Manual>.\n\n=over 2\n\n=item nodes\n\nNodes are rendered (or \"quoted\", if you wish) with enclosing square brackets:\n\n\t[ Single node ]\n\t[ Node A ] --> [ Node B ]\n\nAnonymous nodes do not have a name and cannot be refered to again:\n\n\t[ ] -> [ Bonn ] -> [ ]\n\nThis creates three nodes, two of them anonymous.\n\n=item edges\n\nThe edges between the nodes can have the following styles:\n\n\t->\t\tsolid\n\t=>\t\tdouble\n\t.>\t\tdotted\n\t~>\t\twave\n\n\t- >\t\tdashed\n\t.->\t\tdot-dash\n\t..->\t\tdot-dot-dash\n\t= >\t\tdouble-dash\n\nThere are also the styles C<bold>, C<wide> and C<broad>. Unlike the others,\nthese can only be set via the (optional) edge attributes:\n\n\t[ AB ] --> { style: bold; } [ ABC ]\n\nYou can repeat each of the style-patterns as much as you like:\n\n\t--->\n\t==>\n\t=>\n\t~~~~~>\n\t..-..-..->\n\nNote that in patterns longer than one character, the entire\npattern must be repeated e.g. all characters of the pattern must be\npresent. Thus:\n\n\t..-..-..->\t# valid dot-dot-dash\n\t..-..-..>\t# invalid!\n\n\t.-.-.->\t\t# valid dot-dash\n\t.-.->\t\t# invalid!\n\nIn additon to the styles, the following two directions are possible:\n\n\t --\t\tedge without arrow heads\n\t -->\t\tarrow at target node (end point)\n\t<-->\t\tarrow on both the source and target node\n\t\t\t(end and start point)\n\nOf course you can combine all directions with all styles. However,\nnote that edges without arrows cannot use the shortcuts for styles:\n\n\t---\t\t# valid\n\t.-.-\t\t# valid\n\t.-\t\t# invalid!\n\t-\t\t# invalid!\n\t~\t\t# invalid!\n\nJust remember to use at least two repititions of the full pattern\nfor arrow-less edges.\n\nYou can also give edges a label, either by inlining it into the style,\nor by setting it via the attributes:\n\n\t[ AB ] --> { style: bold; label: foo; } [ ABC ]\n\n\t-- foo -->\n\t... baz ...>\n\n\t-- solid -->\n\t== double ==>\n\t.. dotted ..>\n\t~~ wave ~~>\n\n\t-  dashed - >\n\t=  double-dash = >\n\t.- dot-dash .->\n\t..- dot-dot-dash ..->\n\nNote that the two patterns on the left and right of the label must be\nthe same, and that there is a space between the left pattern and the\nlabel, as well as the label and the right pattern.\n\nYou may use inline label only with edges that have an arrow. Thus:\n\n\t<-- label -->\t# valid\n\t-- label -->\t# valid\n\n\t-- label --\t# invalid!\n\nTo use a label with an edge without arrow heads, use the attributes:\n\n\t[ AB ] -- { label: edgelabel; } [ CD ]\n\n=item groups\n\nRound brackets are used to group nodes together:\n\n\t( Cities:\n\n\t\t[ Bonn ] -> [ Berlin ]\n\t)\n\nAnonymous groups do not have a name and cannot be refered to again:\n\n\t( [ Bonn ] ) -> [ Berlin ]\n\nThis creates an anonymous group with the node C<Bonn> in it, and\nlinks it to the node C<Berlin>.\n\n=back\n\nPlease see L<Graph::Easy::Manual> for a full description of the syntax rules.\n\n=head2 Output\n\nThe output will be a L<Graph::Easy|Graph::Easy> object (unless overrriden\nwith C<use_class()>), see the documentation for Graph::Easy what you can do\nwith it.\n\n=head1 EXAMPLES\n\nSee L<Graph::Easy> for an extensive list of examples.\n\n=head1 METHODS\n\nC<Graph::Easy::Parser> supports the following methods:\n\n=head2 new()\n\n\tuse Graph::Easy::Parser;\n\tmy $parser = Graph::Easy::Parser->new();\n\nCreates a new parser object. The valid parameters are:\n\n\tdebug\n\tfatal_errors\n\nThe first will enable debug output to STDERR:\n\n\tmy $parser = Graph::Easy::Parser->new( debug => 1 );\n\t$parser->from_text('[A] -> [ B ]');\n\nSetting C<fatal_errors> to 0 will make parsing errors not die, but\njust set an error string, which can be retrieved with L<error()>.\n\n\tmy $parser = Graph::Easy::Parser->new( fatal_errors => 0 );\n\t$parser->from_text(' foo ' );\n\tprint $parser->error();\n\nSee also L<catch_messages()> for how to catch errors and warnings.\n\n=head2 reset()\n\n\t$parser->reset();\n\nReset the status of the parser, clear errors etc. Automatically called\nwhen you call any of the C<from_XXX()> methods below.\n\n=head2 use_class()\n\n\t$parser->use_class('node', 'Graph::Easy::MyNode');\n\nOverride the class to be used to constructs objects while parsing. The\nfirst parameter can be one of the following:\n\n\tnode\n\tedge\n\tgraph\n\tgroup\n\nThe second parameter should be a class that is a subclass of the\nappropriate base class:\n\n\tpackage Graph::Easy::MyNode;\n\n\tuse base qw/Graph::Easy::Node/;\n\n\t# override here methods for your node class\n\n\t######################################################\n\t# when overriding nodes, we also need ::Anon\n\n\tpackage Graph::Easy::MyNode::Anon;\n\n\tuse base qw/Graph::Easy::MyNode/;\n\tuse base qw/Graph::Easy::Node::Anon/;\n\n\t######################################################\n\t# and :::Empty\n\n\tpackage Graph::Easy::MyNode::Empty;\n\n\tuse base qw/Graph::Easy::MyNode/;\n\n\t######################################################\n\tpackage main;\n\t\n\tuse Graph::Easy::Parser;\n\tuse Graph::Easy;\n\n\tuse Graph::Easy::MyNode;\n\tuse Graph::Easy::MyNode::Anon;\n\tuse Graph::Easy::MyNode::Empty;\n\n\tmy $parser = Graph::Easy::Parser;\n\n\t$parser->use_class('node', 'Graph::Easy::MyNode');\n\n\tmy $graph = $parser->from_text(...);\n\nThe object C<$graph> will now contain nodes that are of your\ncustom class instead of plain C<Graph::Easy::Node>.\n\nWhen overriding nodes, you also should provide subclasses\nfor C<Graph::Easy::Node::Anon> and C<Graph::Easy::Node::Empty>,\nand make these subclasses of your custom node class as shown\nabove. For edges, groups and graphs, you need just one subclass.\n\n=head2 from_text()\n\n\tmy $graph = $parser->from_text( $text );\n\nCreate a L<Graph::Easy|Graph::Easy> object from the textual description in C<$text>.\n\nReturns undef for error, you can find out what the error was\nwith L<error()>.\n\nThis method will reset any previous error, and thus the C<$parser> object\ncan be re-used to parse different texts by just calling C<from_text()>\nmultiple times.\n\n=head2 from_file()\n\n\tmy $graph = $parser->from_file( $filename );\n\tmy $graph = Graph::Easy::Parser->from_file( $filename );\n\nCreates a L<Graph::Easy|Graph::Easy> object from the textual description in the file\nC<$filename>.\n\nThe second calling style will create a temporary C<Graph::Easy::Parser> object,\nparse the file and return the resulting C<Graph::Easy> object.\n\nReturns undef for error, you can find out what the error was\nwith L<error()> when using the first calling style.\n\n=head2 error()\n\n\tmy $error = $parser->error();\n\nReturns the last error, or the empty string if no error occured.\n\nIf you want to catch warnings from the parser, enable catching\nof warnings or errors:\n\n\t$parser->catch_messages(1);\n\n\t# Or individually:\n\t# $parser->catch_warnings(1);\n\t# $parser->catch_errors(1);\n\n\t# something which warns or throws an error:\n\t...\n\n\tif ($parser->error())\n\t  {\n\t  my @errors = $parser->errors();\n\t  }\n\tif ($parser->warning())\n\t  {\n\t  my @warnings = $parser->warnings();\n\t  }\n\nSee L<Graph::Easy::Base> for more details on error/warning message capture.\n\n=head2 parse_error()\n\n\t$parser->parse_error( $msg_nr, @params);\n\nSets an error message from a message number and replaces embedded\ntemplates like C<##param1##> with the passed parameters.\n\n=head2 _parse_attributes()\n\n\tmy $attributes = $parser->_parse_attributes( $txt, $class );\n\tmy ($att, $multiples) = $parser->_parse_attributes( $txt, $class );\n  \nB<Internal usage only>. Takes a text like this:\n\n\tattribute: value;  attribute2 : value2;\n\nand returns a hash with the attributes.\n\nIn list context, also returns the max count of multiple attributes, e.g.\n3 when it encounters something like C<< red|green|blue >>. When\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph::Easy>. L<Graph::Easy::Parser::Graphviz> and L<Graph::Easy::Parser::VCG>.\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>\n\nSee the LICENSE file for information.\n\n=cut\n",
  "Graph/Easy.pm": "############################################################################\n# Manage, and layout graphs on a flat plane.\n#\n#############################################################################\n\npackage Graph::Easy;\n\nuse 5.008002;\nuse Graph::Easy::Base;\nuse Graph::Easy::Attributes;\nuse Graph::Easy::Edge;\nuse Graph::Easy::Group;\nuse Graph::Easy::Group::Anon;\nuse Graph::Easy::Layout;\nuse Graph::Easy::Node;\nuse Graph::Easy::Node::Anon;\nuse Graph::Easy::Node::Empty;\nuse Scalar::Util qw/weaken/;\n\n$VERSION = '0.69';\n@ISA = qw/Graph::Easy::Base/;\n\nuse strict;\nmy $att_aliases;\n\nBEGIN \n  {\n  # a few aliases for backwards compatibility\n  *get_attribute = \\&attribute; \n  *as_html_page = \\&as_html_file;\n  *as_graphviz_file = \\&as_graphviz;\n  *as_ascii_file = \\&as_ascii;\n  *as_boxart_file = \\&as_boxart;\n  *as_txt_file = \\&as_txt;\n  *as_vcg_file = \\&as_vcg;\n  *as_gdl_file = \\&as_gdl;\n  *as_graphml_file = \\&as_graphml;\n\n  # a few aliases for code re-use\n  *_aligned_label = \\&Graph::Easy::Node::_aligned_label;\n  *quoted_comment = \\&Graph::Easy::Node::quoted_comment;\n  *_un_escape = \\&Graph::Easy::Node::_un_escape;\n  *_convert_pod = \\&Graph::Easy::Node::_convert_pod;\n  *_label_as_html = \\&Graph::Easy::Node::_label_as_html;\n  *_wrapped_label = \\&Graph::Easy::Node::_wrapped_label;\n  *get_color_attribute = \\&color_attribute;\n  *get_custom_attributes = \\&Graph::Easy::Node::get_custom_attributes;\n  *custom_attributes = \\&Graph::Easy::Node::get_custom_attributes;\n  $att_aliases = Graph::Easy::_att_aliases();\n\n  # backwards compatibility\n  *is_simple_graph = \\&is_simple;\n\n  # compatibility to Graph\n  *vertices = \\&nodes;\n  }\n\n#############################################################################\n\nsub new\n  {\n  # override new() as to not set the {id}\n  my $class = shift;\n\n  # called like \"new->('[A]->[B]')\":\n  if (@_ == 1 && !ref($_[0]))\n    {\n    require Graph::Easy::Parser;\n    my $parser = Graph::Easy::Parser->new();\n    my $self = eval { $parser->from_text($_[0]); };\n    if (!defined $self)\n      {\n      $self = Graph::Easy->new( fatal_errors => 0 );\n      $self->error( 'Error: ' . $parser->error() ||\n        'Unknown error while parsing initial text' );\n      $self->catch_errors( 0 );\n      }\n    return $self;\n    }\n\n  my $self = bless {}, $class;\n\n  my $args = $_[0];\n  $args = { @_ } if ref($args) ne 'HASH';\n\n  $self->_init($args);\n  }\n\nsub DESTROY\n  {\n  my $self = shift;\n \n  # Be carefull to not delete ->{graph}, these will be cleaned out by\n  # Perl automatically in O(1) time, manual delete is O(N) instead.\n\n  delete $self->{chains};\n  # clean out pointers in child-objects so that they can safely be reused\n  for my $n (values %{$self->{nodes}})\n    {\n    if (ref($n))\n      {\n      delete $n->{edges};\n      delete $n->{group};\n      }\n    }\n  for my $e (values %{$self->{edges}})\n    {\n    if (ref($e))\n      {\n      delete $e->{cells};\n      delete $e->{to};\n      delete $e->{from};\n      }\n    }\n  for my $g (values %{$self->{groups}})\n    {\n    if (ref($g))\n      {\n      delete $g->{nodes};\n      delete $g->{edges};\n      }\n    }\n  }\n\n# Attribute overlay for HTML output:\n\nmy $html_att = {\n  node => {\n    borderstyle => 'solid',\n    borderwidth => '1px',\n    bordercolor => '#000000',\n    align => 'center',\n    padding => '0.2em',\n    'padding-left' => '0.3em',\n    'padding-right' => '0.3em',\n    margin => '0.1em',\n    fill => 'white',\n    },\n  'node.anon' => {\n    'borderstyle' => 'none',\n    # ' inherit' to protect the value from being replaced by the one from \"node\"\n    'background' => ' inherit',\n    },\n  graph => {\n    margin => '0.5em',\n    padding => '0.5em',\n    'empty-cells' => 'show',\n    },\n  edge => { \n    border => 'none',\n    padding => '0.2em',\n    margin => '0.1em',\n    'font' => 'monospaced, courier-new, courier, sans-serif',\n    'vertical-align' => 'bottom',\n    },\n  group => { \n    'borderstyle' => 'dashed',\n    'borderwidth' => '1',\n    'fontsize' => '0.8em',\n    fill => '#a0d0ff',\n    padding => '0.2em',\n# XXX TODO:\n# in HTML, align left is default, so we could omit this:\n    align => 'left',\n    },\n  'group.anon' => {\n    'borderstyle' => 'none',\n    background => 'white',\n    },\n  };\n\n\nsub _init\n  {\n  my ($self,$args) = @_;\n\n  $self->{debug} = 0;\n  $self->{timeout} = 5;\t\t\t# in seconds\n  $self->{strict} = 1;\t\t\t# check attributes strict?\n  \n  $self->{class} = 'graph';\n  $self->{id} = '';\n  $self->{groups} = {};\n\n  # node objects, indexed by their unique name\n  $self->{nodes} = {};\n  # edge objects, indexed by unique ID\n  $self->{edges} = {};\n\n  $self->{output_format} = 'html';\n\n  $self->{_astar_bias} = 0.001;\n\n  # default classes to use in add_foo() methods\n  $self->{use_class} = {\n    edge => 'Graph::Easy::Edge',\n    group => 'Graph::Easy::Group',\n    node => 'Graph::Easy::Node',\n  };\n\n  # Graph::Easy will die, Graph::Easy::Parser::Graphviz will warn\n  $self->{_warn_on_unknown_attributes} = 0;\n  $self->{fatal_errors} = 1;\n\n  # The attributes of the graph itself, _and_ the class/subclass attributes.\n  # These can share a hash, because:\n  # *  {att}->{graph} contains both the graph attributes and the class, since\n  #    these are synonymous, it is not possible to have more than one graph.\n  # *  'node', 'group', 'edge' are not valid attributes for a graph, so\n  #    setting \"graph { node: 1; }\" is not possible and can thus not overwrite\n  #    the entries from att->{node}.\n  # *  likewise for \"node.subclass\", attribute names never have a \".\" in them\n  $self->{att} = {};\n\n  foreach my $k (keys %$args)\n    {\n    if ($k !~ /^(timeout|debug|strict|fatal_errors|undirected)\\z/)\n      {\n      $self->error (\"Unknown option '$k'\");\n      }\n    if ($k eq 'undirected' && $args->{$k})\n      {\n      $self->set_attribute('type', 'undirected'); next;\n      }\n    $self->{$k} = $args->{$k};\n    }\n\n  binmode(STDERR,'utf8') or die (\"Cannot do binmode(STDERR,'utf8'\")\n    if $self->{debug};\n\n  $self->{score} = undef;\n\n  $self->randomize();\n\n  $self;\n  }\n\n#############################################################################\n# accessors\n\nsub timeout\n  {\n  my $self = shift;\n\n  $self->{timeout} = $_[0] if @_;\n  $self->{timeout};\n  }\n\nsub debug\n  {\n  my $self = shift;\n\n  $self->{debug} = $_[0] if @_;\n  $self->{debug};\n  }\n\nsub strict\n  {\n  my $self = shift;\n\n  $self->{strict} = $_[0] if @_;\n  $self->{strict};\n  }\n\nsub type\n  {\n  # return the type of the graph, \"undirected\" or \"directed\"\n  my $self = shift;\n\n  $self->{att}->{type} || 'directed';\n  }\n\nsub is_simple\n  {\n  # return true if the graph does not have multiedges\n  my $self = shift;\n\n  my %count;\n  for my $e (values %{$self->{edges}})\n    {\n    my $id = \"$e->{to}->{id},$e->{from}->{id}\";\n    return 0 if exists $count{$id};\n    $count{$id} = undef;\n    }\n\n  1;\t\t\t\t\t# found none\n  }\n\nsub is_directed\n  {\n  # return true if the graph is directed\n  my $self = shift;\n\n  $self->attribute('type') eq 'directed' ? 1 : 0;\n  }\n\nsub is_undirected\n  {\n  # return true if the graph is undirected\n  my $self = shift;\n\n  $self->attribute('type') eq 'undirected' ? 1 : 0;\n  }\n\nsub id\n  {\n  my $self = shift;\n\n  $self->{id} = shift if defined $_[0];\n  $self->{id};\n  }\n\nsub score\n  {\n  my $self = shift;\n\n  $self->{score};\n  }\n\nsub randomize\n  {\n  my $self = shift;\n\n  srand();\n  $self->{seed} = rand(2 ** 31);\n\n  $self->{seed};\n  }\n\nsub root_node\n  {\n  # Return the root node\n  my $self = shift;\n  \n  my $root = $self->{att}->{root};\n  $root = $self->{nodes}->{$root} if defined $root;\n\n  $root;\n  }\n\nsub source_nodes\n  {\n  # return nodes with only outgoing edges\n  my $self = shift;\n\n  my @roots;\n  for my $node (values %{$self->{nodes}})\n    {\n    push @roots, $node \n      if (keys %{$node->{edges}} != 0) && !$node->has_predecessors();\n    }\n  @roots;\n  }\n\nsub predecessorless_nodes\n  {\n  # return nodes with no incoming (but maybe outgoing) edges\n  my $self = shift;\n\n  my @roots;\n  for my $node (values %{$self->{nodes}})\n    {\n    push @roots, $node \n      if (keys %{$node->{edges}} == 0) || !$node->has_predecessors();\n    }\n  @roots;\n  }\n\nsub label\n  {\n  my $self = shift;\n\n  my $label = $self->{att}->{graph}->{label}; $label = '' unless defined $label;\n  $label = $self->_un_escape($label) if !$_[0] && $label =~ /\\\\[EGHNT]/;\n  $label;\n  }\n\nsub link\n  {\n  # return the link, build from linkbase and link (or autolink)\n  my $self = shift;\n\n  my $link = $self->attribute('link');\n  my $autolink = ''; $autolink = $self->attribute('autolink') if $link eq '';\n  if ($link eq '' && $autolink ne '')\n    {\n    $link = $self->{name} if $autolink eq 'name';\n    # defined to avoid overriding \"name\" with the non-existant label attribute\n    $link = $self->{att}->{label} if $autolink eq 'label' && defined $self->{att}->{label};\n    $link = $self->{name} if $autolink eq 'label' && !defined $self->{att}->{label};\n    }\n  $link = '' unless defined $link;\n\n  # prepend base only if link is relative\n  if ($link ne '' && $link !~ /^([\\w]{3,4}:\\/\\/|\\/)/)\n    {\n    $link = $self->attribute('linkbase') . $link;\n    }\n\n  $link = $self->_un_escape($link) if !$_[0] && $link =~ /\\\\[EGHNT]/;\n\n  $link;\n  }\n\nsub parent\n  {\n  # return parent object, for graphs that is undef\n  undef;\n  }\n\nsub seed\n  {\n  my $self = shift;\n\n  $self->{seed} = $_[0] if @_ > 0;\n\n  $self->{seed};\n  }\n\nsub nodes\n  {\n  # return all nodes as objects, in scalar context their count\n  my ($self) = @_;\n\n  my $n = $self->{nodes};\n\n  return scalar keys %$n unless wantarray;\t# shortcut\n\n  values %$n;\n  }\n\nsub anon_nodes\n  {\n  # return all anon nodes as objects\n  my ($self) = @_;\n\n  my $n = $self->{nodes};\n\n  if (!wantarray)\n    {\n    my $count = 0;\n    for my $node (values %$n)\n      {\n      $count++ if $node->is_anon();\n      }\n    return $count;\n    }\n\n  my @anon = ();\n  for my $node (values %$n)\n    {\n    push @anon, $node if $node->is_anon();\n    }\n  @anon;\n  }\n\nsub edges\n  {\n  # Return all the edges this graph contains as objects\n  my ($self) = @_;\n\n  my $e = $self->{edges};\n\n  return scalar keys %$e unless wantarray;\t# shortcut\n\n  values %$e;\n  }\n\nsub edges_within\n  {\n  # return all the edges as objects\n  my ($self) = @_;\n\n  my $e = $self->{edges};\n\n  return scalar keys %$e unless wantarray;\t# shortcut\n\n  values %$e;\n  }\n\nsub sorted_nodes\n  {\n  # return all nodes as objects, sorted by $f1 or $f1 and $f2\n  my ($self, $f1, $f2) = @_;\n\n  return scalar keys %{$self->{nodes}} unless wantarray;\t# shortcut\n\n  $f1 = 'id' unless defined $f1;\n  # sorting on a non-unique field alone will result in unpredictable\n  # sorting order due to hashing\n  $f2 = 'name' if !defined $f2 && $f1 !~ /^(name|id)$/;\n\n  my $sort;\n  $sort = sub { $a->{$f1} <=> $b->{$f1} } if $f1;\n  $sort = sub { abs($a->{$f1}) <=> abs($b->{$f1}) } if $f1 && $f1 eq 'rank';\n  $sort = sub { $a->{$f1} cmp $b->{$f1} } if $f1 && $f1 =~ /^(name|title|label)$/;\n  $sort = sub { $a->{$f1} <=> $b->{$f1} || $a->{$f2} <=> $b->{$f2} } if $f2;\n  $sort = sub { abs($a->{$f1}) <=> abs($b->{$f1}) || $a->{$f2} <=> $b->{$f2} } if $f2 && $f1 eq 'rank';\n  $sort = sub { $a->{$f1} <=> $b->{$f1} || abs($a->{$f2}) <=> abs($b->{$f2}) } if $f2 && $f2 eq 'rank';\n  $sort = sub { $a->{$f1} <=> $b->{$f1} || $a->{$f2} cmp $b->{$f2} } if $f2 &&\n           $f2 =~ /^(name|title|label)$/;\n  $sort = sub { abs($a->{$f1}) <=> abs($b->{$f1}) || $a->{$f2} cmp $b->{$f2} } if \n           $f1 && $f1 eq 'rank' &&\n           $f2 && $f2 =~ /^(name|title|label)$/;\n  # 'name', 'id'\n  $sort = sub { $a->{$f1} cmp $b->{$f1} || $a->{$f2} <=> $b->{$f2} } if $f2 &&\n           $f2 eq 'id' && $f1 ne 'rank';\n\n  # the 'return' here should not be removed\n  return sort $sort values %{$self->{nodes}};\n  }\n\nsub add_edge_once\n  {\n  # add an edge, unless it already exists. In that case it returns undef\n  my ($self, $x, $y, $edge) = @_;\n\n  # got an edge object? Don't add it twice!\n  return undef if ref($edge);\n\n  # turn plaintext scalars into objects \n  my $x1 = $self->{nodes}->{$x} unless ref $x;\n  my $y1 = $self->{nodes}->{$y} unless ref $y;\n\n  # nodes do exist => maybe the edge also exists\n  if (ref($x1) && ref($y1))\n    {\n    my @ids = $x1->edges_to($y1);\n\n    return undef if @ids;\t# found already one edge?\n    }\n\n  $self->add_edge($x,$y,$edge);\n  }\n\nsub edge\n  {\n  # return an edge between two nodes as object\n  my ($self, $x, $y) = @_;\n\n  # turn plaintext scalars into objects \n  $x = $self->{nodes}->{$x} unless ref $x;\n  $y = $self->{nodes}->{$y} unless ref $y;\n\n  # node does not exist => edge does not exist\n  return undef unless ref($x) && ref($y);\n\n  my @ids = $x->edges_to($y);\n  \n  wantarray ? @ids : $ids[0];\n  }\n\nsub flip_edges\n  {\n  # turn all edges going from $x to $y around\n  my ($self, $x, $y) = @_;\n\n  # turn plaintext scalars into objects \n  $x = $self->{nodes}->{$x} unless ref $x;\n  $y = $self->{nodes}->{$y} unless ref $y;\n\n  # node does not exist => edge does not exist\n  # if $x == $y, return early (no need to turn selfloops)\n\n  return $self unless ref($x) && ref($y) && ($x != $y);\n\n  for my $e (values %{$x->{edges}})\n    {\n    $e->flip() if $e->{from} == $x && $e->{to} == $y;\n    }\n\n  $self;\n  }\n\nsub node\n  {\n  # return node by name\n  my ($self,$name) = @_;\n  $name = '' unless defined $name;\n\n  $self->{nodes}->{$name};\n  }\n\nsub rename_node\n  {\n  # change the name of a node\n  my ($self, $node, $new_name) = @_;\n\n  $node = $self->{nodes}->{$node} unless ref($node);\n\n  if (!ref($node))\n    {\n    $node = $self->add_node($new_name);\n    }\n  else\n    {\n    if (!ref($node->{graph}))\n      {\n      # add node to ourself\n      $node->{name} = $new_name;\n      $self->add_node($node);\n      }\n    else\n      {\n      if ($node->{graph} != $self)\n        {\n\t$node->{graph}->del_node($node);\n\t$node->{name} = $new_name;\n\t$self->add_node($node);\n\t}\n      else\n\t{\n\tdelete $self->{nodes}->{$node->{name}};\n\t$node->{name} = $new_name;\n\t$self->{nodes}->{$node->{name}} = $node;\n\t}\n      }\n    }\n  if ($node->is_anon())\n    {\n    # turn anon nodes into a normal node (since it got a new name):\n    bless $node, $self->{use_class}->{node} || 'Graph::Easy::Node';\n    delete $node->{att}->{label} if $node->{att}->{label} eq ' ';\n    $node->{class} = 'group';\n    }\n  $node;\n  }\n\nsub rename_group\n  {\n  # change the name of a group\n  my ($self, $group, $new_name) = @_;\n\n  if (!ref($group))\n    {\n    $group = $self->add_group($new_name);\n    }\n  else\n    {\n    if (!ref($group->{graph}))\n      {\n      # add node to ourself\n      $group->{name} = $new_name;\n      $self->add_group($group);\n      }\n    else\n      {\n      if ($group->{graph} != $self)\n        {\n\t$group->{graph}->del_group($group);\n\t$group->{name} = $new_name;\n\t$self->add_group($group);\n\t}\n      else\n\t{\n\tdelete $self->{groups}->{$group->{name}};\n\t$group->{name} = $new_name;\n\t$self->{groups}->{$group->{name}} = $group;\n\t}\n      }\n    }\n  if ($group->is_anon())\n    {\n    # turn anon groups into a normal group (since it got a new name):\n    bless $group, $self->{use_class}->{group} || 'Graph::Easy::Group';\n    delete $group->{att}->{label} if $group->{att}->{label} eq '';\n    $group->{class} = 'group';\n    }\n  $group;\n  }\n\n#############################################################################\n# attribute handling\n\nsub _check_class\n  {\n  # Check the given class (\"graph\", \"node.foo\" etc.) or class selector\n  # (\".foo\") for being valid, and return a list of base classes this applies\n  # to. Handles also a list of class selectors like \".foo, .bar, node.foo\".\n  my ($self, $selector) = @_;\n\n  my @parts = split /\\s*,\\s*/, $selector;\n\n  my @classes = ();\n  for my $class (@parts)\n    {\n    # allowed classes, subclasses (except \"graph.\"), selectors (excpet \".\")\n    return unless $class =~ /^(\\.\\w|node|group|edge|graph\\z)/;\n    # \"node.\" is invalid, too\n    return if $class =~ /\\.\\z/;\n\n    # run a loop over all classes: \"node.foo\" => (\"node\"), \".foo\" => (\"node\",\"edge\",\"group\")\n    $class =~ /^(\\w*)/; \n    my $base_class = $1; \n    if ($base_class eq '')\n      {\n      push @classes, ('edge'.$class, 'group'.$class, 'node'.$class);\n      }\n    else\n      {\n      push @classes, $class;\n      }\n    } # end for all parts\n\n  @classes;\n  }\n\nsub set_attribute\n  {\n  my ($self, $class_selector, $name, $val) = @_;\n\n  # allow calling in the style of $graph->set_attribute($name,$val);\n  if (@_ == 3)\n    {\n    $val = $name;\n    $name = $class_selector;\n    $class_selector = 'graph';\n    }\n\n  # font-size => fontsize\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  $name = 'undef' unless defined $name;\n  $val = 'undef' unless defined $val;\n\n  my @classes = $self->_check_class($class_selector);\n\n  return $self->error (\"Illegal class '$class_selector' when trying to set attribute '$name' to '$val'\")\n    if @classes == 0;\n\n  for my $class (@classes)\n    {\n    $val = $self->unquote_attribute($class,$name,$val);\n\n    if ($self->{strict})\n      {\n      my ($rc, $newname, $v) = $self->validate_attribute($name,$val,$class);\n      return if defined $rc;\t\t# error?\n\n      $val = $v;\n      }\n\n    $self->{score} = undef;\t# invalidate layout to force a new layout\n    delete $self->{cache};\t# setting a class or flow must invalidate the cache\n\n    # handle special attribute 'gid' like in \"graph { gid: 123; }\"\n    if ($class eq 'graph')\n      {\n      if ($name =~ /^g?id\\z/)\n        {\n        $self->{id} = $val;\n        }\n      # handle special attribute 'output' like in \"graph { output: ascii; }\"\n      if ($name eq 'output')\n        {\n        $self->{output_format} = $val;\n        }\n      }\n\n    my $att = $self->{att};\n    # create hash if it doesn't exist yet\n    $att->{$class} = {} unless ref $att->{$class};\n\n    if ($name eq 'border')\n      {\n      my $c = $att->{$class};\n\n      ($c->{borderstyle}, $c->{borderwidth}, $c->{bordercolor}) =\n\t $self->split_border_attributes( $val );\n\n      return $val;\n      }\n\n    $att->{$class}->{$name} = $val;\n\n    } # end for all selected classes\n\n  $val;\n  }\n\nsub set_attributes\n  {\n  my ($self, $class_selector, $att) = @_;\n\n  # if called as $graph->set_attributes( { color => blue } ), assume\n  # class eq 'graph'\n\n  if (defined $class_selector && !defined $att)\n    {\n    $att = $class_selector; $class_selector = 'graph';\n    }\n\n  my @classes = $self->_check_class($class_selector);\n\n  return $self->error (\"Illegal class '$class_selector' when trying to set attributes\")\n    if @classes == 0;\n\n  foreach my $a (keys %$att)\n    {\n    for my $class (@classes)\n      {\n      $self->set_attribute($class, $a, $att->{$a});\n      }\n    } \n  $self;\n  }\n\nsub del_attribute\n  {\n  # delete the attribute with the name in the selected class(es)\n  my ($self, $class_selector, $name) = @_;\n\n  if (@_ == 2)\n    {\n    $name = $class_selector; $class_selector = 'graph';\n    }\n\n  # font-size => fontsize\n  $name = $att_aliases->{$name} if exists $att_aliases->{$name};\n\n  my @classes = $self->_check_class($class_selector);\n\n  return $self->error (\"Illegal class '$class_selector' when trying to delete attribute '$name'\")\n    if @classes == 0;\n\n  for my $class (@classes)\n    {\n    my $a = $self->{att}->{$class};\n\n    delete $a->{$name};\n    if ($name eq 'size')\n      {\n      delete $a->{rows};\n      delete $a->{columns};\n      }\n    if ($name eq 'border')\n      {\n      delete $a->{borderstyle};\n      delete $a->{borderwidth};\n      delete $a->{bordercolor};\n      }\n    }\n  $self;\n  }\n\n#############################################################################\n\n# for determining the absolute graph flow\nmy $p_flow =\n  {\n  'east' => 90,\n  'west' => 270,\n  'north' => 0,\n  'south' => 180,\n  'up' => 0,\n  'down' => 180,\n  'back' => 270,\n  'left' => 270,\n  'right' => 90,\n  'front' => 90,\n  'forward' => 90,\n  };\n\nsub flow\n  {\n  # return out flow as number\n  my ($self)  = @_;\n\n  my $flow = $self->{att}->{graph}->{flow};\n\n  return 90 unless defined $flow;\n\n  my $f = $p_flow->{$flow}; $f = $flow unless defined $f;\n  $f;\n  }\n\n#############################################################################\n#############################################################################\n# Output (as_ascii, as_html) routines; as_txt() is in As_txt.pm, as_graphml\n# is in As_graphml.pm\n\nsub output_format\n  {\n  # set the output format\n  my $self = shift;\n\n  $self->{output_format} = shift if $_[0];\n  $self->{output_format};\n  }\n\nsub output\n  {\n  # general output routine, to output the graph as the format that was\n  # specified in the graph source itself\n  my $self = shift;\n\n  no strict 'refs';\n\n  my $method = 'as_' . $self->{output_format};\n\n  $self->_croak(\"Cannot find a method to generate '$self->{output_format}'\")\n    unless $self->can($method);\n\n  $self->$method();\n  }\n\nsub _class_styles\n  {\n  # Create the style sheet with the class lists. This is used by both\n  # css() and as_svg(). $skip is a qr// object that returns true for\n  # attribute names to be skipped (e.g. excluded), and $map is a\n  # HASH that contains mapping for attribute names for the output.\n  # \"$base\" is the basename for classes (either \"table.graph$id\" if \n  # not defined, or whatever you pass in, like \"\" for svg).\n  # $indent is a left-indenting spacer like \"  \".\n  # $overlay contains a HASH with attribute-value pairs to set as defaults.\n\n  my ($self, $skip, $map, $base, $indent, $overlay) = @_;\n\n  my $a = $self->{att};\n\n  $indent = '' unless defined $indent;\n  my $indent2 = $indent x 2; $indent2 = '  ' if $indent2 eq '';\n\n  my $class_list = { edge => {}, node => {}, group => {} };\n  if (defined $overlay)\n    {\n    $a = {};\n\n    # make a copy from $self->{att} to $a:\n\n    for my $class (keys %{$self->{att}})\n      {\n      my $ac = $self->{att}->{$class};\n      $a->{$class} = {};\n      my $acc = $a->{$class};\n      for my $k (keys %$ac)\n        {\n        $acc->{$k} = $ac->{$k};\n        }\n      }\n\n    # add the extra keys\n    for my $class (keys %$overlay)\n      {\n      my $oc = $overlay->{$class};\n      # create the hash if it doesn't exist yet\n      $a->{$class} = {} unless ref $a->{$class};\n      my $acc = $a->{$class};\n      for my $k (keys %$oc)\n        {\n        $acc->{$k} = $oc->{$k} unless exists $acc->{$k};\n        }\n      $class_list->{$class} = {};\n      }\n    }\n\n  my $id = $self->{id};\n\n  my @primaries = sort keys %$class_list;\n  foreach my $primary (@primaries)\n    {\n    my $cl = $class_list->{$primary};\t\t\t# shortcut\n    foreach my $class (sort keys %$a)\n      {\n      if ($class =~ /^$primary\\.(.*)/)\n        {\n        $cl->{$1} = undef;\t\t\t\t# note w/o doubles\n        }\n      }\n    }\n\n  $base = \"table.graph$id \" unless defined $base;\n\n  my $groups = $self->groups();\t\t\t\t# do we have groups?\n\n  my $css = '';\n  foreach my $class (sort keys %$a)\n    {\n    next if keys %{$a->{$class}} == 0;\t\t\t# skip empty ones\n\n    my $c = $class; $c =~ s/\\./_/g;\t\t\t# node.city => node_city\n\n    next if $class eq 'group' and $groups == 0;\n\n    my $css_txt = '';\n    my $cls = '';\n    if ($class eq 'graph' && $base eq '')\n      {\n      $css_txt .= \"${indent}.$class \\{\\n\";\t\t\t# for SVG\n      }\n    elsif ($class eq 'graph')\n      {\n      $css_txt .= \"$indent$base\\{\\n\";\n      }\n    else\n      {\n      if ($c !~ /\\./)\t\t\t\t\t# one of our primary ones\n        {\n        # generate also class list \t\t\t# like: \"cities,node_rivers\"\n        $cls = join (\",$base.${c}_\", sort keys %{ $class_list->{$c} });\n        $cls = \",$base.${c}_$cls\" if $cls ne '';\t\t# like: \",node_cities,node_rivers\"\n        }\n      $css_txt .= \"$indent$base.$c$cls {\\n\";\n      }\n    my $done = 0;\n    foreach my $att (sort keys %{$a->{$class}})\n      {\n      # should be skipped?\n      next if $att =~ $skip || $att eq 'border';\n\n      # do not specify attributes for the entire graph (only for the label)\n      # $base ne '' skips this rule for SVG output\n      next if $class eq 'graph' && $base ne '' && $att =~ /^(color|font|fontsize|align|fill)\\z/;\n\n      $done++;\t\t\t\t\t\t# how many did we really?\n      my $val = $a->{$class}->{$att};\n\n      next if !defined $val;\n\n      # for groups, set to none, it will be later overriden for the different\n      # cells (like \"ga\") with a border only on the appropriate side:\n      $val = 'none' if $att eq 'borderstyle' && $class eq 'group';\n      # fix border-widths to be in pixel\n      $val .= 'px' if $att eq 'borderwidth' && $val !~ /(px|em|%)\\z/;\n\n      # for color attributes, convert to hex\n      my $entry = $self->_attribute_entry($class, $att);\n\n      if (defined $entry)\n\t{\n\tmy $type = $entry->[ ATTR_TYPE_SLOT ] || ATTR_STRING;\n\tif ($type == ATTR_COLOR)\n\t  {\n\t  # create as RGB color\n\t  $val = $self->get_color_attribute($class,$att) || $val;\n\t  }\n\t}\n      # change attribute name/value?\n      if (exists $map->{$att})\n\t{\n        $att = $map->{$att} unless ref $map->{$att};\t\t# change attribute name?\n        ($att,$val) = &{$map->{$att}}($self,$att,$val,$class) if ref $map->{$att};\n\t}\n\n      # value is \"inherit\"?\n      if ($class ne 'graph' && $att && $val && $val eq 'inherit')\n        {\n        # get the value from one class \"up\"\n\n\t# node.foo => node, node => graph\n        my $base_class = $class; $base_class = 'graph' unless $base_class =~ /\\./;\n\t$base_class =~ s/\\..*//;\n\n        $val = $a->{$base_class}->{$att};\n\n\tif ($base_class ne 'graph' && (!defined $val || $val eq 'inherit'))\n\t  {\n\t  # node.foo => node, inherit => graph\n          $val = $a->{graph}->{$att};\n\t  $att = undef if !defined $val;\n\t  }\n\t}\n\n      $css_txt .= \"$indent2$att: $val;\\n\" if defined $att && defined $val;\n      }\n\n    $css_txt .= \"$indent}\\n\";\n    $css .= $css_txt if $done > 0;\t\t\t# skip if no attributes at all\n    }\n  $css;\n  }\n\nsub _skip\n  {\n  # return a regexp that specifies which attributes to suppress in CSS\n  my ($self) = shift;\n\n  # skip these for CSS\n  qr/^(basename|columns|colorscheme|comment|class|flow|format|group|rows|root|size|offset|origin|linkbase|(auto)?(label|link|title)|auto(join|split)|(node|edge)class|shape|arrowstyle|label(color|pos)|point(style|shape)|textstyle|style)\\z/;\n  }\n\n#############################################################################\n# These routines are used by as_html for the generation of CSS\n\nsub _remap_text_wrap\n  {\n  my ($self,$name,$style) = @_;\n\n  return (undef,undef) if $style ne 'auto';\n\n  # make text wrap again\n  ('white-space','normal');\n  }\n\nsub _remap_fill\n  {\n  my ($self,$name,$color,$class) = @_;\n\n  return ('background',$color) unless $class =~ /edge/;\n\n  # for edges, the fill is ignored\n  (undef,undef);\n  }\n\n#############################################################################\n\nsub css\n  {\n  my $self = shift;\n\n  my $a = $self->{att};\n  my $id = $self->{id};\n\n  # for each primary class (node/group/edge) we need to find all subclasses,\n  # and list them in the CSS, too. Otherwise \"node_city\" would not inherit\n  # the attributes from \"node\".\n\n  my $css = $self->_class_styles( $self->_skip(),\n    {\n      fill => \\&_remap_fill,\n      textwrap => \\&_remap_text_wrap,\n      align => 'text-align',\n      font => 'font-family',\n      fontsize => 'font-size',\n      bordercolor => 'border-color',\n      borderstyle => 'border-style',\n      borderwidth => 'border-width',\n    },\n    undef,\n    undef, \n    $html_att,\n    );\n\n  my @groups = $self->groups();\n\n  # Set attributes for all TDs that start with \"group\":\n  $css .= <<CSS\ntable.graph##id## td[class|=\"group\"] { padding: 0.2em; }\nCSS\n  if @groups > 0;\n\n  $css .= <<CSS\ntable.graph##id## td {\n  padding: 2px;\n  background: inherit;\n  white-space: nowrap;\n  }\ntable.graph##id## span.l { float: left; }\ntable.graph##id## span.r { float: right; }\nCSS\n;\n\n  # append CSS for edge cells (and their parts like va (vertical arrow\n  # (left/right), vertical empty), etc)\n\n  # eb\t- empty bottom or arrow pointing down/up\n  # el  - (vertical) empty left space of ver edge\n  #       or empty vertical space on hor edge starts\n  # lh  - edge label horizontal\n  # le  - edge label, but empty (no label)\n  # lv  - edge label vertical\n  # sh  - shifted arrow horizontal (shift right)\n  # sa  - shifted arrow horizontal (shift left for corners)\n  # shl - shifted arrow horizontal (shift left)\n  # sv  - shifted arrow vertical (pointing down)\n  # su  - shifted arrow vertical (pointing up)\n\n  $css .= <<CSS\ntable.graph##id## .va {\n  vertical-align: middle;\n  line-height: 1em;\n  width: 0.4em;\n  }\ntable.graph##id## .el {\n  width: 0.1em;\n  max-width: 0.1em;\n  min-width: 0.1em;\n  }\ntable.graph##id## .lh, table.graph##id## .lv {\n  font-size: 0.8em;\n  padding-left: 0.4em;\n  }\ntable.graph##id## .sv, table.graph##id## .sh, table.graph##id## .shl, table.graph##id## .sa, table.graph##id## .su {\n  max-height: 1em;\n  line-height: 1em;\n  position: relative;\n  top: 0.55em;\n  left: -0.3em;\n  overflow: visible;\n  }\ntable.graph##id## .sv, table.graph##id## .su {\n  max-height: 0.5em;\n  line-height: 0.5em;\n  }\ntable.graph##id## .shl { left: 0.3em; }\ntable.graph##id## .sv { left: -0.5em; top: -0.4em; }\ntable.graph##id## .su { left: -0.5em; top: 0.4em; }\ntable.graph##id## .sa { left: -0.3em; top: 0; }\ntable.graph##id## .eb { max-height: 0; line-height: 0; height: 0; }\nCSS\n  # if we have edges\n  if keys %{$self->{edges}}  > 0;\n\n  # if we have nodes with rounded shapes:\n  my $rounded = 0;\n  for my $n (values %{$self->{nodes}})\n    {\n    $rounded ++ and last if $n->shape() =~ /circle|ellipse|rounded/;\n    }\n\n  $css .= <<CSS\ntable.graph##id## span.c { position: relative; top: 1.5em; }\ntable.graph##id## div.c { -moz-border-radius: 100%; border-radius: 100%; }\ntable.graph##id## div.r { -moz-border-radius: 1em; border-radius: 1em; }\nCSS\n  if $rounded > 0;\n\n  # append CSS for group cells (only if we actually have groups)\n\n  if (@groups > 0)\n    {\n    foreach my $group (@groups)\n      {\n      my $class = $group->class();\n\n      my $border = $group->attribute('borderstyle'); \n\n      $class =~ s/.*\\.//;\t# leave only subclass\n      $css .= Graph::Easy::Group::Cell->_css($self->{id}, $class, $border); \n      }\n    }\n\n  # replace the id with either '' or '123', depending on our ID\n  $css =~ s/##id##/$id/g;\n\n  $css;\n  }\n\nsub html_page_header\n  {\n  # return the HTML header for as_html_file()\n  my ($self, $css) = @_;\n  \n  my $html = <<HTML\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n <head>\n <meta http-equiv=\"Content-Type\" content=\"text/html; charset=##charset##\">\n <title>##title##</title>##CSS##\n</head>\n<body bgcolor=white text=black>\nHTML\n;\n\n  $html =~ s/\\n\\z//;\n  $html =~ s/##charset##/utf-8/g;\n  my $t = $self->title();\n  $html =~ s/##title##/$t/g;\n\n  # insert CSS if requested\n  $css = $self->css() unless defined $css;\n\n  $html =~ s/##CSS##/\\n <style type=\"text\\/css\">\\n <!--\\n $css -->\\n <\\/style>/ if $css ne '';\n  $html =~ s/##CSS##//;\n\n  $html;\n  }\n\nsub title\n  {\n  my $self = shift;\n\n  my $title = $self->{att}->{graph}->{title};\n  $title = $self->{att}->{graph}->{label} if !defined $title;\n  $title = 'Untitled graph' if !defined $title;\n\n  $title = $self->_un_escape($title, 1) if !$_[0] && $title =~ /\\\\[EGHNTL]/;\n  $title;\n  }\n\nsub html_page_footer\n  {\n  # return the HTML footer for as_html_file()\n  my $self = shift;\n\n  \"\\n</body></html>\\n\";\n  }\n\nsub as_html_file\n  {\n  my $self = shift;\n\n  $self->html_page_header() . $self->as_html() . $self->html_page_footer();\n  }\n\n#############################################################################\n\nsub _caption\n  {\n  # create the graph label as caption\n  my $self = shift;\n\n  my ($caption,$switch_to_center) = $self->_label_as_html();\n\n  return ('','') unless defined $caption && $caption ne '';\n\n  my $bg = $self->raw_color_attribute('fill');\n\n  my $style = ' style=\"';\n  $style .= \"background: $bg;\" if $bg;\n    \n  # the font family\n  my $f = $self->raw_attribute('font') || '';\n  $style .= \"font-family: $f;\" if $f ne '';\n\n  # the text color\n  my $c = $self->raw_color_attribute('color');\n  $style .= \"color: $c;\" if $c;\n\n  # bold, italic, underline, incl. fontsize and align\n  $style .= $self->text_styles_as_css();\n\n  $style =~ s/;\\z//;\t\t\t\t# remove last ';'\n  $style .= '\"' unless $style eq ' style=\"';\n\n  $style =~ s/style=\"\\s/style=\"/;\t\t# remove leading space\n\n  my $link = $self->link();\n\n  if ($link ne '')\n    {\n    # encode critical entities\n    $link =~ s/\\s/\\+/g;\t\t\t\t# space\n    $link =~ s/'/%27/g;\t\t\t\t# replace quotation marks\n    $caption = \"<a href='$link'>$caption</a>\";\n    }\n\n  $caption = \"<tr>\\n  <td colspan=##cols##$style>$caption</td>\\n</tr>\\n\";\n\n  my $pos = $self->attribute('labelpos');\n\n  ($caption,$pos);\n  } \n\nsub as_html\n  {\n  # convert the graph to HTML+CSS\n  my ($self) = shift;\n\n  $self->layout() unless defined $self->{score};\n\n  my $top = \"\\n\" . $self->quoted_comment();\n  \n  my $cells = $self->{cells};\n  my ($rows,$cols);\n  \n  my $max_x = undef;\n  my $min_x = undef;\n\n  # find all x and y occurances to sort them by row/columns\n  for my $k (keys %$cells)\n    {\n    my ($x,$y) = split/,/, $k;\n    my $node = $cells->{$k};\n\n    $max_x = $x if !defined $max_x || $x > $max_x;\n    $min_x = $x if !defined $min_x || $x < $min_x;\n    \n    # trace the rows we do have\n    $rows->{$y}->{$x} = $node;\n    # record all possible columns\n    $cols->{$x} = undef;\n    }\n  \n  $max_x = 1, $min_x = 1 unless defined $max_x;\n  \n  # number of cells in the table, maximum  \n  my $max_cells = $max_x - $min_x + 1;\n  \n  my $groups = scalar $self->groups();\n\n  my $id = $self->{id};\n\n  $top .=  \"\\n<table class=\\\"graph$id\\\" cellpadding=0 cellspacing=0\";\n  $top .= \">\\n\";\n\n  my $html = '';\n\n  # prepare the graph label\n  my ($caption,$pos) = $self->_caption();\n\n  my $row_id = 0;\n  # now run through all rows, and for each of them through all columns \n  for my $y (sort { ($a||0) <=> ($b||0) } keys %$rows)\n    {\n\n    # four rows at a time\n    my $rs = [ [], [], [], [] ];\n\n    # for all possible columns\n    for my $x (sort { $a <=> $b } keys %$cols)\n      {\n      if (!exists $rows->{$y}->{$x})\n\t{\n\t# fill empty spaces with undef, but not for parts of multicelled objects:\n\tpush @{$rs->[0]}, undef;\n\tnext;\n\t}\n      my $node = $rows->{$y}->{$x};\n      next if $node->isa('Graph::Easy::Node::Cell');\t\t# skip empty cells\n\n      my $h = $node->as_html();\n\n      if (ref($h) eq 'ARRAY')\n        {\n        #print STDERR '# expected 4 rows, but got ' . scalar @$h if @$h != 4;\n        local $_; my $i = 0;\n        push @{$rs->[$i++]}, $_ for @$h;\n        }\n      else\n        {\n        push @{$rs->[0]}, $h;\n        }\n      }\n\n    ######################################################################\n    # remove trailing empty tag-pairs, then replace undef with empty tags\n\n    for my $row (@$rs)\n      {\n      pop @$row while (@$row > 0 && !defined $row->[-1]);\n      local $_;\n      foreach (@$row)\n        {\n        $_ = \" <td colspan=4 rowspan=4></td>\\n\" unless defined $_;\n        }\n      }\n\n    # now combine equal columns to shorten output\n    for my $row (@$rs)\n      {\n      next;\n\n      # append row to output\n      my $i = 0;\n      while ($i < @$row)\n        {\n        next if $row->[$i] =~ /border(:|-left)/;\n#        next if $row->[$i] !~ />(\\&nbsp;)?</;\t# non-empty?\n#        next if $row->[$i] =~ /span /;\t\t# non-empty?\n#        next if $row->[$i] =~ /^(\\s|\\n)*\\z/;\t# empty?\n\n\t# Combining these cells shows wierd artefacts when using the Firefox\n\t# WebDeveloper toolbar and outlining table cells, but it does not\n\t# seem to harm rendering in browsers:\n        #next if $row->[$i] =~ /class=\"[^\"]+ eb\"/;\t# is class=\".. eb\"\n\n\t# contains wo succ. cell?\n        next if $row->[$i] =~ /(row|col)span.*\\1span/m;\t\n\n        # count all sucessive equal ones\n        my $j = $i + 1;\n\n        $j++ while ($j < @$row && $row->[$j] eq $row->[$i]); # { $j++; }\n\n        if ($j > $i + 1)\n          {\n          my $cnt = $j - $i - 1;\n\n#         print STDERR \"combining row $i to $j ($cnt) (\\n'$row->[$i]'\\n'$row->[$i+1]'\\n'$row->[$j-1]'\\n\";\n\n          # throw away\n          splice (@$row, $i + 1, $cnt);\n\n          # insert empty colspan if not already there\n          $row->[$i] =~ s/<td/<td colspan=0/ unless $row->[$i] =~ /colspan/;\n          # replace\n          $row->[$i] =~ s/colspan=(\\d+)/'colspan='.($1+$cnt*4)/e;\n          }\n        } continue { $i++; }\n      }\n\n    ######################################################################\n\n    my $i = 0;    \n    for my $row (@$rs)\n      {\n      # append row to output\n      my $r = join('',@$row);\n\n      if ($r !~ s/^[\\s\\n]*\\z//)\n\t{\n        # non empty rows get \"\\n</tr>\"\n        $r = \"\\n\" . $r; # if length($r) > 0;\n        }\n\n      $html .= \"<!-- row $row_id line $i -->\\n\" . '<tr>' . $r . \"</tr>\\n\\n\";\n      $i++;\n      }\n    $row_id++;\n    }\n\n  ###########################################################################\n  # finally insert the graph label\n  $max_cells *= 4;\t\t\t\t\t# 4 rows for each cell\n  $caption =~ s/##cols##/$max_cells/ if defined $caption;\n\n  $html .= $caption if $pos eq 'bottom';\n  $top .= $caption if $pos eq 'top';\n\n  $html = $top . $html;\n\n  # remove empty trailing <tr></tr> pairs\n  $html =~ s#(<tr></tr>\\n\\n)+\\z##;\n\n  $html .= \"</table>\\n\";\n \n  $html;\n  } \n\n############################################################################# \n# as_boxart_*\n  \nsub as_boxart\n  {\n  # Create box-drawing art using Unicode characters - will return utf-8.\n  my ($self) = shift;\n\n  require Graph::Easy::As_ascii;\n  \n  # select Unicode box drawing characters\n  $self->{_ascii_style} = 1;\n\n  $self->_as_ascii(@_);\n  }\n\nsub as_boxart_html\n  {\n  # Output a box-drawing using Unicode, then return it as a HTML chunk\n  # suitable to be embedded into an HTML page.\n  my ($self) = shift;\n\n  \"<pre style='line-height: 1em; line-spacing: 0;'>\\n\" . \n    $self->as_boxart(@_) . \n    \"\\n</pre>\\n\";\n  }\n\nsub as_boxart_html_file\n  {\n  my $self = shift;\n\n  $self->layout() unless defined $self->{score};\n\n  $self->html_page_header(' ') . \"\\n\" . \n    $self->as_boxart_html() . $self->html_page_footer();\n  }\n\n#############################################################################\n# as_ascii_*\n\nsub as_ascii\n  {\n  # Convert the graph to pretty ASCII art - will return utf-8.\n  my $self = shift;\n\n  # select 'ascii' characters\n  $self->{_ascii_style} = 0;\n\n  $self->_as_ascii(@_);\n  }\n\nsub _as_ascii\n  {\n  # Convert the graph to pretty ASCII or box art art - will return utf-8.\n  my $self = shift;\n\n  require Graph::Easy::As_ascii;\n  require Graph::Easy::Layout::Grid;\n\n  my $opt = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };\n\n  # include links?\n  $self->{_links} = $opt->{links};\n\n  $self->layout() unless defined $self->{score};\n\n  # generate for each cell the width/height etc\n\n  my ($rows,$cols,$max_x,$max_y) = $self->_prepare_layout('ascii');\n  my $cells = $self->{cells};\n\n  # offset where to draw the graph (non-zero if graph has label)\n  my $y_start = 0;\n  my $x_start = 0;\n\n  my $align = $self->attribute('align');\n\n  # get the label lines and their alignment\n  my ($label,$aligns) = $self->_aligned_label($align);\n\n  # if the graph has a label, reserve space for it\n  my $label_pos = 'top';\n  if (@$label > 0)\n    {\n    # insert one line over and below\n    unshift @$label, '';   push @$label, '';\n    unshift @$aligns, 'c'; push @$aligns, 'c';\n\n    $label_pos = $self->attribute('graph','label-pos') || 'top';\n    $y_start += scalar @$label if $label_pos eq 'top';\n    $max_y += scalar @$label + 1;\n    print STDERR \"# Graph with label, position $label_pos\\n\" if $self->{debug};\n\n    my $old_max_x = $max_x;\n    # find out the dimensions of the label and make sure max_x is big enough\n    for my $l (@$label)\n      {\n      $max_x = length($l)+2 if (length($l) > $max_x+2);\n      }\n    $x_start = int(($max_x - $old_max_x) / 2);\n    }\n\n  print STDERR \"# Allocating framebuffer $max_x x $max_y\\n\" if $self->{debug};\n\n  # generate the actual framebuffer for the output\n  my $fb = Graph::Easy::Node->_framebuffer($max_x, $max_y);\n\n  # output the label\n  if (@$label > 0)\n    {\n    my $y = 0; $y = $max_y - scalar @$label if $label_pos eq 'bottom';\n    Graph::Easy::Node->_printfb_aligned($fb, 0, $y, $max_x, $max_y, $label, $aligns, 'top');\n    }\n\n  # draw all cells into framebuffer\n  foreach my $v (values %$cells)\n    {\n    next if $v->isa('Graph::Easy::Node::Cell');\t\t# skip empty cells\n\n    # get as ASCII box\n    my $x = $cols->{ $v->{x} } + $x_start;\n    my $y = $rows->{ $v->{y} } + $y_start;\n \n    my @lines = split /\\n/, $v->as_ascii($x,$y);\n    # get position from cell\n    for my $i (0 .. scalar @lines-1)\n      {\n      next if length($lines[$i]) == 0;\n      # XXX TODO: framebuffer shouldn't be to small!\n      $fb->[$y+$i] = ' ' x $max_x if !defined $fb->[$y+$i];\n      substr($fb->[$y+$i], $x, length($lines[$i])) = $lines[$i]; \n      }\n    }\n\n  for my $y (0..$max_y)\n    {\n    $fb->[$y] = '' unless defined $fb->[$y];\n    $fb->[$y] =~ s/\\s+\\z//;\t\t# remove trailing whitespace\n    }\n  my $out = join(\"\\n\", @$fb) . \"\\n\";\n\n  $out =~ s/\\n+\\z/\\n/;\t\t# remove trailing empty lines\n\n  # restore height/width of cells from minw/minh\n  foreach my $v (values %$cells)\n    {\n    $v->{h} = $v->{minh};\n    $v->{w} = $v->{minw};\n    } \n  $out;\t\t\t\t# return output\n  }\n\nsub as_ascii_html\n  {\n  # Convert the graph to pretty ASCII art, then return it as a HTML chunk\n  # suitable to be embedded into an HTML page.\n  my ($self) = shift;\n\n  \"<pre>\\n\" . $self->_as_ascii(@_) . \"\\n</pre>\\n\";\n  }\n\n#############################################################################\n# as_txt, as_debug, as_graphviz\n\nsub as_txt\n  {\n  require Graph::Easy::As_txt;\n\n  _as_txt(@_);\n  }\n\nsub as_graphviz\n  {\n  require Graph::Easy::As_graphviz;\n\n  _as_graphviz(@_);\n  }\n\nsub as_debug\n  {\n  require Graph::Easy::As_txt;\n  eval { require Graph::Easy::As_svg; };\n\n  my $self = shift;\n\n  my $output = '';\n \n  $output .= '# Using Graph::Easy v' . $Graph::Easy::VERSION . \"\\n\";\n  if ($Graph::Easy::As_svg::VERSION)\n    {\n    $output .= '# Using Graph::Easy::As_svg v' . $Graph::Easy::As_svg::VERSION . \"\\n\";\n    }\n  $output .= '# Running Perl v' . $] . \" under $^O\\n\";\n\n  $output . \"\\n# Input normalized as_txt:\\n\\n\" . $self->_as_txt(@_);\n  }\n\n#############################################################################\n# as_vcg(as_gdl\n\nsub as_vcg\n  {\n  require Graph::Easy::As_vcg;\n\n  _as_vcg(@_);\n  }\n\nsub as_gdl\n  {\n  require Graph::Easy::As_vcg;\n\n  _as_vcg(@_, { gdl => 1 });\n  }\n\n#############################################################################\n# as_svg\n\nsub as_svg\n  {\n  require Graph::Easy::As_svg;\n  require Graph::Easy::Layout::Grid;\n\n  _as_svg(@_);\n  }\n\nsub as_svg_file\n  {\n  require Graph::Easy::As_svg;\n  require Graph::Easy::Layout::Grid;\n\n  _as_svg( $_[0], { standalone => 1 } );\n  }\n\nsub svg_information\n  {\n  my ($self) = @_;\n\n  require Graph::Easy::As_svg;\n  require Graph::Easy::Layout::Grid;\n\n  # if it doesn't exist, render as SVG and thus create it\n  _as_svg(@_) unless $self->{svg_info};\n\n  $self->{svg_info};\n  }\n\n#############################################################################\n# as_graphml\n\nsub as_graphml\n  {\n  require Graph::Easy::As_graphml;\n\n  _as_graphml(@_);\n  }\n\n#############################################################################\n\nsub add_edge\n  {\n  my ($self,$x,$y,$edge) = @_;\n \n  my $uc = $self->{use_class};\n\n  my $ec = $uc->{edge};\n  $edge = $ec->new() unless defined $edge;\n  $edge = $ec->new(label => $edge) unless ref($edge);\n\n  $self->_croak(\"Adding an edge object twice is not possible\")\n    if (exists ($self->{edges}->{$edge->{id}}));\n\n  $self->_croak(\"Cannot add edge $edge ($edge->{id}), it already belongs to another graph\")\n    if ref($edge->{graph}) && $edge->{graph} != $self;\n\n  my $nodes = $self->{nodes};\n  my $groups = $self->{groups};\n\n  $self->_croak(\"Cannot add edge for undefined node names ($x -> $y)\")\n    unless defined $x && defined $y;\n\n  my $xn = $x; my $yn = $y;\n  $xn = $x->{name} if ref($x);\n  $yn = $y->{name} if ref($y);\n\n  # convert plain scalars to Node objects if nec.\n\n  # XXX TODO: this might be a problem when adding an edge from a group with the same\n  #           name as a node\n\n  $x = $nodes->{$xn} if exists $nodes->{$xn};\t\t# first look them up\n  $y = $nodes->{$yn} if exists $nodes->{$yn};\n\n  $x = $uc->{node}->new( $x ) unless ref $x;\t\t# if this fails, create\n  $y = $x if !ref($y) && $y eq $xn;\t\t\t# make add_edge('A','A') work\n  $y = $uc->{node}->new( $y ) unless ref $y;\n\n  print STDERR \"# add_edge '$x->{name}' ($x->{id}) -> '$y->{name}' ($y->{id}) (edge $edge->{id}) ($x -> $y)\\n\" if $self->{debug};\n\n  for my $n ($x,$y)\n    {\n    $self->_croak(\"Cannot add node $n ($n->{name}), it already belongs to another graph\")\n      if ref($n->{graph}) && $n->{graph} != $self;\n    }\n\n  # Register the nodes and the edge with our graph object\n  # and weaken the references. Be carefull to not needlessly\n  # override and weaken again an already existing reference, this\n  # is an O(N) operation in most Perl versions, and thus very slow.\n\n  weaken($x->{graph} = $self) unless ref($x->{graph});\n  weaken($y->{graph} = $self) unless ref($y->{graph});\n  weaken($edge->{graph} = $self) unless ref($edge->{graph});\n\n  # Store at the edge from where to where it goes for easier reference\n  $edge->{from} = $x;\n  $edge->{to} = $y;\n \n  # store the edge at the nodes/groups, too\n  $x->{edges}->{$edge->{id}} = $edge;\n  $y->{edges}->{$edge->{id}} = $edge;\n\n  # index nodes by their name so that we can find $x from $x->{name} fast\n  my $store = $nodes; $store = $groups if $x->isa('Graph::Easy::Group');\n  $store->{$x->{name}} = $x;\n  $store = $nodes; $store = $groups if $y->isa('Graph::Easy::Group');\n  $store->{$y->{name}} = $y;\n\n  # index edges by \"edgeid\" so we can find them fast\n  $self->{edges}->{$edge->{id}} = $edge;\n\n  $self->{score} = undef;\t\t\t# invalidate last layout\n\n  wantarray ? ($x,$y,$edge) : $edge;\n  }\n\nsub add_anon_node\n  {\n  my ($self) = shift;\n\n  $self->warn('add_anon_node does not take argumens') if @_ > 0;\n\n  my $node = Graph::Easy::Node::Anon->new();\n\n  $self->add_node($node);\n\n  $node;\n  }\n\nsub add_node\n  {\n  my ($self,$x) = @_;\n\n  my $n = $x;\n  if (ref($x))\n    {\n    $n = $x->{name}; $n = '0' unless defined $n;\n    }\n\n  return $self->_croak(\"Cannot add node with empty name to graph.\") if $n eq '';\n\n  return $self->_croak(\"Cannot add node $x ($n), it already belongs to another graph\")\n    if ref($x) && ref($x->{graph}) && $x->{graph} != $self;\n\n  my $no = $self->{nodes};\n  # already exists?\n  return $no->{$n} if exists $no->{$n};\n\n  my $uc = $self->{use_class};\n  $x = $uc->{node}->new( $x ) unless ref $x;\n\n  # store the node\n  $no->{$n} = $x;\n\n  # Register the nodes and the edge with our graph object\n  # and weaken the references. Be carefull to not needlessly\n  # override and weaken again an already existing reference, this\n  # is an O(N) operation in most Perl versions, and thus very slow.\n\n  weaken($x->{graph} = $self) unless ref($x->{graph});\n\n  $self->{score} = undef;\t\t\t# invalidate last layout\n\n  $x;\n  }\n\nsub add_nodes\n  {\n  my $self = shift;\n\n  my @rc;\n  for my $x (@_)\n    {\n    my $n = $x;\n    if (ref($x))\n      {\n      $n = $x->{name}; $n = '0' unless defined $n;\n      }\n\n    return $self->_croak(\"Cannot add node with empty name to graph.\") if $n eq '';\n\n    return $self->_croak(\"Cannot add node $x ($n), it already belongs to another graph\")\n      if ref($x) && ref($x->{graph}) && $x->{graph} != $self;\n\n    my $no = $self->{nodes};\n    # this one already exists\n    next if exists $no->{$n};\n\n    my $uc = $self->{use_class};\n    # make it work with read-only scalars:\n    my $xx = $x;\n    $xx = $uc->{node}->new( $x ) unless ref $x;\n\n    # store the node\n    $no->{$n} = $xx;\n\n    # Register the nodes and the edge with our graph object\n    # and weaken the references. Be carefull to not needlessly\n    # override and weaken again an already existing reference, this\n    # is an O(N) operation in most Perl versions, and thus very slow.\n\n    weaken($xx->{graph} = $self) unless ref($xx->{graph});\n\n    push @rc, $xx;\n    }\n\n  $self->{score} = undef;\t\t\t# invalidate last layout\n\n  @rc;\n  }\n\n#############################################################################\n#############################################################################\n# Cloning/merging of graphs and objects\n\nsub copy\n  {\n  # create a copy of this graph and return it as new graph\n  my $self = shift;\n\n  my $new = Graph::Easy->new();\n\n  # clone all the settings\n  for my $k (keys %$self)\n    {\n    $new->{$k} = $self->{$k} unless ref($self->{$k});\n    }\n\n  for my $g (keys %{$self->{groups}})\n    {\n    my $ng = $new->add_group($g);\n    # clone the attributes\n    $ng->{att} = $self->_clone( $self->{groups}->{$g}->{att} );\n    }\n  for my $n (values %{$self->{nodes}})\n    {\n    my $nn = $new->add_node($n->{name});\n    # clone the attributes\n    $nn->{att} = $self->_clone( $n->{att} );\n    # restore group membership for the node\n    $nn->add_to_group( $n->{group}->{name} ) if $n->{group};\n    }\n  for my $e (values %{$self->{edges}})\n    {\n    my $ne = $new->add_edge($e->{from}->{name}, $e->{to}->{name} );\n    # clone the attributes\n    $ne->{att} = $self->_clone( $e->{att} );\n    }\n  # clone the attributes\n  $new->{att} = $self->_clone( $self->{att});\n\n  $new;\n  }\n\nsub _clone\n  {\n  # recursively clone a data structure\n  my ($self,$in) = @_;\n\n  my $out = { };\n\n  for my $k (keys %$in)\n    {\n    if (ref($k) eq 'HASH')\n      {\n      $out->{$k} = $self->_clone($in->{$k});\n      }\n    elsif (ref($k))\n      {\n      $self->error(\"Can't clone $k\");\n      }\n    else\n      {\n      $out->{$k} = $in->{$k};\n      }\n    }\n  $out;\n  }\n\nsub merge_nodes\n  {\n  # Merge two nodes, by dropping all connections between them, and then\n  # drawing all connections from/to $B to $A, then drop $B\n  my ($self, $A, $B, $joiner) = @_;\n\n  $A = $self->node($A) unless ref($A);\n  $B = $self->node($B) unless ref($B);\n\n  # if the node is part of a group, deregister it first from there\n  $B->{group}->del_node($B) if ref($B->{group});\n\n  my @edges = values %{$A->{edges}};\n\n  # drop all connections from A --> B\n  for my $edge (@edges)\n    {\n    next unless $edge->{to} == $B;\n\n#    print STDERR \"# dropping $edge->{from}->{name} --> $edge->{to}->{name}\\n\";\n    $self->del_edge($edge);\n    }\n\n  # Move all edges from/to B over to A, but drop \"B --> B\" and \"B --> A\".\n  for my $edge (values %{$B->{edges}})\n    {\n    # skip if going from B --> A or B --> B\n    next if $edge->{to} == $A || ($edge->{to} == $B && $edge->{from} == $B);\n\n#    print STDERR \"# moving $edge->{from}->{name} --> $edge->{to}->{name} to \";\n\n    $edge->{from} = $A if $edge->{from} == $B;\n    $edge->{to} = $A if $edge->{to} == $B;\n\n#   print STDERR \" $edge->{from}->{name} --> $edge->{to}->{name}\\n\";\n\n    delete $B->{edges}->{$edge->{id}};\n    $A->{edges}->{$edge->{id}} = $edge;\n    }\n\n  # should we join the label from B to A?\n  $A->set_attribute('label', $A->label() . $joiner . $B->label() ) if defined $joiner;\n\n  $self->del_node($B);\n\n  $self;\n  }\n\n#############################################################################\n# deletion\n\nsub del_node\n  {\n  my ($self, $node) = @_;\n\n  # make object\n  $node = $self->{nodes}->{$node} unless ref($node);\n\n  # doesn't exist, so we don't need to do anything\n  return unless ref($node);\n\n  # if node is part of a group, delete it there, too\n  $node->{group}->del_node($node) if ref $node->{group};\n\n  delete $self->{nodes}->{$node->{name}};\n\n  # delete all edges from/to this node\n  for my $edge (values %{$node->{edges}})\n    {\n    # drop the edge from our global edge list\n    delete $self->{edges}->{$edge->{id}};\n \n    my $to = $edge->{to}; my $from = $edge->{from};\n\n    # drop the edge from the other node\n    delete $from->{edges}->{$edge->{id}} if $from != $node;\n    delete $to->{edges}->{$edge->{id}} if $to != $node;\n    }\n\n  # decouple node from the graph\n  $node->{graph} = undef;\n  # reset cached size\n  $node->{w} = undef;\n\n  # drop all edges from the node locally\n  $node->{edges} = { };\n\n  # if the node is a child of another node, deregister it there\n  delete $node->{origin}->{children}->{$node->{id}} if defined $node->{origin};\n\n  $self->{score} = undef;\t\t\t# invalidate last layout\n\n  $self;\n  }\n\nsub del_edge\n  {\n  my ($self, $edge) = @_;\n\n  $self->_croak(\"del_edge() needs an object\") unless ref $edge;\n\n  # if edge is part of a group, delete it there, too\n  $edge->{group}->_del_edge($edge) if ref $edge->{group};\n\n  my $to = $edge->{to}; my $from = $edge->{from};\n\n  # delete the edge from the nodes\n  delete $from->{edges}->{$edge->{id}};\n  delete $to->{edges}->{$edge->{id}};\n  \n  # drop the edge from our global edge list\n  delete $self->{edges}->{$edge->{id}};\n\n  $edge->{from} = undef;\n  $edge->{to} = undef;\n\n  $self;\n  }\n\n#############################################################################\n# group management\n\nsub add_group\n  {\n  # add a group object\n  my ($self,$group) = @_;\n\n  my $uc = $self->{use_class};\n\n  # group with that name already exists?\n  my $name = $group; \n  $group = $self->{groups}->{ $group } unless ref $group;\n\n  # group with that name doesn't exist, so create new one\n  $group = $uc->{group}->new( name => $name ) unless ref $group;\n\n  # index under the group name for easier lookup\n  $self->{groups}->{ $group->{name} } = $group;\n\n  # register group with ourself and weaken the reference\n  $group->{graph} = $self;\n  {\n    no warnings; # dont warn on already weak references\n    weaken($group->{graph});\n  } \n  $self->{score} = undef;\t\t\t# invalidate last layout\n\n  $group;\n  }\n\nsub del_group\n  {\n  # delete group\n  my ($self,$group) = @_;\n\n  delete $self->{groups}->{ $group->{name} };\n \n  $self->{score} = undef;\t\t\t# invalidate last layout\n\n  $self;\n  }\n\nsub group\n  {\n  # return group by name\n  my ($self,$name) = @_;\n\n  $self->{groups}->{ $name };\n  }\n\nsub groups\n  {\n  # return number of groups (or groups as object list)\n  my ($self) = @_;\n\n  return sort { $a->{name} cmp $b->{name} } values %{$self->{groups}}\n    if wantarray;\n\n  scalar keys %{$self->{groups}};\n  }\n\nsub groups_within\n  {\n  # Return the groups that are directly inside this graph/group. The optional\n  # level is either -1 (meaning return all groups contained within), or a\n  # positive number indicating how many levels down we need to go.\n  my ($self, $level) = @_;\n\n  $level = -1 if !defined $level || $level < 0;\n\n  # inline call to $self->groups;\n  if ($level == -1)\n    {\n    return sort { $a->{name} cmp $b->{name} } values %{$self->{groups}}\n      if wantarray;\n\n    return scalar keys %{$self->{groups}};\n    }\n\n  my $are_graph = $self->{graph} ? 0 : 1;\n\n  # get the groups at level 0\n  my $current = 0;\n  my @todo;\n  for my $g (values %{$self->{groups}})\n    {\n    # no group set => belongs to graph, set to ourself => belongs to ourself\n    push @todo, $g if ( ($are_graph && !defined $g->{group}) || $g->{group} == $self);\n    }\n\n  if ($level == 0)\n    {\n    return wantarray ? @todo : scalar @todo;\n    }\n\n  # we need to recursively count groups until the wanted level is reached\n  my @cur = @todo;\n  for my $g (@todo)\n    {\n    # _groups_within() is defined in Graph::Easy::Group\n    $g->_groups_within(1, $level, \\@cur);\n    }\n\n  wantarray ? @cur : scalar @cur;\n  }\n\nsub anon_groups\n  {\n  # return all anon groups as objects\n  my ($self) = @_;\n\n  my $n = $self->{groups};\n\n  if (!wantarray)\n    {\n    my $count = 0;\n    for my $group (values %$n)\n      {\n      $count++ if $group->is_anon();\n      }\n    return $count;\n    }\n\n  my @anon = ();\n  for my $group (values %$n)\n    {\n    push @anon, $group if $group->is_anon();\n    }\n  @anon;\n  }\n\nsub use_class\n  {\n  # use the provided class for generating objects of the type $object\n  my ($self, $object, $class) = @_;\n\n  $self->_croak(\"Expected one of node, edge or group, but got $object\")\n    unless $object =~ /^(node|group|edge)\\z/;\n\n  $self->{use_class}->{$object} = $class;\n\n  $self;  \n  }\n\n#############################################################################\n#############################################################################\n# Support for Graph interface to make Graph::Maker happy:\n\nsub add_vertex\n  {\n  my ($self,$x) = @_;\n  \n  $self->add_node($x);\n  $self;\n  }\n\nsub add_vertices\n  {\n  my ($self) = shift;\n  \n  $self->add_nodes(@_);\n  $self;\n  }\n\nsub add_path\n  {\n  my ($self) = shift;\n\n  my $first = shift;\n\n  while (@_)\n    {\n    my $second = shift;\n    $self->add_edge($first, $second );\n    $first = $second; \n    }\n  $self;\n  }\n\nsub add_cycle\n  {\n  my ($self) = shift;\n\n  my $first = shift; my $a = $first;\n\n  while (@_)\n    {\n    my $second = shift;\n    $self->add_edge($first, $second );\n    $first = $second; \n    }\n  # complete the cycle\n  $self->add_edge($first, $a);\n  $self;\n  }\n\nsub has_edge\n  {\n  # return true if at least one edge between X and Y exists\n  my ($self, $x, $y) = @_;\n\n  # turn plaintext scalars into objects \n  $x = $self->{nodes}->{$x} unless ref $x;\n  $y = $self->{nodes}->{$y} unless ref $y;\n\n  # node does not exist => edge does not exist\n  return 0 unless ref($x) && ref($y);\n\n  scalar $x->edges_to($y) ? 1 : 0;\n  }\n\nsub set_vertex_attribute\n  {\n  my ($self, $node, $name, $value) = @_;\n\n  $node = $self->add_node($node);\n  $node->set_attribute($name,$value);\n\n  $self;\n  }\n\nsub get_vertex_attribute\n  {\n  my ($self, $node, $name) = @_;\n\n  $self->node($node)->get_attribute($name);\n  }\n\n#############################################################################\n#############################################################################\n# Animation support\n\nsub animation_as_graph\n  {\n  my $self = shift;\n\n  my $graph = Graph::Easy->new();\n\n  $graph->add_node('onload');\n\n  # XXX TODO\n\n  $graph;\n  }\n\n1;\n__END__\n\n=pod\n\n=encoding utf-8\n\n=head1 NAME\n\nGraph::Easy - Convert or render graphs (as ASCII, HTML, SVG or via Graphviz)\n\n=head1 SYNOPSIS\n\n\tuse Graph::Easy;\n\t\n\tmy $graph = Graph::Easy->new();\n\n\t# make a fresh copy of the graph\n\tmy $new_graph = $graph->copy();\n\n\t$graph->add_edge ('Bonn', 'Berlin');\n\n\t# will not add it, since it already exists\n\t$graph->add_edge_once ('Bonn', 'Berlin');\n\n\tprint $graph->as_ascii( ); \t\t# prints:\n\n\t# +------+     +--------+\n\t# | Bonn | --> | Berlin |\n\t# +------+     +--------+\n\n\t#####################################################\n\t# alternatively, let Graph::Easy parse some text:\n\n\tmy $graph = Graph::Easy->new( '[Bonn] -> [Berlin]' );\n\n\t#####################################################\n\t# slightly more verbose way:\n\n\tmy $graph = Graph::Easy->new();\n\n\tmy $bonn = $graph->add_node('Bonn');\n\t$bonn->set_attribute('border', 'solid 1px black');\n\n\tmy $berlin = $graph->add_node('Berlin');\n\n\t$graph->add_edge ($bonn, $berlin);\n\n\tprint $graph->as_ascii( );\n\n\t# You can use plain scalars as node names and for the edge label:\n\t$graph->add_edge ('Berlin', 'Frankfurt', 'via train');\n\n\t# adding edges with attributes:\n\n\tmy $edge = Graph::Easy::Edge->new();\n\t$edge->set_attributes( {\n\t\tlabel => 'train',\n\t\tstyle => 'dotted',\n\t\tcolor => 'red',\n\t} );\n\n\t# now with the optional edge object\n\t$graph->add_edge ($bonn, $berlin, $edge);\n\n\t# raw HTML section\n\tprint $graph->as_html( );\n\n\t# complete HTML page (with CSS)\n\tprint $graph->as_html_file( );\n\n\t# Other possibilities:\n\n\t# SVG (possible after you installed Graph::Easy::As_svg):\n\tprint $graph->as_svg( );\n\n\t# Graphviz:\n\tmy $graphviz = $graph->as_graphviz();\n\topen $DOT, '|dot -Tpng -o graph.png' or die (\"Cannot open pipe to dot: $!\");\n\tprint $DOT $graphviz;\n\tclose $DOT;\n\n\t# Please see also the command line utility 'graph-easy'\n\n=head1 DESCRIPTION\n\nC<Graph::Easy> lets you generate graphs consisting of various shaped\nnodes connected by edges (with optional labels).\n\nIt can read and write graphs in a varity of formats, as well as render\nthem via its own grid-based layouter.\n\nSince the layouter works on a grid (manhattan layout), the output is\nmost useful for flow charts, network diagrams, or hierarchy trees.\n\nX<graph>\nX<drawing>\nX<diagram>\nX<flowchart>\nX<layout>\nX<manhattan>\n\n=head2 Input\n\nApart from driving the module with Perl code, you can also use\nC<Graph::Easy::Parser> to parse graph descriptions like:\n\n\t[ Bonn ]      --> [ Berlin ]\n\t[ Frankfurt ] <=> [ Dresden ]\n\t[ Bonn ]      --  [ Frankfurt ]\n\nSee the C<EXAMPLES> section below for how this might be rendered.\n\n=head2 Creating graphs\n\nFirst, create a graph object:\n\n\tmy $graph = Graph::Easy->new();\n\nThen add a node to it:\n\n\tmy $node = $graph->add_node('Koblenz');\n\nDon't worry, adding the node again will do nothing:\n\n\t$node = $graph->add_node('Koblenz');\n\nYou can get back a node by its name with C<node()>:\n\n\t$node = $graph->node('Koblenz');\n\nYou can either add another node:\n\n\tmy $second = $graph->node('Frankfurt');\n\nOr add an edge straight-away:\n\n\tmy ($first,$second,$edge) = $graph->add_edge('Mainz','Ulm');\n\nAdding the edge the second time creates another edge from 'Mainz' to 'Ulm':\n\n\tmy $other_edge;\n\t ($first,$second,$other_edge) = $graph->add_edge('Mainz','Ulm');\n\nThis can be avoided by using C<add_edge_once()>:\n\n\tmy $edge = $graph->add_edge_once('Mainz','Ulm');\n\tif (defined $edge)\n\t  {\n\t  # the first time the edge was added, do something with it\n\t  $edge->set_attribute('color','blue');\n\t  }\n\nYou can set attributes on nodes and edges:\n\n\t$node->attribute('fill', 'yellow');\n\t$edge->attribute('label', 'train');\n\nIt is possible to add an edge with a label:\n\n\t$graph->add_edge('Cottbus', 'Berlin', 'my label');\n\nYou can also add self-loops:\n\n\t$graph->add_edge('Bremen','Bremen');\n\nAdding multiple nodes is easy:\n\n\tmy ($bonn,$rom) = Graph::Easy->add_nodes('Bonn','Rom');\n\nYou can also have subgraphs (these are called groups):\n\n\tmy ($group) = Graph::Easy->add_group('Cities');\n\nOnly nodes can be part of a group, edges are automatically considered\nto be in the group if they lead from one node inside the group to\nanother node in the same group. There are multiple ways to add one or\nmore nodes into a group:\n\n\t$group->add_member($bonn);\n\t$group->add_node($rom);\n\t$group->add_nodes($rom,$bonn);\n\nFor more options please see the online manual: \nL<http://bloodgate.com/perl/graph/manual/> .\n\n=head2 Output\n\nThe output can be done in various styles:\n\n=over 2\n\n=item ASCII ART\n\nUses things like C<+>, C<-> C<< < >> and C<|> to render the boxes.\n\n=item BOXART\n\nUses Unicode box art drawing elements to output the graph.\n\n=item HTML\n\nHTML tables with CSS making everything \"pretty\".\n\n=item SVG\n\nCreates a Scalable Vector Graphics output.\n\n=item Graphviz\n\nCreates graphviz code that can be feed to 'dot', 'neato' or similar programs.\n\n=item GraphML\n\nCreates a textual description of the graph in the GraphML format.\n\n=item GDL/VCG\n\nCreates a textual description of the graph in the VCG or GDL (Graph\nDescription Language) format.\n\n=back\n\nX<ascii>\nX<html>\nX<svg>\nX<boxart>\nX<graphviz>\nX<dot>\nX<neato>\n\n=head1 EXAMPLES\n\nThe following examples are given in the simple text format that is understood\nby L<Graph::Easy::Parser|Graph::Easy::Parser>.\n\nYou can also see many more examples at:\n\nL<http://bloodgate.com/perl/graph/>\n\n=head2 One node\n\nThe most simple graph (apart from the empty one :) is a graph consisting of\nonly one node:\n\n\t[ Dresden ]\n\n=head2 Two nodes\n\nA simple graph consisting of two nodes, linked together by a directed edge:\n\n\t[ Bonn ] -> [ Berlin ]\n\n=head2 Three nodes\n\nA graph consisting of three nodes, and both are linked from the first:\n\n\t[ Bonn ] -> [ Berlin ]\n\t[ Bonn ] -> [ Hamburg ]\n\n=head2 Three nodes in a chain\n\nA graph consisting of three nodes, showing that you can chain connections together:\n\n\t[ Bonn ] -> [ Berlin ] -> [ Hamburg ]\n\n=head2 Two not connected graphs\n\nA graph consisting of two separate parts, both of them not connected\nto each other:\n\n\t[ Bonn ] -> [ Berlin ]\n\t[ Freiburg ] -> [ Hamburg ]\n\n=head2 Three nodes, interlinked\n\nA graph consisting of three nodes, and two of the are connected from\nthe first node:\n\n\t[ Bonn ] -> [ Berlin ]\n\t[ Berlin ] -> [ Hamburg ]\n\t[ Bonn ] -> [ Hamburg ]\n\n=head2 Different edge styles\n\nA graph consisting of a couple of nodes, linked with the\ndifferent possible edge styles.\n\n\t[ Bonn ] <-> [ Berlin ]\t\t# bidirectional\n\t[ Berlin ] ==> [ Rostock ]\t# double\n\t[ Hamburg ] ..> [ Altona ]\t# dotted\n\t[ Dresden ] - > [ Bautzen ]\t# dashed\n\t[ Leipzig ] ~~> [ Kirchhain ]\t# wave\n\t[ Hof ] .-> [ Chemnitz ]\t# dot-dash\n\t[ Magdeburg ] <=> [ Ulm ]\t# bidrectional, double etc\n\t[ Magdeburg ] -- [ Ulm ]\t# arrow-less edge\n\nMore examples at: L<http://bloodgate.com/perl/graph/>\n\n=head1 ANIMATION SUPPORT\n\nB<Note: Animations are not yet implemented!>\n\nIt is possible to add animations to a graph. This is done by\nadding I<steps> via the pseudo-class C<step>:\n\n\tstep.0 {\n\t  target: Bonn;\t\t# find object with id=Bonn, or\n\t\t\t\t# if this fails, the node named\n\t\t\t\t# \"Bonn\".\n\t  animate: fill:\t# animate this attribute\n\t  from: yellow;\t\t# start value (0% of duration)\n\t  via: red;\t\t# at 50% of the duration\n\t  to: yellow;\t\t# and 100% of duration\n\t  wait: 0;\t\t# after triggering, wait so many seconds\n\t  duration: 5;\t\t# entire time to go from \"from\" to \"to\"\n\t  trigger: onload;\t# when to trigger this animation\n\t  repeat: 2;\t\t# how often to repeat (\"2\" means two times)\n\t\t\t\t# also \"infinite\", then \"next\" will be ignored\n\t  next: 1;\t\t# which step to take after repeat is up\n\t}\n\tstep.1 {\n\t  from: white;\t\t# set to white\n\t  to: white;\n\t  duration: 0.1;\t# 100ms\n\t  next: 0;\t\t# go back to step.0\n\t}\n\nHere two steps are created, I<0> and I<1> and the animation will\nbe going like this:\n\n                               0.1s\n\t                     +-------------------------------+\n\t                     v                               |\n\t+--------+  0s   +--------+  5s   +--------+  5s   +--------+\n\t| onload | ----> | step.0 | ----> | step.0 | ----> | step.1 |\n\t+--------+       +--------+       +--------+       +--------+\n\nYou can generate a a graph with the animation flow via\nC<animation_as_graph()>.\n\n=head2 Output\n\nCurrently no output formats supports animations yet.\n\n=head1 METHODS\n\nC<Graph::Easy> supports the following methods:\n\n=head2 new()\n\n        use Graph::Easy;\n\n        my $graph = Graph::Easy->new( );\n        \nCreates a new, empty C<Graph::Easy> object.\n\nTakes optinal a hash reference with a list of options. The following are\nvalid options:\n\n\tdebug\t\t\tif true, enables debug output\n\ttimeout\t\t\ttimeout (in seconds) for the layouter\n\tfatal_errors\t\twrong attributes are fatal errors, default: true\n\tstrict\t\t\ttest attribute names for being valid, default: true\n\tundirected\t\tcreate an undirected graph, default: false\n\n=head2 copy()\n\n    my $copy = $graph->copy( );\n\nCreate a copy of this graph and return it as a new Graph::Easy object.\n\n=head2 error()\n\n\tmy $error = $graph->error();\n\nReturns the last error or '' for none.\nOptionally, takes an error message to be set.\n\n\t$graph->error( 'Expected Foo, but found Bar.' );\n\nSee L<warn()> on how to catch error messages. See also L<non_fatal_errors()>\non how to turn errors into warnings.\n\n=head2 warn()\n\n\tmy $warning = $graph->warn();\n\nReturns the last warning or '' for none.\nOptionally, takes a warning message to be output to STDERR:\n\n\t$graph->warn( 'Expected Foo, but found Bar.' );\n\nIf you want to catch warnings from the layouter, enable catching\nof warnings or errors:\n\n\t$graph->catch_messages(1);\n\n\t# Or individually:\n\t# $graph->catch_warnings(1);\n\t# $graph->catch_errors(1);\n\n\t# something which warns or throws an error:\n\t...\n\n\tif ($graph->error())\n\t  {\n\t  my @errors = $graph->errors();\n\t  }\n\tif ($graph->warning())\n\t  {\n\t  my @warnings = $graph->warnings();\n\t  }\n\nSee L<Graph::Easy::Base> for more details on error/warning message capture.\n\n=head2 add_edge()\n\n\tmy ($first, $second, $edge) = $graph->add_edge( 'node 1', 'node 2');\n\n=head2 add_edge()\n\n\tmy ($first, $second, $edge) = $graph->add_edge( 'node 1', 'node 2');\n\tmy $edge = $graph->add_edge( $x, $y, $edge);\n\t$graph->add_edge( $x, $y);\n\nAdd an edge between nodes X and Y. The optional edge object defines\nthe style of the edge, if not present, a default object will be used.\n\nWhen called in scalar context, will return C<$edge>. In array/list context\nit will return the two nodes and the edge object.\n\nC<$x> and C<$y> should be either plain scalars with the names of\nthe nodes, or objects of L<Graph::Easy::Node|Graph::Easy::Node>,\nwhile the optional C<$edge> should be L<Graph::Easy::Edge|Graph::Easy::Edge>.\n\nNote: C<Graph::Easy> graphs are multi-edged, and adding the same edge\ntwice will result in two edges going from C<$x> to C<$y>! See\nC<add_edge_once()> on how to avoid that.\n\nYou can also use C<edge()> to check whether an edge from X to Y already exists\nin the graph.\n \n=head2 add_edge_once()\n\n\tmy ($first, $second, $edge) = $graph->add_edge_once( 'node 1', 'node 2');\n\tmy $edge = $graph->add_edge_once( $x, $y, $edge);\n\t$graph->add_edge_once( $x, $y);\n\n\tif (defined $edge)\n\t  {\n\t  # got added once, so do something with it\n\t  $edge->set_attribute('label','unique');\n\t  }\n\nAdds an edge between nodes X and Y, unless there exists already\nan edge between these two nodes. See C<add_edge()>.\n\nReturns undef when an edge between X and Y already exists.\n\nWhen called in scalar context, will return C<$edge>. In array/list context\nit will return the two nodes and the edge object.\n\n=head2 flip_edges()\n\n\tmy $graph = Graph::Easy->new();\n\t$graph->add_edge('Bonn','Berlin');\n\t$graph->add_edge('Berlin','Bonn');\n\n\tprint $graph->as_ascii();\n\n\t#   +--------------+\n\t#   v              |\n\t# +--------+     +------+\n\t# | Berlin | --> | Bonn |\n\t# +--------+     +------+\n\n\t$graph->flip_edges('Bonn', 'Berlin');\n\n\tprint $graph->as_ascii();\n\n\t#   +--------------+\n\t#   |              v\n\t# +--------+     +------+\n\t# | Berlin | --> | Bonn |\n\t# +--------+     +------+\n\nTurn around (transpose) all edges that are going from the first node to the\nsecond node.\n\nX<transpose>\n\n=head2 add_node()\n\n\tmy $node = $graph->add_node( 'Node 1' );\n\t# or if you already have a Graph::Easy::Node object:\n\t$graph->add_node( $x );\n\nAdd a single node X to the graph. C<$x> should be either a\nC<Graph::Easy::Node> object, or a unique name for the node. Will do\nnothing if the node already exists in the graph.\n\nIt returns an L<Graph::Easy::Node> object.\n\n=head2 add_anon_node()\n\n\tmy $anon_node = $graph->add_anon_node( );\n\nCreates a single, anonymous node and adds it to the graph, returning the\nC<Graph::Easy::Node::Anon> object.\n\nThe created node is equal to one created via C< [ ] > in the Graph::Easy\ntext description.\n\n=head2 add_nodes()\n\n\tmy @nodes = $graph->add_nodes( 'Node 1', 'Node 2' );\n\nAdd all the given nodes to the graph. The arguments should be either a\nC<Graph::Easy::Node> object, or a unique name for the node. Will do\nnothing if the node already exists in the graph.\n\nIt returns a list of L<Graph::Easy::Node> objects.\n\n=head2 rename_node()\n\n\t$node = $graph->rename_node($node, $new_name);\n\nChanges the name of a node. If the passed node is not part of\nthis graph or just a string, it will be added with the new\nname to this graph.\n\nIf the node was part of another graph, it will be deleted there and added\nto this graph with the new name, effectively moving the node from the old\nto the new graph and renaming it at the same time.\n\n=head2 del_node()\n\n\t$graph->del_node('Node name');\n\t$graph->del_node($node);\n\nDelete the node with the given name from the graph.\n\n=head2 del_edge()\n\n\t$graph->del_edge($edge);\n\nDelete the given edge object from the graph. You can use C<edge()> to find\nan edge from Node A to B:\n\n\t$graph->del_edge( $graph->edge('A','B') );\n\n=head2 merge_nodes()\n\n\t$graph->merge_nodes( $first_node, $second_node );\n\t$graph->merge_nodes( $first_node, $second_node, $joiner );\n\nMerge two nodes. Will delete all connections between the two nodes, then\nmove over any connection to/from the second node to the first, then delete\nthe second node from the graph.\n\nAny attributes on the second node will be lost.\n\nIf present, the optional C<< $joiner >> argument will be used to join\nthe label of the second node to the label of the first node. If not\npresent, the label of the second node will be dropped along with all\nthe other attributes:\n\n\tmy $graph = Graph::Easy->new('[A]->[B]->[C]->[D]');\n\n\t# this produces \"[A]->[C]->[D]\"\n\t$graph->merge_nodes( 'A', 'B' );\n\n\t# this produces \"[A C]->[D]\"\n\t$graph->merge_nodes( 'A', 'C', ' ' );\n\n\t# this produces \"[A C \\n D]\", note single quotes on the third argument!\n\t$graph->merge_nodes( 'A', 'C', ' \\n ' );\n\n=head2 get_attribute()\n\n\tmy $value = $graph->get_attribute( $class, $name );\n\nReturn the value of attribute C<$name> from class C<$class>.\n\nExample:\n\n\tmy $color = $graph->attribute( 'node', 'color' );\n\nYou can also call all the various attribute related methods on members of the\ngraph directly, for instance:\n\n\t$node->get_attribute('label');\n\t$edge->get_attribute('color');\n\t$group->get_attribute('fill');\n\n=head2 attribute()\n\n\tmy $value = $graph->attribute( $class, $name );\n\nIs an alias for L<get_attribute>.\n\n=head2 color_attribute()\n\n\t# returns f.i. #ff0000\n\tmy $color = $graph->get_color_attribute( 'node', 'color' );\n\nJust like L<get_attribute()>, but only for colors, and returns them as hex,\nusing the current colorscheme.\n\n=head2 get_color_attribute()\n\nIs an alias for L<color_attribute()>.\n\n=head2 get_attributes()\n\n\tmy $att = $object->get_attributes();\n\nReturn all effective attributes on this object (graph/node/group/edge) as\nan anonymous hash ref. This respects inheritance and default values.\n\nNote that this does not include custom attributes.\n\nSee also L<get_custom_attributes> and L<raw_attributes()>.\n\n=head2 get_custom_attributes()\n\n\tmy $att = $object->get_custom_attributes();\n\nReturn all the custom attributes on this object (graph/node/group/edge) as\nan anonymous hash ref.\n\n=head2 custom_attributes()\n\n\tmy $att = $object->custom_attributes();\n\nC<< custom_attributes() >> is an alias for L<< get_custom_attributes >>.\n\n=head2 raw_attributes()\n\n\tmy $att = $object->raw_attributes();\n\nReturn all set attributes on this object (graph, node, group or edge) as\nan anonymous hash ref. Thus you get all the locally active attributes\nfor this object.\n\nInheritance is respected, e.g. attributes that have the value \"inherit\"\nand are inheritable, will be inherited from the base class.\n\nBut default values for unset attributes are skipped. Here is an example:\n\n\tnode { color: red; }\n\n\t[ A ] { class: foo; color: inherit; }\n\nThis will return:\n\n\t{ class => foo, color => red }\n\nAs you can see, attributes like C<background> etc. are not included, while\nthe color value was inherited properly.\n\nSee also L<get_attributes()>.\n\n=head2 default_attribute()\n\n\tmy $def = $graph->default_attribute($class, 'fill');\n\nReturns the default value for the given attribute B<in the class>\nof the object.\n\nThe default attribute is the value that will be used if\nthe attribute on the object itself, as well as the attribute\non the class is unset.\n\nTo find out what attribute is on the class, use the three-arg form\nof L<attribute> on the graph:\n\n\tmy $g = Graph::Easy->new();\n\tmy $node = $g->add_node('Berlin');\n\n\tprint $node->attribute('fill'), \"\\n\";\t\t# print \"white\"\n\tprint $node->default_attribute('fill'), \"\\n\";\t# print \"white\"\n\tprint $g->attribute('node','fill'), \"\\n\";\t# print \"white\"\n\n\t$g->set_attribute('node','fill','red');\t\t# class is \"red\"\n\t$node->set_attribute('fill','green');\t\t# this object is \"green\"\n\n\tprint $node->attribute('fill'), \"\\n\";\t\t# print \"green\"\n\tprint $node->default_attribute('fill'), \"\\n\";\t# print \"white\"\n\tprint $g->attribute('node','fill'), \"\\n\";\t# print \"red\"\n\nSee also L<raw_attribute()>.\n\n=head2 raw_attribute()\n\n\tmy $value = $object->raw_attribute( $name );\n\nReturn the value of attribute C<$name> from the object it this\nmethod is called on (graph, node, edge, group etc.). If the\nattribute is not set on the object itself, returns undef.\n\nThis method respects inheritance, so an attribute value of 'inherit'\non an object will make the method return the inherited value:\n\n\tmy $g = Graph::Easy->new();\n\tmy $n = $g->add_node('A');\n\n\t$g->set_attribute('color','red');\n\n\tprint $n->raw_attribute('color');\t\t# undef\n\t$n->set_attribute('color','inherit');\n\tprint $n->raw_attribute('color');\t\t# 'red'\n\nSee also L<attribute()>.\n\n=head2 raw_color_attribute()\n\n\t# returns f.i. #ff0000\n\tmy $color = $graph->raw_color_attribute('color' );\n\nJust like L<raw_attribute()>, but only for colors, and returns them as hex,\nusing the current colorscheme.\n\nIf the attribute is not set on the object, returns C<undef>.\n\n=head2 raw_attributes()\n\n\tmy $att = $object->raw_attributes();\n\nReturns a hash with all the raw attributes of that object.\nAttributes that are no set on the object itself, but on\nthe class this object belongs to are B<not> included.\n\nThis method respects inheritance, so an attribute value of 'inherit'\non an object will make the method return the inherited value.\n\n=head2 set_attribute()\n\n\t# Set the attribute on the given class.\n\t$graph->set_attribute( $class, $name, $val );\n\n\t# Set the attribute on the graph itself. This is synonymous\n\t# to using 'graph' as class in the form above.\n\t$graph->set_attribute( $name, $val );\n\nSets a given attribute named C<$name> to the new value C<$val> in the class\nspecified in C<$class>.\n\nExample:\n\n\t$graph->set_attribute( 'graph', 'gid', '123' );\n\nThe class can be one of C<graph>, C<edge>, C<node> or C<group>. The last\nthree can also have subclasses like in C<node.subclassname>.\n\nYou can also call the various attribute related methods on members of the\ngraph directly, for instance:\n\n\t$node->set_attribute('label', 'my node');\n\t$edge->set_attribute('color', 'red');\n\t$group->set_attribute('fill', 'green');\n\n=head2 set_attributes()\n\n\t$graph->set_attributes( $class, $att );\n\nGiven a class name in C<$class> and a hash of mappings between attribute names\nand values in C<$att>, will set all these attributes.\n\nThe class can be one of C<graph>, C<edge>, C<node> or C<group>. The last\nthree can also have subclasses like in C<node.subclassname>.\n\nExample:\n\n\t$graph->set_attributes( 'node', { color => 'red', background => 'none' } );\n\n=head2 del_attribute()\n\n\t$graph->del_attribute('border');\n\nDelete the attribute with the given name from the object.\n\nYou can also call the various attribute related methods on members of the\ngraph directly, for instance:\n\n\t$node->del_attribute('label');\n\t$edge->del_attribute('color');\n\t$group->del_attribute('fill');\n\n=head2 unquote_attribute()\n\n\t# returns '\"Hello World!\"'\n\tmy $value = $self->unquote_attribute('node','label','\"Hello World!\"');\n\t# returns 'red'\n\tmy $color = $self->unquote_attribute('node','color','\"red\"');\n\nReturn the attribute unquoted except for labels and titles, that is it removes\ndouble quotes at the start and the end of the string, unless these are\nescaped with a backslash.\n\n=head2 border_attribute()\n\n  \tmy $border = $graph->border_attribute();\n\nReturn the combined border attribute like \"1px solid red\" from the\nborder(style|color|width) attributes.\n\n=head2 split_border_attributes()\n\n  \tmy ($style,$width,$color) = $graph->split_border_attribute($border);\n\nSplit the border attribute (like \"1px solid red\") into the three different parts.\n\n=head2 quoted_comment()\n\n\tmy $cmt = $node->comment();\n\nComment of this object, quoted suitable as to be embedded into HTML/SVG.\nReturns the empty string if this object doesn't have a comment set.\n\n=head2 flow()\n\n\tmy $flow = $graph->flow();\n\nReturns the flow of the graph, as absolute number in degress.\n\n=head2 source_nodes()\n\n\tmy @roots = $graph->source_nodes();\n\nReturns all nodes that have only outgoing edges, e.g. are the root of a tree,\nin no particular order.\n\nIsolated nodes (no edges at all) will B<not> be included, see\nL<predecessorless_nodes()> to get these, too.\n\nIn scalar context, returns the number of source nodes.\n\n=head2 predecessorless_nodes()\n\n\tmy @roots = $graph->predecessorless_nodes();\n\nReturns all nodes that have no incoming edges, regardless of whether\nthey have outgoing edges or not, in no particular order.\n\nIsolated nodes (no edges at all) B<will> be included in the list.\n\nSee also L<source_nodes()>.\n\nIn scalar context, returns the number of predecessorless nodes.\n\n=head2 root_node()\n\n\tmy $root = $graph->root_node();\n\nReturn the root node as L<Graph::Easy::Node> object, if it was\nset with the 'root' attribute.\n\n=head2 timeout()\n\n\tprint $graph->timeout(), \" seconds timeout for layouts.\\n\";\n\t$graph->timeout(12);\n\nGet/set the timeout for layouts in seconds. If the layout process did not\nfinish after that time, it will be stopped and a warning will be printed.\n\nThe default timeout is 5 seconds.\n\n=head2 strict()\n\n\tprint \"Graph has strict checking\\n\" if $graph->strict();\n\t$graph->strict(undef);\t\t# disable strict attribute checks\n\nGet/set the strict option. When set to a true value, all attribute names and\nvalues will be strictly checked and unknown/invalid one will be rejected.\n\nThis option is on by default.\n\n=head2 type()\n\n\tprint \"Graph is \" . $graph->type() . \"\\n\";\n\nReturns the type of the graph as string, either \"directed\" or \"undirected\".\n\n=head2 layout()\n\n\t$graph->layout();\n\t$graph->layout( type => 'force', timeout => 60 );\n\nCreates the internal structures to layout the graph. \n\nThis method will be called automatically when you call any of the\nC<as_FOO> methods or C<output()> as described below.\n\nThe options are:\n\n\ttype\t\tthe type of the layout, possible values:\n\t\t\t'force'\t\t- force based layouter\n\t\t\t'adhoc'\t\t- the default layouter\n\ttimeout\t\ttimeout in seconds\n\nSee also: L<timeout()>.\n\n=head2 output_format()\n\n\t$graph->output_format('html');\n\nSet the outputformat. One of 'html', 'ascii', 'graphviz', 'svg' or 'txt'.\nSee also L<output()>.\n\n=head2 output()\n\n\tmy $out = $graph->output();\n\nOutput the graph in the format set by C<output_format()>.\n\n=head2 as_ascii()\n\n\tprint $graph->as_ascii();\n\nReturn the graph layout in ASCII art, in utf-8.\n\n=head2 as_ascii_file()\n\n\tprint $graph->as_ascii_file();\n\nIs an alias for L<as_ascii>.\n\n=head2 as_ascii_html()\n\n\tprint $graph->as_ascii_html();\n\nReturn the graph layout in ASCII art, suitable to be embedded into an HTML\npage. Basically it wraps the output from L<as_ascii()> into\nC<< <pre> </pre> >> and inserts real HTML links. The returned\nstring is in utf-8.\n\n=head2 as_boxart()\n\n\tprint $graph->as_box();\n\nReturn the graph layout as box drawing using Unicode characters (in utf-8,\nas always).\n\n=head2 as_boxart_file()\n\n\tprint $graph->as_boxart_file();\n\nIs an alias for C<as_box>.\n\n=head2 as_boxart_html()\n\n\tprint $graph->as_boxart_html();\n\nReturn the graph layout as box drawing using Unicode characters,\nas chunk that can be embedded into an HTML page.\n\nBasically it wraps the output from L<as_boxart()> into\nC<< <pre> </pre> >> and inserts real HTML links. The returned\nstring is in utf-8.\n\n=head2 as_boxart_html_file()\n\n\tprint $graph->as_boxart_html_file();\n\nReturn the graph layout as box drawing using Unicode characters,\nas a full HTML page complete with header and footer.\n\n=head2 as_html()\n\n\tprint $graph->as_html();\n\nReturn the graph layout as HTML section. See L<css()> to get the\nCSS section to go with that HTML code. If you want a complete HTML page\nthen use L<as_html_file()>.\n\n=head2 as_html_page()\n\n\tprint $graph->as_html_page();\n\nIs an alias for C<as_html_file>.\n\n=head2 as_html_file()\n\n\tprint $graph->as_html_file();\n\nReturn the graph layout as HTML complete with headers, CSS section and\nfooter. Can be viewed in the browser of your choice.\n\n=head2 add_group()\n\n\tmy $group = $graph->add_group('Group name');\n\nAdd a group to the graph and return it as L<Graph::Easy::Group> object.\n\n=head2 group()\n\n\tmy $group = $graph->group('Name');\n\nReturns the group with the name C<Name> as L<Graph::Easy::Group> object.\n\n=head2 rename_group()\n\n\t$group = $graph->rename_group($group, $new_name);\n\nChanges the name of the given group. If the passed group is not part of\nthis graph or just a string, it will be added with the new\nname to this graph.\n\nIf the group was part of another graph, it will be deleted there and added\nto this graph with the new name, effectively moving the group from the old\nto the new graph and renaming it at the same time.\n\n=head2 groups()\n\n\tmy @groups = $graph->groups();\n\nReturns the groups of the graph as L<Graph::Easy::Group> objects,\nin arbitrary order.\n  \n=head2 groups_within()\n\n\t# equivalent to $graph->groups():\n\tmy @groups = $graph->groups_within();\t\t# all\n\tmy @toplevel_groups = $graph->groups_within(0);\t# level 0 only\n\nReturn the groups that are inside this graph, up to the specified level,\nin arbitrary order.\n\nThe default level is -1, indicating no bounds and thus all contained\ngroups are returned.\n\nA level of 0 means only the direct children, and hence only the toplevel\ngroups will be returned. A level 1 means the toplevel groups and their\ntoplevel children, and so on.\n\n=head2 anon_groups()\n\n\tmy $anon_groups = $graph->anon_groups();\n\nIn scalar context, returns the number of anon groups (aka\nL<Graph::Easy::Group::Anon>) the graph has.\n\nIn list context, returns all anon groups as objects, in arbitrary order.\n\n=head2 del_group()\n\n\t$graph->del_group($name);\n\nDelete the group with the given name.\n\n=head2 edges(), edges_within()\n\n\tmy @edges = $graph->edges();\n\nReturns the edges of the graph as L<Graph::Easy::Edge> objects,\nin arbitrary order.\n\nL<edges_within()> is an alias for C<edges()>.\n\n=head2 is_simple_graph(), is_simple()\n\n\tif ($graph->is_simple())\n\t  {\n\t  }\n\nReturns true if the graph does not have multiedges, e.g. if it\ndoes not have more than one edge going from any node to any other\nnode or group.\n\nSince this method has to look at all edges, it is costly in terms of\nboth CPU and memory.\n\n=head2 is_directed()\n\n\tif ($graph->is_directed())\n\t  {\n\t  }\n\nReturns true if the graph is directed.\n\n=head2 is_undirected()\n\n\tif ($graph->is_undirected())\n\t  {\n\t  }\n\nReturns true if the graph is undirected.\n\n=head2 parent()\n\n\tmy $parent = $graph->parent();\n\nReturns the parent graph, for graphs this is undef.\n\n=head2 label()\n\n\tmy $label = $graph->label();\n\nReturns the label of the graph.\n\n=head2 title()\n\n\tmy $title = $graph->title();\n\nReturns the (mouseover) title of the graph.\n\n=head2 link()\n\n\tmy $link = $graph->link();\n\nReturn a potential link (for the graphs label), build from the attributes C<linkbase>\nand C<link> (or autolink). Returns '' if there is no link.\n\n=head2 as_graphviz()\n\n\tprint $graph->as_graphviz();\n\nReturn the graph as graphviz code, suitable to be feed to a program like\nC<dot> etc.\n\n=head2 as_graphviz_file()\n\n\tprint $graph->as_graphviz_file();\n\nIs an alias for L<as_graphviz()>.\n\n=head2 angle()\n\n        my $degrees = Graph::Easy->angle( 'south' );\n        my $degrees = Graph::Easy->angle( 120 );\n\nCheck an angle for being valid and return a value between -359 and 359\ndegrees. The special values C<south>, C<north>, C<west>, C<east>, C<up>\nand C<down> are also valid and converted to degrees.\n\n=head2 nodes()\n\n\tmy $nodes = $graph->nodes();\n\nIn scalar context, returns the number of nodes/vertices the graph has.\n\nIn list context, returns all nodes as objects, in arbitrary order.\n\n=head2 anon_nodes()\n\n\tmy $anon_nodes = $graph->anon_nodes();\n\nIn scalar context, returns the number of anon nodes (aka\nL<Graph::Easy::Node::Anon>) the graph has.\n\nIn list context, returns all anon nodes as objects, in arbitrary order.\n\n=head2 html_page_header()\n\n\tmy $header = $graph->html_page_header();\n\tmy $header = $graph->html_page_header($css);\n\nReturn the header of an HTML page. Used together with L<html_page_footer>\nby L<as_html_page> to construct a complete HTML page.\n\nTakes an optional parameter with the CSS styles to be inserted into the\nheader. If C<$css> is not defined, embedds the result of C<< $self->css() >>.\n\n=head2 html_page_footer()\n\n\tmy $footer = $graph->html_page_footer();\n\nReturn the footer of an HTML page. Used together with L<html_page_header>\nby L<as_html_page> to construct a complete HTML page.\n\n=head2 css()\n\n\tmy $css = $graph->css();\n\nReturn CSS code for that graph. See L<as_html()>.\n\n=head2 as_txt()\n\n\tprint $graph->as_txt();\n\nReturn the graph as a normalized textual representation, that can be\nparsed with L<Graph::Easy::Parser> back to the same graph.\n\nThis does not call L<layout()> since the actual text representation\nis just a dump of the graph.\n\n=head2 as_txt_file()\n\n\tprint $graph->as_txt_file();\n\nIs an alias for L<as_txt()>.\n\n=head2 as_svg()\n\n\tprint $graph->as_svg();\n\nReturn the graph as SVG (Scalable Vector Graphics), which can be\nembedded into HTML pages. You need to install\nL<Graph::Easy::As_svg> first to make this work.\n\nSee also L<as_svg_file()>.\n\nB<Note:> You need L<Graph::Easy::As_svg> installed for this to work!\n\n=head2 as_svg_file()\n\n\tprint $graph->as_svg_file();\n\nReturns SVG just like C<as_svg()>, but this time as standalone SVG,\nsuitable for storing it in a file and referencing it externally.\n\nAfter calling C<as_svg_file()> or C<as_svg()>, you can retrieve\nsome SVG information, notable C<width> and C<height> via\nC<svg_information>.\n\nB<Note:> You need L<Graph::Easy::As_svg> installed for this to work!\n\n=head2 svg_information()\n\n\tmy $info = $graph->svg_information();\n\n\tprint \"Size: $info->{width}, $info->{height}\\n\";\n\nReturn information about the graph created by the last\nC<as_svg()> or C<as_svg_file()> call.\n\nThe following fields are set:\n\n\twidth\t\twidth of the SVG in pixels\n\theight\t\theight of the SVG in pixels\n\nB<Note:> You need L<Graph::Easy::As_svg> installed for this to work!\n\n=head2 as_vcg()\n\n\tprint $graph->as_vcg();\n\nReturn the graph as VCG text. VCG is a subset of GDL (Graph Description\nLanguage).\n\nThis does not call L<layout()> since the actual text representation\nis just a dump of the graph.\n\n=head2 as_vcg_file()\n\n\tprint $graph->as_vcg_file();\n\nIs an alias for L<as_vcg()>.\n\n=head2 as_gdl()\n\n\tprint $graph->as_gdl();\n\nReturn the graph as GDL (Graph Description Language) text. GDL is a superset\nof VCG.\n\nThis does not call L<layout()> since the actual text representation\nis just a dump of the graph.\n\n=head2 as_gdl_file()\n\n\tprint $graph->as_gdl_file();\n\nIs an alias for L<as_gdl()>.\n\n=head2 as_graphml()\n\n\tprint $graph->as_graphml();\n\nReturn the graph as a GraphML representation.\n\nThis does not call L<layout()> since the actual text representation\nis just a dump of the graph.\n\nThe output contains only the set attributes, e.g. default attribute values\nare not specifically mentioned. The attribute names and values are the\nin the format that C<Graph::Easy> defines.\n\n=head2 as_graphml_file()\n\n\tprint $graph->as_graphml_file();\n\nIs an alias for L<as_graphml()>.\n\n=head2 sorted_nodes()\n\n\tmy $nodes =\n\t $graph->sorted_nodes( );\t\t# default sort on 'id'\n\tmy $nodes = \n\t $graph->sorted_nodes( 'name' );\t# sort on 'name'\n\tmy $nodes = \n\t $graph->sorted_nodes( 'layer', 'id' );\t# sort on 'layer', then on 'id'\n\nIn scalar context, returns the number of nodes/vertices the graph has.\nIn list context returns a list of all the node objects (as reference),\nsorted by their attribute(s) given as arguments. The default is 'id',\ne.g. their internal ID number, which amounts more or less to the order\nthey have been inserted.\n\nThis routine will sort the nodes by their group first, so the requested\nsort order will be only valid if there are no groups or inside each\ngroup.\n\n=head2 as_debug()\n\n\tprint $graph->as_debug();\n\nReturn debugging information like version numbers of used modules,\nand a textual representation of the graph.\n\nThis does not call L<layout()> since the actual text representation\nis more a dump of the graph, than a certain layout.\n\n=head2 node()\n\n\tmy $node = $graph->node('node name');\n\nReturn node by unique name (case sensitive). Returns undef if the node\ndoes not exist in the graph.\n\n=head2 edge()\n\n\tmy $edge = $graph->edge( $x, $y );\n\nReturns the edge objects between nodes C<$x> and C<$y>. Both C<$x> and C<$y>\ncan be either scalars with names or C<Graph::Easy::Node> objects.\n\nReturns undef if the edge does not yet exist.\n\nIn list context it will return all edges from C<$x> to C<$y>, in\nscalar context it will return only one (arbitrary) edge.\n\n=head2 id()\n\n\tmy $graph_id = $graph->id();\n\t$graph->id('123');\n\nReturns the id of the graph. You can also set a new ID with this routine. The\ndefault is ''.\n\nThe graph's ID is used to generate unique CSS classes for each graph, in the\ncase you want to have more than one graph in an HTML page.\n\n=head2 seed()\n\n\tmy $seed = $graph->seed();\n\t$graph->seed(2);\n\nGet/set the random seed for the graph object. See L<randomize()>\nfor a method to set a random seed.\n\nThe seed is used to create random numbers for the layouter. For\nthe same graph, the same seed will always lead to the same layout.\n\n=head2 randomize()\n\n\t$graph->randomize();\n\nSet a random seed for the graph object. See L<seed()>.\n\n=head2 debug()\n\n\tmy $debug = $graph->debug();\t# get\n\t$graph->debug(1);\t\t# enable\n\t$graph->debug(0);\t\t# disable\n\nEnable, disable or read out the debug status. When the debug status is true,\nadditional debug messages will be printed on STDERR.\n\n=head2 score()\n\n\tmy $score = $graph->score();\n\nReturns the score of the graph, or undef if L<layout()> has not yet been called.\n\nHigher scores are better, although you cannot compare scores for different\ngraphs. The score should only be used to compare different layouts of the same\ngraph against each other:\n\n\tmy $max = undef;\n\n\t$graph->randomize();\n\tmy $seed = $graph->seed(); \n\n\t$graph->layout();\n\t$max = $graph->score(); \n\n\tfor (1..10)\n\t  {\n\t  $graph->randomize();\t\t\t# select random seed\n\t  $graph->layout();\t\t\t# layout with that seed\n\t  if ($graph->score() > $max)\n\t    {\n\t    $max = $graph->score();\t\t# store the new max store\n\t    $seed = $graph->seed();\t\t# and it's seed\n\t    }\n\t  }\n\n\t# redo the best layout\n\tif ($seed ne $graph->seed())\n\t  {\n\t  $graph->seed($seed);\n\t  $graph->layout();\n\t  }\n\t# output graph:\n\tprint $graph->as_ascii();\t\t# or as_html() etc\n\n=head2 valid_attribute()\n\n\tmy $graph = Graph::Easy->new();\n\tmy $new_value =\n\t  $graph->valid_attribute( $name, $value, $class );\n\n\tif (ref($new_value) eq 'ARRAY' && @$new_value == 0)\n\t  {\n\t  # throw error\n          die (\"'$name' is not a valid attribute name for '$class'\")\n\t\tif $self->{_warn_on_unused_attributes};\n\t  }\n\telsif (!defined $new_value)\n\t  {\n\t  # throw error\n          die (\"'$value' is no valid '$name' for '$class'\");\n\t  }\n\nDeprecated, please use L<validate_attribute()>.\n\nCheck that a C<$name,$value> pair is a valid attribute in class C<$class>,\nand returns a new value.\n\nIt returns an array ref if the attribute name is invalid, and undef if the\nvalue is invalid.\n\nThe return value can differ from the passed in value, f.i.:\n\n\tprint $graph->valid_attribute( 'color', 'red' );\n\nThis would print '#ff0000';\n\n=head2 validate_attribute()\n\n\tmy $graph = Graph::Easy->new();\n\tmy ($rc,$new_name, $new_value) =\n\t  $graph->validate_attribute( $name, $value, $class );\n\nChecks a given attribute name and value (or values, in case of a\nvalue like \"red|green\") for being valid. It returns a new\nattribute name (in case of \"font-color\" => \"fontcolor\") and\neither a single new attribute, or a list of attribute values\nas array ref.\n\nIf C<$rc> is defined, it is the error number:\n\n\t1\t\t\tunknown attribute name\n\t2\t\t\tinvalid attribute value\n\t4\t\t\tfound multiple attributes, but these arent\n\t\t\t\tallowed at this place\n\n=head2 color_as_hex()\n\n\tmy $hexred   = Graph::Easy->color_as_hex( 'red' );\n\tmy $hexblue  = Graph::Easy->color_as_hex( '#0000ff' );\n\tmy $hexcyan  = Graph::Easy->color_as_hex( '#f0f' );\n\tmy $hexgreen = Graph::Easy->color_as_hex( 'rgb(0,255,0)' );\n\nTakes a valid color name or definition (hex, short hex, or RGB) and returns the\ncolor in hex like C<#ff00ff>.\n\n=head2 color_value($color_name, $color_scheme)\n\n\tmy $color = Graph::Easy->color_name( 'red' );\t# #ff0000\n\tprint Graph::Easy->color_name( '#ff0000' );\t# #ff0000\n\n\tprint Graph::Easy->color_name( 'snow', 'x11' );\n\nGiven a color name, returns the color in hex. See L<color_name>\nfor a list of possible values for the optional C<$color_scheme>\nparameter.\n\n=head2 color_name($color_value, $color_scheme)\n\n\tmy $color = Graph::Easy->color_name( 'red' );\t# red\n\tprint Graph::Easy->color_name( '#ff0000' );\t# red\n\n\tprint Graph::Easy->color_name( 'snow', 'x11' );\n\nTakes a hex color value and returns the name of the color.\n\nThe optional parameter is the color scheme, where the following\nvalues are possible:\n\n w3c\t\t\t(the default)\n x11\t\t\t(what graphviz uses as default)\n\nPlus the following ColorBrewer schemes are supported, see the\nonline manual for examples and their usage:\n\n accent3 accent4 accent5 accent6 accent7 accent8\n\n blues3 blues4 blues5 blues6 blues7 blues8 blues9\n\n brbg3 brbg4 brbg5 brbg6 brbg7 brbg8 brbg9 brbg10 brbg11\n\n bugn3 bugn4 bugn5 bugn6 bugn7 bugn8 bugn9 bupu3 bupu4 bupu5 bupu6 bupu7\n bupu8 bupu9\n\n dark23 dark24 dark25 dark26 dark27 dark28\n\n gnbu3 gnbu4 gnbu5 gnbu6 gnbu7 gnbu8 gnbu9\n\n greens3 greens4 greens5 greens6 greens7 greens8 greens9\n\n greys3 greys4 greys5 greys6 greys7 greys8 greys9\n\n oranges3 oranges4 oranges5 oranges6 oranges7 oranges8 oranges9\n\n orrd3 orrd4 orrd5 orrd6 orrd7 orrd8 orrd9\n\n paired3 paired4 paired5 paired6 paired7 paired8 paired9 paired10 paired11\n paired12 pastel13 pastel14 pastel15 pastel16 pastel17 pastel18 pastel19\n\n pastel23 pastel24 pastel25 pastel26 pastel27 pastel28\n\n piyg3 piyg4 piyg5 piyg6 piyg7 piyg8 piyg9 piyg10 piyg11\n\n prgn3 prgn4 prgn5 prgn6 prgn7 prgn8 prgn9 prgn10 prgn11\n\n pubu3 pubu4 pubu5 pubu6 pubu7 pubu8 pubu9\n\n pubugn3 pubugn4 pubugn5 pubugn6 pubugn7 pubugn8 pubugn9\n\n puor3 puor4 puor5 puor6 puor7 puor8 puor9 purd3 purd4 purd5 purd6 purd7 purd8\n purd9 puor10 puor11\n\n purples3 purples4 purples5 purples6 purples7 purples8 purples9\n\n rdbu10 rdbu11 rdbu3 rdbu4 rdbu5 rdbu6 rdbu7 rdbu8 rdbu9 rdgy3 rdgy4 rdgy5 rdgy6\n\n rdgy7 rdgy8 rdgy9 rdpu3 rdpu4 rdpu5 rdpu6 rdpu7 rdpu8 rdpu9 rdgy10 rdgy11\n\n rdylbu3 rdylbu4 rdylbu5 rdylbu6 rdylbu7 rdylbu8 rdylbu9 rdylbu10 rdylbu11\n\n rdylgn3 rdylgn4 rdylgn5 rdylgn6 rdylgn7 rdylgn8 rdylgn9 rdylgn10 rdylgn11\n\n reds3 reds4 reds5 reds6 reds7 reds8 reds9\n\n set13 set14 set15 set16 set17 set18 set19 set23 set24 set25 set26 set27 set28\n set33 set34 set35 set36 set37 set38 set39\n\n set310 set311 set312\n\n spectral3 spectral4 spectral5 spectral6 spectral7 spectral8 spectral9\n spectral10spectral11\n\n ylgn3 ylgn4 ylgn5 ylgn6 ylgn7 ylgn8 ylgn9\n\n ylgnbu3 ylgnbu4 ylgnbu5 ylgnbu6 ylgnbu7 ylgnbu8 ylgnbu9\n\n ylorbr3 ylorbr4 ylorbr5 ylorbr6 ylorbr7 ylorbr8 ylorbr9\n\n ylorrd3 ylorrd4 ylorrd5 ylorrd6 ylorrd7 ylorrd8 ylorrd9\n\n=head2 color_names()\n\n\tmy $names = Graph::Easy->color_names();\n\nReturn a hash with name => value mapping for all known colors.\n\n=head2 text_style()\n\n\tif ($graph->text_style('bold, italic'))\n\t  {\n\t  ...\n\t  }\n\nChecks the given style list for being valid.\n\n=head2 text_styles()\n\n\tmy $styles = $graph->text_styles();\t# or $edge->text_styles() etc.\n\n\tif ($styles->{'italic'})\n\t  {\n\t  print 'is italic\\n';\n\t  }\n\nReturn a hash with the given text-style properties, aka 'underline', 'bold' etc.\n\n=head2 text_styles_as_css()\n\n\tmy $styles = $graph->text_styles_as_css();\t# or $edge->...() etc.\n\nReturn the text styles as a chunk of CSS styling that can be embedded into\na C< style=\"\" > parameter.\n\n=head2 use_class()\n\n\t$graph->use_class('node', 'Graph::Easy::MyNode');\n\nOverride the class to be used to constructs objects when calling\nC<add_edge()>, C<add_group()> or C<add_node()>.\n\nThe first parameter can be one of the following:\n\n\tnode\n\tedge\n\tgroup\n\nPlease see the documentation about C<use_class()> in C<Graph::Easy::Parser>\nfor examples and details.\n\n=head2 animation_as_graph()\n\n\tmy $graph_2 = $graph->animation_as_graph();\n\tprint $graph_2->as_ascii();\n\nReturns the animation of C<$graph> as a graph describing the flow of the\nanimation. Useful for debugging animation flows.\n\n=head2 add_cycle()\n\n\t$graph->add_cycle('A','B','C');\t\t# A -> B -> C -> A\n\nCompatibility method for Graph, adds the edges between each node\nand back from the last node to the first. Returns the graph.\n\n=head2 add_path()\n\n\t$graph->add_path('A','B','C');\t\t# A -> B -> C\n\nCompatibility method for Graph, adds the edges between each node.\nReturns the graph.\n\n=head2 add_vertex()\n\n\t$graph->add_vertex('A');\n\nCompatibility method for Graph, adds the node and returns the graph.\n\n=head2 add_vertices()\n\n\t$graph->add_vertices('A','B');\n\nCompatibility method for Graph, adds these nodes and returns the graph.\n\n=head2 has_edge()\n\n\t$graph->has_edge('A','B');\n\nCompatibility method for Graph, returns true if at least one edge between\nA and B exists.\n\n=head2 vertices()\n\nCompatibility method for Graph, returns in scalar context the number\nof nodes this graph has, in list context a (arbitrarily sorted) list\nof node objects.\n\n=head2 set_vertex_attribute()\n\n\t$graph->set_vertex_attribute( 'A', 'fill', '#deadff' );\n\nCompatibility method for Graph, set the named vertex attribute.\n\nPlease note that this routine will only accept Graph::Easy attribute\nnames and values. If you want to attach custom attributes, you need to\nstart their name with 'x-':\n\n\t$graph->set_vertex_attribute( 'A', 'x-foo', 'bar' );\n\n=head2 get_vertex_attribute()\n\n\tmy $fill = $graph->get_vertex_attribute( 'A', 'fill' );\n\nCompatibility method for Graph, get the named vertex attribute.\n\nPlease note that this routine will only accept Graph::Easy attribute\nnames. See L<set_vertex_attribute()>.\n\n=head1 EXPORT\n\nExports nothing.\n\n=head1 SEE ALSO\n\nL<Graph>, L<Graph::Convert>, L<Graph::Easy::As_svg>, L<Graph::Easy::Manual> and\nL<Graph::Easy::Parser>.\n\n=head2 Related Projects\n\nL<Graph::Layout::Aesthetic>, L<Graph> and L<Text::Flowchart>.\n\nThere is also an very old, unrelated project from ca. 1995, which does something similar.\nSee L<http://rw4.cs.uni-sb.de/users/sander/html/gsvcg1.html>.\n\nTestcases and more examples under:\n\nL<http://bloodgate.com/perl/graph/>.\n\n=head1 LIMITATIONS\n\nThis module is now quite complete, but there are still some limitations.\nHopefully further development will lift these.\n\n=head2 Scoring\n\nScoring is not yet implemented, each generated graph will be the same regardless\nof the random seed.\n\n=head2 Layouter\n\nThe layouter can not yet handle links between groups (or between\na group and a node, or vice versa). These links will thus only\nappear in L<as_graphviz()> or L<as_txt()> output.\n\n=head2 Paths\n\n=over 2\n\n=item No optimizations\n\nIn complex graphs, non-optimal layout part like this one might appear:\n\n\t+------+     +--------+\n\t| Bonn | --> | Berlin | --> ...\n\t+------+     +--------+\n\t               ^\n\t               |\n\t               |\n\t+---------+    |\n\t| Kassel  | ---+\n\t+---------+\n\nA second-stage optimizer that simplifies these layouts is not yet implemented.\n\nIn addition the general placement/processing strategy as well as the local\nstrategy might be improved.\n\n=item attributes\n\nThe following attributes are currently ignored by the layouter:\n\n\tundirected graphs\n\tautosplit/autojoin for edges\n\ttail/head label/title/link for edges\n\n=item groups\n\nThe layouter is not fully recursive yet, so groups do not properly nest.\n\nIn addition, links to/from groups are missing, too.\n\n=back\n\n=head2 Output formats\n\nSome output formats are not yet complete in their\nimplementation. Please see the online manual at\nL<http://bloodgate.com/perl/graph/manual> under \"Output\" for\ndetails.\n\nX<graph>\nX<manual>\nX<online>\n\n=head1 LICENSE\n\nThis library is free software; you can redistribute it and/or modify\nit under the terms of the GPL 2.0 or a later version.\n\nSee the LICENSE file for a copy of the GPL.\n\nThis product includes color specifications and designs developed by Cynthia\nBrewer (http://colorbrewer.org/). See the LICENSE file for the full license\ntext that applies to these color schemes.\n\nX<gpl>\nX<apache-style>\nX<cynthia>\nX<brewer>\nX<colorscheme>\nX<license>\n\n=head1 NAME CHANGE\n\nThe package was formerly known as C<Graph::Simple>. The name was changed\nfor two reasons:\n\n=over 2\n\n=item *\n\nIn graph theory, a C<simple> graph is a special type of graph. This software,\nhowever, supports more than simple graphs.\n\n=item *\n\nCreating graphs should be easy even when the graphs are quite complex.\n\n=back\n\n=head1 AUTHOR\n\nCopyright (C) 2004 - 2008 by Tels L<http://bloodgate.com>\n\nX<tels>\n\n=cut\n"
};

/**
 * Load Graph::Easy modules into WebPerl's virtual filesystem
 * Call this after WebPerl is initialized but before running code
 */
window.loadGraphEasyModules = function() {
    if (typeof Module === 'undefined' || !Module.FS) {
        console.error('WebPerl not initialized. Call this after Perl.init()');
        return false;
    }

    const FS = Module.FS;

    // Create directory structure
    const dirs = new Set();
    for (const modulePath of Object.keys(window.GraphEasyModules)) {
        const dir = modulePath.substring(0, modulePath.lastIndexOf('/'));
        if (dir) {
            let current = '';
            for (const part of dir.split('/')) {
                current = current ? current + '/' + part : part;
                dirs.add(current);
            }
        }
    }

    // Create directories in the virtual filesystem
    for (const dir of Array.from(dirs).sort()) {
        const fullPath = '/lib/' + dir;
        try {
            FS.mkdir(fullPath);
        } catch (e) {
            // Directory might already exist
        }
    }

    // Write module files
    for (const [modulePath, content] of Object.entries(window.GraphEasyModules)) {
        const fullPath = '/lib/' + modulePath;
        try {
            FS.writeFile(fullPath, content);
            console.log('Loaded:', fullPath);
        } catch (e) {
            console.error('Failed to load:', fullPath, e);
        }
    }

    return true;
};
